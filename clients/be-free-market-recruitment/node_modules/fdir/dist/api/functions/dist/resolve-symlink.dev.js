"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.build = build;

var fs_1 = __importDefault(require("fs"));

var path_1 = require("path");

var resolveSymlinksAsync = function resolveSymlinksAsync(path, state, callback) {
  var queue = state.queue,
      suppressErrors = state.options.suppressErrors;
  queue.enqueue();
  fs_1["default"].realpath(path, function (error, resolvedPath) {
    if (error) return queue.dequeue(suppressErrors ? null : error, state);
    fs_1["default"].stat(resolvedPath, function (error, stat) {
      if (error) return queue.dequeue(suppressErrors ? null : error, state);
      if (stat.isDirectory() && isRecursive(path, resolvedPath, state)) return queue.dequeue(null, state);
      callback(stat, resolvedPath);
      queue.dequeue(null, state);
    });
  });
};

var resolveSymlinks = function resolveSymlinks(path, state, callback) {
  var queue = state.queue,
      suppressErrors = state.options.suppressErrors;
  queue.enqueue();

  try {
    var resolvedPath = fs_1["default"].realpathSync(path);
    var stat = fs_1["default"].statSync(resolvedPath);
    if (stat.isDirectory() && isRecursive(path, resolvedPath, state)) return;
    callback(stat, resolvedPath);
  } catch (e) {
    if (!suppressErrors) throw e;
  }
};

function build(options, isSynchronous) {
  if (!options.resolveSymlinks || options.excludeSymlinks) return null;
  return isSynchronous ? resolveSymlinks : resolveSymlinksAsync;
}

function isRecursive(path, resolved, state) {
  if (state.options.useRealPaths) return isRecursiveUsingRealPaths(resolved, state);
  var parent = (0, path_1.dirname)(path);
  var depth = 1;

  while (parent !== state.root && depth < 2) {
    var resolvedPath = state.symlinks.get(parent);
    var isSameRoot = !!resolvedPath && (resolvedPath === resolved || resolvedPath.startsWith(resolved) || resolved.startsWith(resolvedPath));
    if (isSameRoot) depth++;else parent = (0, path_1.dirname)(parent);
  }

  state.symlinks.set(path, resolved);
  return depth > 1;
}

function isRecursiveUsingRealPaths(resolved, state) {
  return state.visited.includes(resolved + state.options.pathSeparator);
}