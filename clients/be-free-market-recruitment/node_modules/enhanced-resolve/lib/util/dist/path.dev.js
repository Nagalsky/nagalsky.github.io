/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

var path = require("path");

var CHAR_HASH = "#".charCodeAt(0);
var CHAR_SLASH = "/".charCodeAt(0);
var CHAR_BACKSLASH = "\\".charCodeAt(0);
var CHAR_A = "A".charCodeAt(0);
var CHAR_Z = "Z".charCodeAt(0);
var CHAR_LOWER_A = "a".charCodeAt(0);
var CHAR_LOWER_Z = "z".charCodeAt(0);
var CHAR_DOT = ".".charCodeAt(0);
var CHAR_COLON = ":".charCodeAt(0);
var posixNormalize = path.posix.normalize;
var winNormalize = path.win32.normalize;
/**
 * @enum {number}
 */

var PathType = Object.freeze({
  Empty: 0,
  Normal: 1,
  Relative: 2,
  AbsoluteWin: 3,
  AbsolutePosix: 4,
  Internal: 5
});
exports.PathType = PathType;
var invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
exports.invalidSegmentRegEx = invalidSegmentRegEx;
var deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
exports.deprecatedInvalidSegmentRegEx = deprecatedInvalidSegmentRegEx;
/**
 * @param {string} p a path
 * @returns {PathType} type of path
 */

var getType = function getType(p) {
  switch (p.length) {
    case 0:
      return PathType.Empty;

    case 1:
      {
        var _c = p.charCodeAt(0);

        switch (_c) {
          case CHAR_DOT:
            return PathType.Relative;

          case CHAR_SLASH:
            return PathType.AbsolutePosix;

          case CHAR_HASH:
            return PathType.Internal;
        }

        return PathType.Normal;
      }

    case 2:
      {
        var _c2 = p.charCodeAt(0);

        switch (_c2) {
          case CHAR_DOT:
            {
              var _c4 = p.charCodeAt(1);

              switch (_c4) {
                case CHAR_DOT:
                case CHAR_SLASH:
                  return PathType.Relative;
              }

              return PathType.Normal;
            }

          case CHAR_SLASH:
            return PathType.AbsolutePosix;

          case CHAR_HASH:
            return PathType.Internal;
        }

        var _c3 = p.charCodeAt(1);

        if (_c3 === CHAR_COLON) {
          if (_c2 >= CHAR_A && _c2 <= CHAR_Z || _c2 >= CHAR_LOWER_A && _c2 <= CHAR_LOWER_Z) {
            return PathType.AbsoluteWin;
          }
        }

        return PathType.Normal;
      }
  }

  var c0 = p.charCodeAt(0);

  switch (c0) {
    case CHAR_DOT:
      {
        var _c5 = p.charCodeAt(1);

        switch (_c5) {
          case CHAR_SLASH:
            return PathType.Relative;

          case CHAR_DOT:
            {
              var c2 = p.charCodeAt(2);
              if (c2 === CHAR_SLASH) return PathType.Relative;
              return PathType.Normal;
            }
        }

        return PathType.Normal;
      }

    case CHAR_SLASH:
      return PathType.AbsolutePosix;

    case CHAR_HASH:
      return PathType.Internal;
  }

  var c1 = p.charCodeAt(1);

  if (c1 === CHAR_COLON) {
    var _c6 = p.charCodeAt(2);

    if ((_c6 === CHAR_BACKSLASH || _c6 === CHAR_SLASH) && (c0 >= CHAR_A && c0 <= CHAR_Z || c0 >= CHAR_LOWER_A && c0 <= CHAR_LOWER_Z)) {
      return PathType.AbsoluteWin;
    }
  }

  return PathType.Normal;
};

exports.getType = getType;
/**
 * @param {string} p a path
 * @returns {string} the normalized path
 */

var normalize = function normalize(p) {
  switch (getType(p)) {
    case PathType.Empty:
      return p;

    case PathType.AbsoluteWin:
      return winNormalize(p);

    case PathType.Relative:
      {
        var r = posixNormalize(p);
        return getType(r) === PathType.Relative ? r : "./".concat(r);
      }
  }

  return posixNormalize(p);
};

exports.normalize = normalize;
/**
 * @param {string} rootPath the root path
 * @param {string | undefined} request the request path
 * @returns {string} the joined path
 */

var join = function join(rootPath, request) {
  if (!request) return normalize(rootPath);
  var requestType = getType(request);

  switch (requestType) {
    case PathType.AbsolutePosix:
      return posixNormalize(request);

    case PathType.AbsoluteWin:
      return winNormalize(request);
  }

  switch (getType(rootPath)) {
    case PathType.Normal:
    case PathType.Relative:
    case PathType.AbsolutePosix:
      return posixNormalize("".concat(rootPath, "/").concat(request));

    case PathType.AbsoluteWin:
      return winNormalize("".concat(rootPath, "\\").concat(request));
  }

  switch (requestType) {
    case PathType.Empty:
      return rootPath;

    case PathType.Relative:
      {
        var r = posixNormalize(rootPath);
        return getType(r) === PathType.Relative ? r : "./".concat(r);
      }
  }

  return posixNormalize(rootPath);
};

exports.join = join;
/** @type {Map<string, Map<string, string | undefined>>} */

var joinCache = new Map();
/**
 * @param {string} rootPath the root path
 * @param {string} request the request path
 * @returns {string} the joined path
 */

var cachedJoin = function cachedJoin(rootPath, request) {
  /** @type {string | undefined} */
  var cacheEntry;
  var cache = joinCache.get(rootPath);

  if (cache === undefined) {
    joinCache.set(rootPath, cache = new Map());
  } else {
    cacheEntry = cache.get(request);
    if (cacheEntry !== undefined) return cacheEntry;
  }

  cacheEntry = join(rootPath, request);
  cache.set(request, cacheEntry);
  return cacheEntry;
};

exports.cachedJoin = cachedJoin;