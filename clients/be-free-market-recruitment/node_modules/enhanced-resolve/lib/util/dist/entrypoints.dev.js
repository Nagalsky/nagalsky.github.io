/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Ivan Kopeykin @vankop
*/
"use strict";
/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */

/** @typedef {{[k: string]: MappingValue}} ConditionalMapping */

/** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */

/** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */

/** @typedef {Record<string, MappingValue>} ImportsField */

/**
 * Processing exports/imports field
 * @callback FieldProcessor
 * @param {string} request request
 * @param {Set<string>} conditionNames condition names
 * @returns {[string[], string | null]} resolved paths with used field
 */

/*
Example exports field:
{
  ".": "./main.js",
  "./feature": {
    "browser": "./feature-browser.js",
    "default": "./feature.js"
  }
}
Terminology:

Enhanced-resolve name keys ("." and "./feature") as exports field keys.

If value is string or string[], mapping is called as a direct mapping
and value called as a direct export.

If value is key-value object, mapping is called as a conditional mapping
and value called as a conditional export.

Key in conditional mapping is called condition name.

Conditional mapping nested in another conditional mapping is called nested mapping.

----------

Example imports field:
{
  "#a": "./main.js",
  "#moment": {
    "browser": "./moment/index.js",
    "default": "moment"
  },
  "#moment/": {
    "browser": "./moment/",
    "default": "moment/"
  }
}
Terminology:

Enhanced-resolve name keys ("#a" and "#moment/", "#moment") as imports field keys.

If value is string or string[], mapping is called as a direct mapping
and value called as a direct export.

If value is key-value object, mapping is called as a conditional mapping
and value called as a conditional export.

Key in conditional mapping is called condition name.

Conditional mapping nested in another conditional mapping is called nested mapping.

*/

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _require = require("./identifier"),
    parseIdentifier = _require.parseIdentifier;

var slashCode = "/".charCodeAt(0);
var dotCode = ".".charCodeAt(0);
var hashCode = "#".charCodeAt(0);
var patternRegEx = /\*/g;
/**
 * @param {ExportsField} exportsField the exports field
 * @returns {FieldProcessor} process callback
 */

module.exports.processExportsField = function processExportsField(exportsField) {
  return createFieldProcessor(buildExportsField(exportsField), function (request) {
    return request.length === 0 ? "." : "./" + request;
  }, assertExportsFieldRequest, assertExportTarget);
};
/**
 * @param {ImportsField} importsField the exports field
 * @returns {FieldProcessor} process callback
 */


module.exports.processImportsField = function processImportsField(importsField) {
  return createFieldProcessor(importsField, function (request) {
    return "#" + request;
  }, assertImportsFieldRequest, assertImportTarget);
};
/**
 * @param {ExportsField | ImportsField} field root
 * @param {(s: string) => string} normalizeRequest Normalize request, for `imports` field it adds `#`, for `exports` field it adds `.` or `./`
 * @param {(s: string) => string} assertRequest assertRequest
 * @param {(s: string, f: boolean) => void} assertTarget assertTarget
 * @returns {FieldProcessor} field processor
 */


function createFieldProcessor(field, normalizeRequest, assertRequest, assertTarget) {
  return function fieldProcessor(request, conditionNames) {
    request = assertRequest(request);
    var match = findMatch(normalizeRequest(request), field);
    if (match === null) return [[], null];

    var _match = _slicedToArray(match, 5),
        mapping = _match[0],
        remainingRequest = _match[1],
        isSubpathMapping = _match[2],
        isPattern = _match[3],
        usedField = _match[4];
    /** @type {DirectMapping|null} */


    var direct = null;

    if (isConditionalMapping(mapping)) {
      direct = conditionalMapping(
      /** @type {ConditionalMapping} */
      mapping, conditionNames); // matching not found

      if (direct === null) return [[], null];
    } else {
      direct =
      /** @type {DirectMapping} */
      mapping;
    }

    return [directMapping(remainingRequest, isPattern, isSubpathMapping, direct, conditionNames, assertTarget), usedField];
  };
}
/**
 * @param {string} request request
 * @returns {string} updated request
 */


function assertExportsFieldRequest(request) {
  if (request.charCodeAt(0) !== dotCode) {
    throw new Error('Request should be relative path and start with "."');
  }

  if (request.length === 1) return "";

  if (request.charCodeAt(1) !== slashCode) {
    throw new Error('Request should be relative path and start with "./"');
  }

  if (request.charCodeAt(request.length - 1) === slashCode) {
    throw new Error("Only requesting file allowed");
  }

  return request.slice(2);
}
/**
 * @param {string} request request
 * @returns {string} updated request
 */


function assertImportsFieldRequest(request) {
  if (request.charCodeAt(0) !== hashCode) {
    throw new Error('Request should start with "#"');
  }

  if (request.length === 1) {
    throw new Error("Request should have at least 2 characters");
  }

  if (request.charCodeAt(1) === slashCode) {
    throw new Error('Request should not start with "#/"');
  }

  if (request.charCodeAt(request.length - 1) === slashCode) {
    throw new Error("Only requesting file allowed");
  }

  return request.slice(1);
}
/**
 * @param {string} exp export target
 * @param {boolean} expectFolder is folder expected
 */


function assertExportTarget(exp, expectFolder) {
  var parsedIdentifier = parseIdentifier(exp);

  if (!parsedIdentifier) {
    return;
  }

  var _parsedIdentifier = _slicedToArray(parsedIdentifier, 1),
      relativePath = _parsedIdentifier[0];

  var isFolder = relativePath.charCodeAt(relativePath.length - 1) === slashCode;

  if (isFolder !== expectFolder) {
    throw new Error(expectFolder ? "Expecting folder to folder mapping. ".concat(JSON.stringify(exp), " should end with \"/\"") : "Expecting file to file mapping. ".concat(JSON.stringify(exp), " should not end with \"/\""));
  }
}
/**
 * @param {string} imp import target
 * @param {boolean} expectFolder is folder expected
 */


function assertImportTarget(imp, expectFolder) {
  var parsedIdentifier = parseIdentifier(imp);

  if (!parsedIdentifier) {
    return;
  }

  var _parsedIdentifier2 = _slicedToArray(parsedIdentifier, 1),
      relativePath = _parsedIdentifier2[0];

  var isFolder = relativePath.charCodeAt(relativePath.length - 1) === slashCode;

  if (isFolder !== expectFolder) {
    throw new Error(expectFolder ? "Expecting folder to folder mapping. ".concat(JSON.stringify(imp), " should end with \"/\"") : "Expecting file to file mapping. ".concat(JSON.stringify(imp), " should not end with \"/\""));
  }
}
/**
 * @param {string} a first string
 * @param {string} b second string
 * @returns {number} compare result
 */


function patternKeyCompare(a, b) {
  var aPatternIndex = a.indexOf("*");
  var bPatternIndex = b.indexOf("*");
  var baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  var baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLenA > baseLenB) return -1;
  if (baseLenB > baseLenA) return 1;
  if (aPatternIndex === -1) return 1;
  if (bPatternIndex === -1) return -1;
  if (a.length > b.length) return -1;
  if (b.length > a.length) return 1;
  return 0;
}
/**
 * Trying to match request to field
 * @param {string} request request
 * @param {ExportsField | ImportsField} field exports or import field
 * @returns {[MappingValue, string, boolean, boolean, string]|null} match or null, number is negative and one less when it's a folder mapping, number is request.length + 1 for direct mappings
 */


function findMatch(request, field) {
  if (Object.prototype.hasOwnProperty.call(field, request) && !request.includes("*") && !request.endsWith("/")) {
    var _target =
    /** @type {{[k: string]: MappingValue}} */
    field[request];
    return [_target, "", false, false, request];
  }
  /** @type {string} */


  var bestMatch = "";
  /** @type {string|undefined} */

  var bestMatchSubpath;
  var keys = Object.getOwnPropertyNames(field);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var patternIndex = key.indexOf("*");

    if (patternIndex !== -1 && request.startsWith(key.slice(0, patternIndex))) {
      var patternTrailer = key.slice(patternIndex + 1);

      if (request.length >= key.length && request.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = request.slice(patternIndex, request.length - patternTrailer.length);
      }
    } // For legacy `./foo/`
    else if (key[key.length - 1] === "/" && request.startsWith(key) && patternKeyCompare(bestMatch, key) === 1) {
        bestMatch = key;
        bestMatchSubpath = request.slice(key.length);
      }
  }

  if (bestMatch === "") return null;
  var target =
  /** @type {{[k: string]: MappingValue}} */
  field[bestMatch];
  var isSubpathMapping = bestMatch.endsWith("/");
  var isPattern = bestMatch.includes("*");
  return [target,
  /** @type {string} */
  bestMatchSubpath, isSubpathMapping, isPattern, bestMatch];
}
/**
 * @param {ConditionalMapping|DirectMapping|null} mapping mapping
 * @returns {boolean} is conditional mapping
 */


function isConditionalMapping(mapping) {
  return mapping !== null && _typeof(mapping) === "object" && !Array.isArray(mapping);
}
/**
 * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings
 * @param {boolean} isPattern true, if mapping is a pattern (contains "*")
 * @param {boolean} isSubpathMapping true, for subpath mappings
 * @param {DirectMapping|null} mappingTarget direct export
 * @param {Set<string>} conditionNames condition names
 * @param {(d: string, f: boolean) => void} assert asserting direct value
 * @returns {string[]} mapping result
 */


function directMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, conditionNames, assert) {
  if (mappingTarget === null) return [];

  if (typeof mappingTarget === "string") {
    return [targetMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, assert)];
  }
  /** @type {string[]} */


  var targets = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = mappingTarget[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var exp = _step.value;

      if (typeof exp === "string") {
        targets.push(targetMapping(remainingRequest, isPattern, isSubpathMapping, exp, assert));
        continue;
      }

      var mapping = conditionalMapping(exp, conditionNames);
      if (!mapping) continue;
      var innerExports = directMapping(remainingRequest, isPattern, isSubpathMapping, mapping, conditionNames, assert);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = innerExports[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var innerExport = _step2.value;
          targets.push(innerExport);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return targets;
}
/**
 * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings
 * @param {boolean} isPattern true, if mapping is a pattern (contains "*")
 * @param {boolean} isSubpathMapping true, for subpath mappings
 * @param {string} mappingTarget direct export
 * @param {(d: string, f: boolean) => void} assert asserting direct value
 * @returns {string} mapping result
 */


function targetMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, assert) {
  if (remainingRequest === undefined) {
    assert(mappingTarget, false);
    return mappingTarget;
  }

  if (isSubpathMapping) {
    assert(mappingTarget, true);
    return mappingTarget + remainingRequest;
  }

  assert(mappingTarget, false);
  var result = mappingTarget;

  if (isPattern) {
    result = result.replace(patternRegEx, remainingRequest.replace(/\$/g, "$$"));
  }

  return result;
}
/**
 * @param {ConditionalMapping} conditionalMapping_ conditional mapping
 * @param {Set<string>} conditionNames condition names
 * @returns {DirectMapping|null} direct mapping if found
 */


function conditionalMapping(conditionalMapping_, conditionNames) {
  /** @type {[ConditionalMapping, string[], number][]} */
  var lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];

  loop: while (lookup.length > 0) {
    var _lookup = _slicedToArray(lookup[lookup.length - 1], 3),
        mapping = _lookup[0],
        conditions = _lookup[1],
        j = _lookup[2];

    for (var i = j; i < conditions.length; i++) {
      var condition = conditions[i];

      if (condition === "default") {
        var innerMapping = mapping[condition]; // is nested

        if (isConditionalMapping(innerMapping)) {
          var _conditionalMapping =
          /** @type {ConditionalMapping} */
          innerMapping;
          lookup[lookup.length - 1][2] = i + 1;
          lookup.push([_conditionalMapping, Object.keys(_conditionalMapping), 0]);
          continue loop;
        }

        return (
          /** @type {DirectMapping} */
          innerMapping
        );
      }

      if (conditionNames.has(condition)) {
        var _innerMapping = mapping[condition]; // is nested

        if (isConditionalMapping(_innerMapping)) {
          var _conditionalMapping2 =
          /** @type {ConditionalMapping} */
          _innerMapping;
          lookup[lookup.length - 1][2] = i + 1;
          lookup.push([_conditionalMapping2, Object.keys(_conditionalMapping2), 0]);
          continue loop;
        }

        return (
          /** @type {DirectMapping} */
          _innerMapping
        );
      }
    }

    lookup.pop();
  }

  return null;
}
/**
 * @param {ExportsField} field exports field
 * @returns {ExportsField} normalized exports field
 */


function buildExportsField(field) {
  // handle syntax sugar, if exports field is direct mapping for "."
  if (typeof field === "string" || Array.isArray(field)) {
    return {
      ".": field
    };
  }

  var keys = Object.keys(field);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];

    if (key.charCodeAt(0) !== dotCode) {
      // handle syntax sugar, if exports field is conditional mapping for "."
      if (i === 0) {
        while (i < keys.length) {
          var charCode = keys[i].charCodeAt(0);

          if (charCode === dotCode || charCode === slashCode) {
            throw new Error("Exports field key should be relative path and start with \".\" (key: ".concat(JSON.stringify(key), ")"));
          }

          i++;
        }

        return {
          ".": field
        };
      }

      throw new Error("Exports field key should be relative path and start with \".\" (key: ".concat(JSON.stringify(key), ")"));
    }

    if (key.length === 1) {
      continue;
    }

    if (key.charCodeAt(1) !== slashCode) {
      throw new Error("Exports field key should be relative path and start with \"./\" (key: ".concat(JSON.stringify(key), ")"));
    }
  }

  return field;
}