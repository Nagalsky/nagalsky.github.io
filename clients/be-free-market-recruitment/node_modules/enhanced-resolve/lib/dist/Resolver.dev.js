/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require("tapable"),
    AsyncSeriesBailHook = _require.AsyncSeriesBailHook,
    AsyncSeriesHook = _require.AsyncSeriesHook,
    SyncHook = _require.SyncHook;

var createInnerContext = require("./createInnerContext");

var _require2 = require("./util/identifier"),
    parseIdentifier = _require2.parseIdentifier;

var _require3 = require("./util/path"),
    _normalize = _require3.normalize,
    _join = _require3.cachedJoin,
    getType = _require3.getType,
    PathType = _require3.PathType;
/** @typedef {import("./ResolverFactory").ResolveOptions} ResolveOptions */

/** @typedef {Error & { details?: string }} ErrorWithDetail */

/** @typedef {(err: ErrorWithDetail | null, res?: string | false, req?: ResolveRequest) => void} ResolveCallback */

/**
 * @typedef {Object} PossibleFileSystemError
 * @property {string=} code
 * @property {number=} errno
 * @property {string=} path
 * @property {string=} syscall
 */

/**
 * @template T
 * @callback FileSystemCallback
 * @param {PossibleFileSystemError & Error | null} err
 * @param {T=} result
 */

/**
 * @typedef {string | Buffer | URL} PathLike
 */

/**
 * @typedef {PathLike | number} PathOrFileDescriptor
 */

/**
 * @typedef {Object} ObjectEncodingOptions
 * @property {BufferEncoding | null | undefined} [encoding]
 */

/** @typedef {function(NodeJS.ErrnoException | null, string=): void} StringCallback */

/** @typedef {function(NodeJS.ErrnoException | null, Buffer=): void} BufferCallback */

/** @typedef {function(NodeJS.ErrnoException | null, (string | Buffer)=): void} StringOrBufferCallback */

/** @typedef {function(NodeJS.ErrnoException | null, IStats=): void} StatsCallback */

/** @typedef {function(NodeJS.ErrnoException | null, IBigIntStats=): void} BigIntStatsCallback */

/** @typedef {function(NodeJS.ErrnoException | null, (IStats | IBigIntStats)=): void} StatsOrBigIntStatsCallback */

/** @typedef {function(NodeJS.ErrnoException | Error | null, JsonObject=): void} ReadJsonCallback */

/** @typedef {function(NodeJS.ErrnoException | null, string[]=): void} ReaddirStringCallback */

/** @typedef {function(NodeJS.ErrnoException | null, Buffer[]=): void} ReaddirBufferCallback */

/** @typedef {function(NodeJS.ErrnoException | null, (string[] | Buffer[])=): void} ReaddirStringOrBufferCallback */

/** @typedef {function(NodeJS.ErrnoException | null, Dirent[]=): void} ReaddirDirentCallback */

/**
 * @template T
 * @typedef {Object} IStatsBase
 * @property {() => boolean} isFile
 * @property {() => boolean} isDirectory
 * @property {() => boolean} isBlockDevice
 * @property {() => boolean} isCharacterDevice
 * @property {() => boolean} isSymbolicLink
 * @property {() => boolean} isFIFO
 * @property {() => boolean} isSocket
 * @property {T} dev
 * @property {T} ino
 * @property {T} mode
 * @property {T} nlink
 * @property {T} uid
 * @property {T} gid
 * @property {T} rdev
 * @property {T} size
 * @property {T} blksize
 * @property {T} blocks
 * @property {T} atimeMs
 * @property {T} mtimeMs
 * @property {T} ctimeMs
 * @property {T} birthtimeMs
 * @property {Date} atime
 * @property {Date} mtime
 * @property {Date} ctime
 * @property {Date} birthtime
 */

/**
 * @typedef {IStatsBase<number>} IStats
 */

/**
 * @typedef {IStatsBase<bigint> & { atimeNs: bigint, mtimeNs: bigint, ctimeNs: bigint, birthtimeNs: bigint  }} IBigIntStats
 */

/**
 * @typedef {Object} Dirent
 * @property {() => boolean} isFile
 * @property {() => boolean} isDirectory
 * @property {() => boolean} isBlockDevice
 * @property {() => boolean} isCharacterDevice
 * @property {() => boolean} isSymbolicLink
 * @property {() => boolean} isFIFO
 * @property {() => boolean} isSocket
 * @property {string} name
 * @property {string} path
 */

/**
 * @typedef {Object} StatOptions
 * @property {(boolean | undefined)=} bigint
 */

/**
 * @typedef {Object} StatSyncOptions
 * @property {(boolean | undefined)=} bigint
 * @property {(boolean | undefined)=} throwIfNoEntry
 */

/**
 * @typedef {{
 * (path: PathOrFileDescriptor, options: ({ encoding?: null | undefined, flag?: string | undefined } & import("events").Abortable) | undefined | null, callback: BufferCallback): void;
 * (path: PathOrFileDescriptor, options: ({ encoding: BufferEncoding, flag?: string | undefined } & import("events").Abortable) | BufferEncoding, callback: StringCallback): void;
 * (path: PathOrFileDescriptor, options: (ObjectEncodingOptions & { flag?: string | undefined } & import("events").Abortable) | BufferEncoding | undefined | null, callback: StringOrBufferCallback): void;
 * (path: PathOrFileDescriptor, callback: BufferCallback): void;
 * }} ReadFile
 */

/**
 * @typedef {ObjectEncodingOptions | BufferEncoding | undefined | null} EncodingOption
 */

/**
 * @typedef {'buffer'| { encoding: 'buffer' }} BufferEncodingOption
 */

/**
 * @typedef {{
 * (path: PathOrFileDescriptor, options?: { encoding?: null | undefined, flag?: string | undefined } | null): Buffer;
 * (path: PathOrFileDescriptor, options: { encoding: BufferEncoding, flag?: string | undefined } | BufferEncoding): string;
 * (path: PathOrFileDescriptor, options?: (ObjectEncodingOptions & { flag?: string | undefined }) | BufferEncoding | null): string | Buffer;
 * }} ReadFileSync
 */

/**
 * @typedef {{
 * (path: PathLike, options: { encoding: BufferEncoding | null, withFileTypes?: false | undefined, recursive?: boolean | undefined } | BufferEncoding | undefined | null, callback: ReaddirStringCallback): void;
 * (path: PathLike, options: { encoding: 'buffer', withFileTypes?: false | undefined, recursive?: boolean | undefined } | 'buffer', callback: ReaddirBufferCallback): void;
 * (path: PathLike, callback: ReaddirStringCallback): void;
 * (path: PathLike, options: (ObjectEncodingOptions & { withFileTypes?: false | undefined, recursive?: boolean | undefined }) | BufferEncoding | undefined | null, callback: ReaddirStringOrBufferCallback): void;
 * (path: PathLike, options: ObjectEncodingOptions & { withFileTypes: true, recursive?: boolean | undefined }, callback: ReaddirDirentCallback): void;
 * }} Readdir
 */

/**
 * @typedef {{
 * (path: PathLike, options?: { encoding: BufferEncoding | null, withFileTypes?: false | undefined, recursive?: boolean | undefined } | BufferEncoding | null): string[];
 * (path: PathLike, options: { encoding: 'buffer', withFileTypes?: false | undefined, recursive?: boolean | undefined } | 'buffer'): Buffer[];
 * (path: PathLike, options?: (ObjectEncodingOptions & { withFileTypes?: false | undefined, recursive?: boolean | undefined }) | BufferEncoding | null): string[] | Buffer[];
 * (path: PathLike, options: ObjectEncodingOptions & { withFileTypes: true, recursive?: boolean | undefined }): Dirent[];
 * }} ReaddirSync

 /**
 * @typedef {function(PathOrFileDescriptor, ReadJsonCallback): void} ReadJson
 */

/**
 * @typedef {function(PathOrFileDescriptor): JsonObject} ReadJsonSync
 */

/**
 * @typedef {{
 * (path: PathLike, options: EncodingOption, callback: StringCallback): void;
 * (path: PathLike, options: BufferEncodingOption, callback: BufferCallback): void;
 * (path: PathLike, options: EncodingOption, callback: StringOrBufferCallback): void;
 * (path: PathLike, callback: StringCallback): void;
 * }} Readlink
 */

/**
 * @typedef {{
 * (path: PathLike, options?: EncodingOption): string;
 * (path: PathLike, options: BufferEncodingOption): Buffer;
 * (path: PathLike, options?: EncodingOption): string | Buffer;
 * }} ReadlinkSync
 */

/**
 * @typedef {{
 * (path: PathLike, callback: StatsCallback): void;
 * (path: PathLike, options: (StatOptions & { bigint?: false | undefined }) | undefined, callback: StatsCallback): void;
 * (path: PathLike, options: StatOptions & { bigint: true }, callback: BigIntStatsCallback): void;
 * (path: PathLike, options: StatOptions | undefined, callback: StatsOrBigIntStatsCallback): void;
 * }} LStat
 */

/**
 * @typedef {{
 * (path: PathLike, options?: undefined): IStats;
 * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined, throwIfNoEntry: false }): IStats | undefined;
 * (path: PathLike, options: StatSyncOptions & { bigint: true, throwIfNoEntry: false }): IBigIntStats | undefined;
 * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined }): IStats;
 * (path: PathLike, options: StatSyncOptions & { bigint: true }): IBigIntStats;
 * (path: PathLike,  options: StatSyncOptions & { bigint: boolean, throwIfNoEntry?: false | undefined }): IStats | IBigIntStats;
 * (path: PathLike,  options?: StatSyncOptions): IStats | IBigIntStats | undefined;
 * }} LStatSync
 */

/**
 * @typedef {{
 * (path: PathLike, callback: StatsCallback): void;
 * (path: PathLike, options: (StatOptions & { bigint?: false | undefined }) | undefined, callback: StatsCallback): void;
 * (path: PathLike, options: StatOptions & { bigint: true }, callback: BigIntStatsCallback): void;
 * (path: PathLike, options: StatOptions | undefined, callback: StatsOrBigIntStatsCallback): void;
 * }} Stat
 */

/**
 * @typedef {{
 * (path: PathLike, options?: undefined): IStats;
 * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined, throwIfNoEntry: false }): IStats | undefined;
 * (path: PathLike, options: StatSyncOptions & { bigint: true, throwIfNoEntry: false }): IBigIntStats | undefined;
 * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined }): IStats;
 * (path: PathLike, options: StatSyncOptions & { bigint: true }): IBigIntStats;
 * (path: PathLike,  options: StatSyncOptions & { bigint: boolean, throwIfNoEntry?: false | undefined }): IStats | IBigIntStats;
 * (path: PathLike,  options?: StatSyncOptions): IStats | IBigIntStats | undefined;
 * }} StatSync
 */

/**
 * @typedef {{
 * (path: PathLike, options: EncodingOption, callback: StringCallback): void;
 * (path: PathLike, options: BufferEncodingOption, callback: BufferCallback): void;
 * (path: PathLike, options: EncodingOption, callback: StringOrBufferCallback): void;
 * (path: PathLike, callback: StringCallback): void;
 * }} RealPath
 */

/**
 * @typedef {{
 * (path: PathLike, options?: EncodingOption): string;
 * (path: PathLike, options: BufferEncodingOption): Buffer;
 * (path: PathLike, options?: EncodingOption): string | Buffer;
 * }} RealPathSync
 */

/**
 * @typedef {Object} FileSystem
 * @property {ReadFile} readFile
 * @property {Readdir} readdir
 * @property {ReadJson=} readJson
 * @property {Readlink} readlink
 * @property {LStat=} lstat
 * @property {Stat} stat
 * @property {RealPath=} realpath
 */

/**
 * @typedef {Object} SyncFileSystem
 * @property {ReadFileSync} readFileSync
 * @property {ReaddirSync} readdirSync
 * @property {ReadJsonSync=} readJsonSync
 * @property {ReadlinkSync} readlinkSync
 * @property {LStatSync=} lstatSync
 * @property {StatSync} statSync
 * @property {RealPathSync=} realpathSync
 */

/**
 * @typedef {Object} ParsedIdentifier
 * @property {string} request
 * @property {string} query
 * @property {string} fragment
 * @property {boolean} directory
 * @property {boolean} module
 * @property {boolean} file
 * @property {boolean} internal
 */

/** @typedef {string | number | boolean | null} JsonPrimitive */

/** @typedef {JsonValue[]} JsonArray */

/** @typedef {JsonPrimitive | JsonObject | JsonArray} JsonValue */

/** @typedef {{[Key in string]: JsonValue} & {[Key in string]?: JsonValue | undefined}} JsonObject */

/**
 * @typedef {Object} BaseResolveRequest
 * @property {string | false} path
 * @property {object=} context
 * @property {string=} descriptionFilePath
 * @property {string=} descriptionFileRoot
 * @property {JsonObject=} descriptionFileData
 * @property {string=} relativePath
 * @property {boolean=} ignoreSymlinks
 * @property {boolean=} fullySpecified
 * @property {string=} __innerRequest
 * @property {string=} __innerRequest_request
 * @property {string=} __innerRequest_relativePath
 */

/** @typedef {BaseResolveRequest & Partial<ParsedIdentifier>} ResolveRequest */

/**
 * String with special formatting
 * @typedef {string} StackEntry
 */

/**
 * @template T
 * @typedef {{ add: (item: T) => void }} WriteOnlySet
 */

/** @typedef {(function (ResolveRequest): void)} ResolveContextYield */

/**
 * Resolve context
 * @typedef {Object} ResolveContext
 * @property {WriteOnlySet<string>=} contextDependencies
 * @property {WriteOnlySet<string>=} fileDependencies files that was found on file system
 * @property {WriteOnlySet<string>=} missingDependencies dependencies that was not found on file system
 * @property {Set<StackEntry>=} stack set of hooks' calls. For instance, `resolve → parsedResolve → describedResolve`,
 * @property {(function(string): void)=} log log function
 * @property {ResolveContextYield=} yield yield result, if provided plugins can return several results
 */

/** @typedef {AsyncSeriesBailHook<[ResolveRequest, ResolveContext], ResolveRequest | null>} ResolveStepHook */

/**
 * @typedef {Object} KnownHooks
 * @property {SyncHook<[ResolveStepHook, ResolveRequest], void>} resolveStep
 * @property {SyncHook<[ResolveRequest, Error]>} noResolve
 * @property {ResolveStepHook} resolve
 * @property {AsyncSeriesHook<[ResolveRequest, ResolveContext]>} result
 */

/**
 * @typedef {{[key: string]: ResolveStepHook}} EnsuredHooks
 */

/**
 * @param {string} str input string
 * @returns {string} in camel case
 */


function toCamelCase(str) {
  return str.replace(/-([a-z])/g, function (str) {
    return str.slice(1).toUpperCase();
  });
}

var Resolver =
/*#__PURE__*/
function () {
  _createClass(Resolver, null, [{
    key: "createStackEntry",

    /**
     * @param {ResolveStepHook} hook hook
     * @param {ResolveRequest} request request
     * @returns {StackEntry} stack entry
     */
    value: function createStackEntry(hook, request) {
      return hook.name + ": (" + request.path + ") " + (request.request || "") + (request.query || "") + (request.fragment || "") + (request.directory ? " directory" : "") + (request.module ? " module" : "");
    }
    /**
     * @param {FileSystem} fileSystem a filesystem
     * @param {ResolveOptions} options options
     */

  }]);

  function Resolver(fileSystem, options) {
    _classCallCheck(this, Resolver);

    this.fileSystem = fileSystem;
    this.options = options;
    /** @type {KnownHooks} */

    this.hooks = {
      resolveStep: new SyncHook(["hook", "request"], "resolveStep"),
      noResolve: new SyncHook(["request", "error"], "noResolve"),
      resolve: new AsyncSeriesBailHook(["request", "resolveContext"], "resolve"),
      result: new AsyncSeriesHook(["result", "resolveContext"], "result")
    };
  }
  /**
   * @param {string | ResolveStepHook} name hook name or hook itself
   * @returns {ResolveStepHook} the hook
   */


  _createClass(Resolver, [{
    key: "ensureHook",
    value: function ensureHook(name) {
      if (typeof name !== "string") {
        return name;
      }

      name = toCamelCase(name);

      if (/^before/.test(name)) {
        return (
          /** @type {ResolveStepHook} */
          this.ensureHook(name[6].toLowerCase() + name.slice(7)).withOptions({
            stage: -10
          })
        );
      }

      if (/^after/.test(name)) {
        return (
          /** @type {ResolveStepHook} */
          this.ensureHook(name[5].toLowerCase() + name.slice(6)).withOptions({
            stage: 10
          })
        );
      }
      /** @type {ResolveStepHook} */


      var hook =
      /** @type {KnownHooks & EnsuredHooks} */
      this.hooks[name];

      if (!hook) {
        /** @type {KnownHooks & EnsuredHooks} */
        this.hooks[name] = new AsyncSeriesBailHook(["request", "resolveContext"], name);
        return (
          /** @type {KnownHooks & EnsuredHooks} */
          this.hooks[name]
        );
      }

      return hook;
    }
    /**
     * @param {string | ResolveStepHook} name hook name or hook itself
     * @returns {ResolveStepHook} the hook
     */

  }, {
    key: "getHook",
    value: function getHook(name) {
      if (typeof name !== "string") {
        return name;
      }

      name = toCamelCase(name);

      if (/^before/.test(name)) {
        return (
          /** @type {ResolveStepHook} */
          this.getHook(name[6].toLowerCase() + name.slice(7)).withOptions({
            stage: -10
          })
        );
      }

      if (/^after/.test(name)) {
        return (
          /** @type {ResolveStepHook} */
          this.getHook(name[5].toLowerCase() + name.slice(6)).withOptions({
            stage: 10
          })
        );
      }
      /** @type {ResolveStepHook} */


      var hook =
      /** @type {KnownHooks & EnsuredHooks} */
      this.hooks[name];

      if (!hook) {
        throw new Error("Hook ".concat(name, " doesn't exist"));
      }

      return hook;
    }
    /**
     * @param {object} context context information object
     * @param {string} path context path
     * @param {string} request request string
     * @returns {string | false} result
     */

  }, {
    key: "resolveSync",
    value: function resolveSync(context, path, request) {
      /** @type {Error | null | undefined} */
      var err = undefined;
      /** @type {string | false | undefined} */

      var result = undefined;
      var sync = false;
      this.resolve(context, path, request, {}, function (e, r) {
        err = e;
        result = r;
        sync = true;
      });

      if (!sync) {
        throw new Error("Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!");
      }

      if (err) throw err;
      if (result === undefined) throw new Error("No result");
      return result;
    }
    /**
     * @param {object} context context information object
     * @param {string} path context path
     * @param {string} request request string
     * @param {ResolveContext} resolveContext resolve context
     * @param {ResolveCallback} callback callback function
     * @returns {void}
     */

  }, {
    key: "resolve",
    value: function resolve(context, path, request, resolveContext, callback) {
      var _this = this;

      if (!context || _typeof(context) !== "object") return callback(new Error("context argument is not an object"));
      if (typeof path !== "string") return callback(new Error("path argument is not a string"));
      if (typeof request !== "string") return callback(new Error("request argument is not a string"));
      if (!resolveContext) return callback(new Error("resolveContext argument is not set"));
      /** @type {ResolveRequest} */

      var obj = {
        context: context,
        path: path,
        request: request
      };
      /** @type {ResolveContextYield | undefined} */

      var yield_;
      var yieldCalled = false;
      /** @type {ResolveContextYield | undefined} */

      var finishYield;

      if (typeof resolveContext["yield"] === "function") {
        var old = resolveContext["yield"];
        /**
         * @param {ResolveRequest} obj object
         */

        yield_ = function yield_(obj) {
          old(obj);
          yieldCalled = true;
        };
        /**
         * @param {ResolveRequest} result result
         * @returns {void}
         */


        finishYield = function finishYield(result) {
          if (result) {
            /** @type {ResolveContextYield} */
            yield_(result);
          }

          callback(null);
        };
      }

      var message = "resolve '".concat(request, "' in '").concat(path, "'");
      /**
       * @param {ResolveRequest} result result
       * @returns {void}
       */

      var finishResolved = function finishResolved(result) {
        return callback(null, result.path === false ? false : "".concat(result.path.replace(/#/g, "\0#")).concat(result.query ? result.query.replace(/#/g, "\0#") : "").concat(result.fragment || ""), result);
      };
      /**
       * @param {string[]} log logs
       * @returns {void}
       */


      var finishWithoutResolve = function finishWithoutResolve(log) {
        /**
         * @type {ErrorWithDetail}
         */
        var error = new Error("Can't " + message);
        error.details = log.join("\n");

        _this.hooks.noResolve.call(obj, error);

        return callback(error);
      };

      if (resolveContext.log) {
        // We need log anyway to capture it in case of an error
        var parentLog = resolveContext.log;
        /** @type {string[]} */

        var _log = [];
        return this.doResolve(this.hooks.resolve, obj, message, {
          log: function log(msg) {
            parentLog(msg);

            _log.push(msg);
          },
          "yield": yield_,
          fileDependencies: resolveContext.fileDependencies,
          contextDependencies: resolveContext.contextDependencies,
          missingDependencies: resolveContext.missingDependencies,
          stack: resolveContext.stack
        }, function (err, result) {
          if (err) return callback(err);

          if (yieldCalled || result && yield_) {
            return (
              /** @type {ResolveContextYield} */
              finishYield(
              /** @type {ResolveRequest} */
              result)
            );
          }

          if (result) return finishResolved(result);
          return finishWithoutResolve(_log);
        });
      } else {
        // Try to resolve assuming there is no error
        // We don't log stuff in this case
        return this.doResolve(this.hooks.resolve, obj, message, {
          log: undefined,
          "yield": yield_,
          fileDependencies: resolveContext.fileDependencies,
          contextDependencies: resolveContext.contextDependencies,
          missingDependencies: resolveContext.missingDependencies,
          stack: resolveContext.stack
        }, function (err, result) {
          if (err) return callback(err);

          if (yieldCalled || result && yield_) {
            return (
              /** @type {ResolveContextYield} */
              finishYield(
              /** @type {ResolveRequest} */
              result)
            );
          }

          if (result) return finishResolved(result); // log is missing for the error details
          // so we redo the resolving for the log info
          // this is more expensive to the success case
          // is assumed by default

          /** @type {string[]} */

          var _log2 = [];
          return _this.doResolve(_this.hooks.resolve, obj, message, {
            log: function log(msg) {
              return _log2.push(msg);
            },
            "yield": yield_,
            stack: resolveContext.stack
          }, function (err, result) {
            if (err) return callback(err); // In a case that there is a race condition and yield will be called

            if (yieldCalled || result && yield_) {
              return (
                /** @type {ResolveContextYield} */
                finishYield(
                /** @type {ResolveRequest} */
                result)
              );
            }

            return finishWithoutResolve(_log2);
          });
        });
      }
    }
    /**
     * @param {ResolveStepHook} hook hook
     * @param {ResolveRequest} request request
     * @param {null|string} message string
     * @param {ResolveContext} resolveContext resolver context
     * @param {(err?: null|Error, result?: ResolveRequest) => void} callback callback
     * @returns {void}
     */

  }, {
    key: "doResolve",
    value: function doResolve(hook, request, message, resolveContext, callback) {
      var stackEntry = Resolver.createStackEntry(hook, request);
      /** @type {Set<string> | undefined} */

      var newStack;

      if (resolveContext.stack) {
        newStack = new Set(resolveContext.stack);

        if (resolveContext.stack.has(stackEntry)) {
          /**
           * Prevent recursion
           * @type {Error & {recursion?: boolean}}
           */
          var recursionError = new Error("Recursion in resolving\nStack:\n  " + Array.from(newStack).join("\n  "));
          recursionError.recursion = true;
          if (resolveContext.log) resolveContext.log("abort resolving because of recursion");
          return callback(recursionError);
        }

        newStack.add(stackEntry);
      } else {
        // creating a set with new Set([item])
        // allocates a new array that has to be garbage collected
        // this is an EXTREMELY hot path, so let's avoid it
        newStack = new Set();
        newStack.add(stackEntry);
      }

      this.hooks.resolveStep.call(hook, request);

      if (hook.isUsed()) {
        var innerContext = createInnerContext({
          log: resolveContext.log,
          "yield": resolveContext["yield"],
          fileDependencies: resolveContext.fileDependencies,
          contextDependencies: resolveContext.contextDependencies,
          missingDependencies: resolveContext.missingDependencies,
          stack: newStack
        }, message);
        return hook.callAsync(request, innerContext, function (err, result) {
          if (err) return callback(err);
          if (result) return callback(null, result);
          callback();
        });
      } else {
        callback();
      }
    }
    /**
     * @param {string} identifier identifier
     * @returns {ParsedIdentifier} parsed identifier
     */

  }, {
    key: "parse",
    value: function parse(identifier) {
      var part = {
        request: "",
        query: "",
        fragment: "",
        module: false,
        directory: false,
        file: false,
        internal: false
      };
      var parsedIdentifier = parseIdentifier(identifier);
      if (!parsedIdentifier) return part;

      var _parsedIdentifier = _slicedToArray(parsedIdentifier, 3);

      part.request = _parsedIdentifier[0];
      part.query = _parsedIdentifier[1];
      part.fragment = _parsedIdentifier[2];

      if (part.request.length > 0) {
        part.internal = this.isPrivate(identifier);
        part.module = this.isModule(part.request);
        part.directory = this.isDirectory(part.request);

        if (part.directory) {
          part.request = part.request.slice(0, -1);
        }
      }

      return part;
    }
    /**
     * @param {string} path path
     * @returns {boolean} true, if the path is a module
     */

  }, {
    key: "isModule",
    value: function isModule(path) {
      return getType(path) === PathType.Normal;
    }
    /**
     * @param {string} path path
     * @returns {boolean} true, if the path is private
     */

  }, {
    key: "isPrivate",
    value: function isPrivate(path) {
      return getType(path) === PathType.Internal;
    }
    /**
     * @param {string} path a path
     * @returns {boolean} true, if the path is a directory path
     */

  }, {
    key: "isDirectory",
    value: function isDirectory(path) {
      return path.endsWith("/");
    }
    /**
     * @param {string} path path
     * @param {string} request request
     * @returns {string} joined path
     */

  }, {
    key: "join",
    value: function join(path, request) {
      return _join(path, request);
    }
    /**
     * @param {string} path path
     * @returns {string} normalized path
     */

  }, {
    key: "normalize",
    value: function normalize(path) {
      return _normalize(path);
    }
  }]);

  return Resolver;
}();

module.exports = Resolver;