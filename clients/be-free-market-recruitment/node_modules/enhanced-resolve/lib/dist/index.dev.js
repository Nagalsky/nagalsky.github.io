/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var fs = require("graceful-fs");

var CachedInputFileSystem = require("./CachedInputFileSystem");

var ResolverFactory = require("./ResolverFactory");
/** @typedef {import("./PnpPlugin").PnpApiImpl} PnpApi */

/** @typedef {import("./Resolver")} Resolver */

/** @typedef {import("./Resolver").FileSystem} FileSystem */

/** @typedef {import("./Resolver").ResolveCallback} ResolveCallback */

/** @typedef {import("./Resolver").ResolveContext} ResolveContext */

/** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */

/** @typedef {import("./ResolverFactory").Plugin} Plugin */

/** @typedef {import("./ResolverFactory").UserResolveOptions} ResolveOptions */

/** @typedef {{
 * (context: object, path: string, request: string, resolveContext: ResolveContext, callback: ResolveCallback): void;
 * (context: object, path: string, request: string, callback: ResolveCallback): void;
 * (path: string, request: string, resolveContext: ResolveContext, callback: ResolveCallback): void;
 * (path: string, request: string, callback: ResolveCallback): void;
 * }} ResolveFunctionAsync
 */

/** @typedef {{
 * (context: object, path: string, request: string): string|false;
 * (path: string, request: string): string|false;
 * }} ResolveFunction
 */


var nodeFileSystem = new CachedInputFileSystem(fs, 4000);
var nodeContext = {
  environments: ["node+es3+es5+process+native"]
};
var asyncResolver = ResolverFactory.createResolver({
  conditionNames: ["node"],
  extensions: [".js", ".json", ".node"],
  fileSystem: nodeFileSystem
});
/**
 * @type {ResolveFunctionAsync}
 */

var resolve =
/**
 * @param {object|string} context
 * @param {string} path
 * @param {string|ResolveContext|ResolveCallback} request
 * @param {ResolveContext|ResolveCallback=} resolveContext
 * @param {ResolveCallback=} callback
 */
function resolve(context, path, request, resolveContext, callback) {
  if (typeof context === "string") {
    callback =
    /** @type {ResolveCallback} */
    resolveContext;
    resolveContext =
    /** @type {ResolveContext} */
    request;
    request = path;
    path = context;
    context = nodeContext;
  }

  if (typeof callback !== "function") {
    callback =
    /** @type {ResolveCallback} */
    resolveContext;
  }

  asyncResolver.resolve(context, path,
  /** @type {string} */
  request,
  /** @type {ResolveContext} */
  resolveContext,
  /** @type {ResolveCallback} */
  callback);
};

var syncResolver = ResolverFactory.createResolver({
  conditionNames: ["node"],
  extensions: [".js", ".json", ".node"],
  useSyncFileSystemCalls: true,
  fileSystem: nodeFileSystem
});
/**
 * @type {ResolveFunction}
 */

var resolveSync =
/**
 * @param {object|string} context
 * @param {string} path
 * @param {string=} request
 */
function resolveSync(context, path, request) {
  if (typeof context === "string") {
    request = path;
    path = context;
    context = nodeContext;
  }

  return syncResolver.resolveSync(context, path,
  /** @type {string} */
  request);
};
/** @typedef {Omit<ResolveOptions, "fileSystem"> & Partial<Pick<ResolveOptions, "fileSystem">>} ResolveOptionsOptionalFS */

/**
 * @param {ResolveOptionsOptionalFS} options Resolver options
 * @returns {ResolveFunctionAsync} Resolver function
 */


function create(options) {
  var resolver = ResolverFactory.createResolver(_objectSpread({
    fileSystem: nodeFileSystem
  }, options));
  /**
   * @param {object|string} context Custom context
   * @param {string} path Base path
   * @param {string|ResolveContext|ResolveCallback} request String to resolve
   * @param {ResolveContext|ResolveCallback=} resolveContext Resolve context
   * @param {ResolveCallback=} callback Result callback
   */

  return function (context, path, request, resolveContext, callback) {
    if (typeof context === "string") {
      callback =
      /** @type {ResolveCallback} */
      resolveContext;
      resolveContext =
      /** @type {ResolveContext} */
      request;
      request = path;
      path = context;
      context = nodeContext;
    }

    if (typeof callback !== "function") {
      callback =
      /** @type {ResolveCallback} */
      resolveContext;
    }

    resolver.resolve(context, path,
    /** @type {string} */
    request,
    /** @type {ResolveContext} */
    resolveContext, callback);
  };
}
/**
 * @param {ResolveOptionsOptionalFS} options Resolver options
 * @returns {ResolveFunction} Resolver function
 */


function createSync(options) {
  var resolver = ResolverFactory.createResolver(_objectSpread({
    useSyncFileSystemCalls: true,
    fileSystem: nodeFileSystem
  }, options));
  /**
   * @param {object|string} context custom context
   * @param {string} path base path
   * @param {string=} request request to resolve
   * @returns {string|false} Resolved path or false
   */

  return function (context, path, request) {
    if (typeof context === "string") {
      request = path;
      path = context;
      context = nodeContext;
    }

    return resolver.resolveSync(context, path,
    /** @type {string} */
    request);
  };
}
/**
 * @template A
 * @template B
 * @param {A} obj input a
 * @param {B} exports input b
 * @returns {A & B} merged
 */


var mergeExports = function mergeExports(obj, exports) {
  var descriptors = Object.getOwnPropertyDescriptors(exports);
  Object.defineProperties(obj, descriptors);
  return (
    /** @type {A & B} */
    Object.freeze(obj)
  );
};

module.exports = mergeExports(resolve, {
  get sync() {
    return resolveSync;
  },

  create: mergeExports(create, {
    get sync() {
      return createSync;
    }

  }),
  ResolverFactory: ResolverFactory,
  CachedInputFileSystem: CachedInputFileSystem,

  get CloneBasenamePlugin() {
    return require("./CloneBasenamePlugin");
  },

  get LogInfoPlugin() {
    return require("./LogInfoPlugin");
  },

  get forEachBail() {
    return require("./forEachBail");
  }

});