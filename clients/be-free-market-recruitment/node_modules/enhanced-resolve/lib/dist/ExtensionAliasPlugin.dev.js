/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Ivan Kopeykin @vankop
*/
"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var forEachBail = require("./forEachBail");
/** @typedef {import("./Resolver")} Resolver */

/** @typedef {import("./Resolver").ResolveRequest} ResolveRequest */

/** @typedef {import("./Resolver").ResolveStepHook} ResolveStepHook */

/** @typedef {{ alias: string|string[], extension: string }} ExtensionAliasOption */


module.exports =
/*#__PURE__*/
function () {
  /**
   * @param {string | ResolveStepHook} source source
   * @param {ExtensionAliasOption} options options
   * @param {string | ResolveStepHook} target target
   */
  function ExtensionAliasPlugin(source, options, target) {
    _classCallCheck(this, ExtensionAliasPlugin);

    this.source = source;
    this.options = options;
    this.target = target;
  }
  /**
   * @param {Resolver} resolver the resolver
   * @returns {void}
   */


  _createClass(ExtensionAliasPlugin, [{
    key: "apply",
    value: function apply(resolver) {
      var _this = this;

      var target = resolver.ensureHook(this.target);
      var _this$options = this.options,
          extension = _this$options.extension,
          alias = _this$options.alias;
      resolver.getHook(this.source).tapAsync("ExtensionAliasPlugin", function (request, resolveContext, callback) {
        var requestPath = request.request;
        if (!requestPath || !requestPath.endsWith(extension)) return callback();
        var isAliasString = typeof alias === "string";
        /**
         * @param {string} alias extension alias
         * @param {(err?: null|Error, result?: null|ResolveRequest) => void} callback callback
         * @param {number} [index] index
         * @returns {void}
         */

        var resolve = function resolve(alias, callback, index) {
          var newRequest = "".concat(requestPath.slice(0, -extension.length)).concat(alias);
          return resolver.doResolve(target, _objectSpread({}, request, {
            request: newRequest,
            fullySpecified: true
          }), "aliased from extension alias with mapping '".concat(extension, "' to '").concat(alias, "'"), resolveContext, function (err, result) {
            // Throw error if we are on the last alias (for multiple aliases) and it failed, always throw if we are not an array or we have only one alias
            if (!isAliasString && index) {
              if (index !== _this.options.alias.length) {
                if (resolveContext.log) {
                  resolveContext.log("Failed to alias from extension alias with mapping '".concat(extension, "' to '").concat(alias, "' for '").concat(newRequest, "': ").concat(err));
                }

                return callback(null, result);
              }

              return callback(err, result);
            } else {
              callback(err, result);
            }
          });
        };
        /**
         * @param {null|Error} [err] error
         * @param {null|ResolveRequest} [result] result
         * @returns {void}
         */


        var stoppingCallback = function stoppingCallback(err, result) {
          if (err) return callback(err);
          if (result) return callback(null, result); // Don't allow other aliasing or raw request

          return callback(null, null);
        };

        if (isAliasString) {
          resolve(alias, stoppingCallback);
        } else if (alias.length > 1) {
          forEachBail(alias, resolve, stoppingCallback);
        } else {
          resolve(alias[0], stoppingCallback);
        }
      });
    }
  }]);

  return ExtensionAliasPlugin;
}();