/*
  @license
	Rollup.js v4.41.1
	Sat, 24 May 2025 06:13:57 GMT - commit 7c469dc4eb8e1cb6def9fdc04581fdfce9975da3

	https://github.com/rollup/rollup

	Released under the MIT License.
*/
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var rollup = require('./rollup.js');

var require$$0$1 = require('path');

var require$$2 = require('util');

var require$$0$2 = require('fs');

var require$$1 = require('stream');

var require$$2$1 = require('os');

var fseventsImporter = require('./fsevents-importer.js');

var require$$0$3 = require('events');

var chokidar$1 = {};
var utils$2 = {};
var constants$3;
var hasRequiredConstants$3;

function requireConstants$3() {
  if (hasRequiredConstants$3) return constants$3;
  hasRequiredConstants$3 = 1;
  var path = require$$0$1;
  var WIN_SLASH = '\\\\/';
  var WIN_NO_SLASH = "[^".concat(WIN_SLASH, "]");
  /**
   * Posix glob regex
   */

  var DOT_LITERAL = '\\.';
  var PLUS_LITERAL = '\\+';
  var QMARK_LITERAL = '\\?';
  var SLASH_LITERAL = '\\/';
  var ONE_CHAR = '(?=.)';
  var QMARK = '[^/]';
  var END_ANCHOR = "(?:".concat(SLASH_LITERAL, "|$)");
  var START_ANCHOR = "(?:^|".concat(SLASH_LITERAL, ")");
  var DOTS_SLASH = "".concat(DOT_LITERAL, "{1,2}").concat(END_ANCHOR);
  var NO_DOT = "(?!".concat(DOT_LITERAL, ")");
  var NO_DOTS = "(?!".concat(START_ANCHOR).concat(DOTS_SLASH, ")");
  var NO_DOT_SLASH = "(?!".concat(DOT_LITERAL, "{0,1}").concat(END_ANCHOR, ")");
  var NO_DOTS_SLASH = "(?!".concat(DOTS_SLASH, ")");
  var QMARK_NO_DOT = "[^.".concat(SLASH_LITERAL, "]");
  var STAR = "".concat(QMARK, "*?");
  var POSIX_CHARS = {
    DOT_LITERAL: DOT_LITERAL,
    PLUS_LITERAL: PLUS_LITERAL,
    QMARK_LITERAL: QMARK_LITERAL,
    SLASH_LITERAL: SLASH_LITERAL,
    ONE_CHAR: ONE_CHAR,
    QMARK: QMARK,
    END_ANCHOR: END_ANCHOR,
    DOTS_SLASH: DOTS_SLASH,
    NO_DOT: NO_DOT,
    NO_DOTS: NO_DOTS,
    NO_DOT_SLASH: NO_DOT_SLASH,
    NO_DOTS_SLASH: NO_DOTS_SLASH,
    QMARK_NO_DOT: QMARK_NO_DOT,
    STAR: STAR,
    START_ANCHOR: START_ANCHOR
  };
  /**
   * Windows glob regex
   */

  var WINDOWS_CHARS = _objectSpread({}, POSIX_CHARS, {
    SLASH_LITERAL: "[".concat(WIN_SLASH, "]"),
    QMARK: WIN_NO_SLASH,
    STAR: "".concat(WIN_NO_SLASH, "*?"),
    DOTS_SLASH: "".concat(DOT_LITERAL, "{1,2}(?:[").concat(WIN_SLASH, "]|$)"),
    NO_DOT: "(?!".concat(DOT_LITERAL, ")"),
    NO_DOTS: "(?!(?:^|[".concat(WIN_SLASH, "])").concat(DOT_LITERAL, "{1,2}(?:[").concat(WIN_SLASH, "]|$))"),
    NO_DOT_SLASH: "(?!".concat(DOT_LITERAL, "{0,1}(?:[").concat(WIN_SLASH, "]|$))"),
    NO_DOTS_SLASH: "(?!".concat(DOT_LITERAL, "{1,2}(?:[").concat(WIN_SLASH, "]|$))"),
    QMARK_NO_DOT: "[^.".concat(WIN_SLASH, "]"),
    START_ANCHOR: "(?:^|[".concat(WIN_SLASH, "])"),
    END_ANCHOR: "(?:[".concat(WIN_SLASH, "]|$)")
  });
  /**
   * POSIX Bracket Regex
   */


  var POSIX_REGEX_SOURCE = {
    alnum: 'a-zA-Z0-9',
    alpha: 'a-zA-Z',
    ascii: '\\x00-\\x7F',
    blank: ' \\t',
    cntrl: '\\x00-\\x1F\\x7F',
    digit: '0-9',
    graph: '\\x21-\\x7E',
    lower: 'a-z',
    print: '\\x20-\\x7E ',
    punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
    space: ' \\t\\r\\n\\v\\f',
    upper: 'A-Z',
    word: 'A-Za-z0-9_',
    xdigit: 'A-Fa-f0-9'
  };
  constants$3 = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      '***': '*',
      '**/**': '**',
      '**/**/**': '**'
    },
    // Digits
    CHAR_0: 48,

    /* 0 */
    CHAR_9: 57,

    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 65,

    /* A */
    CHAR_LOWERCASE_A: 97,

    /* a */
    CHAR_UPPERCASE_Z: 90,

    /* Z */
    CHAR_LOWERCASE_Z: 122,

    /* z */
    CHAR_LEFT_PARENTHESES: 40,

    /* ( */
    CHAR_RIGHT_PARENTHESES: 41,

    /* ) */
    CHAR_ASTERISK: 42,

    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,

    /* & */
    CHAR_AT: 64,

    /* @ */
    CHAR_BACKWARD_SLASH: 92,

    /* \ */
    CHAR_CARRIAGE_RETURN: 13,

    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94,

    /* ^ */
    CHAR_COLON: 58,

    /* : */
    CHAR_COMMA: 44,

    /* , */
    CHAR_DOT: 46,

    /* . */
    CHAR_DOUBLE_QUOTE: 34,

    /* " */
    CHAR_EQUAL: 61,

    /* = */
    CHAR_EXCLAMATION_MARK: 33,

    /* ! */
    CHAR_FORM_FEED: 12,

    /* \f */
    CHAR_FORWARD_SLASH: 47,

    /* / */
    CHAR_GRAVE_ACCENT: 96,

    /* ` */
    CHAR_HASH: 35,

    /* # */
    CHAR_HYPHEN_MINUS: 45,

    /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60,

    /* < */
    CHAR_LEFT_CURLY_BRACE: 123,

    /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91,

    /* [ */
    CHAR_LINE_FEED: 10,

    /* \n */
    CHAR_NO_BREAK_SPACE: 160,

    /* \u00A0 */
    CHAR_PERCENT: 37,

    /* % */
    CHAR_PLUS: 43,

    /* + */
    CHAR_QUESTION_MARK: 63,

    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62,

    /* > */
    CHAR_RIGHT_CURLY_BRACE: 125,

    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93,

    /* ] */
    CHAR_SEMICOLON: 59,

    /* ; */
    CHAR_SINGLE_QUOTE: 39,

    /* ' */
    CHAR_SPACE: 32,

    /*   */
    CHAR_TAB: 9,

    /* \t */
    CHAR_UNDERSCORE: 95,

    /* _ */
    CHAR_VERTICAL_LINE: 124,

    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,

    /* \uFEFF */
    SEP: path.sep,

    /**
     * Create EXTGLOB_CHARS
     */
    extglobChars: function extglobChars(chars) {
      return {
        '!': {
          type: 'negate',
          open: '(?:(?!(?:',
          close: "))".concat(chars.STAR, ")")
        },
        '?': {
          type: 'qmark',
          open: '(?:',
          close: ')?'
        },
        '+': {
          type: 'plus',
          open: '(?:',
          close: ')+'
        },
        '*': {
          type: 'star',
          open: '(?:',
          close: ')*'
        },
        '@': {
          type: 'at',
          open: '(?:',
          close: ')'
        }
      };
    },

    /**
     * Create GLOB_CHARS
     */
    globChars: function globChars(win32) {
      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
  };
  return constants$3;
}

var hasRequiredUtils$2;

function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;

  (function (exports) {
    var path = require$$0$1;
    var win32 = process.platform === 'win32';

    var _requireConstants$ =
    /*@__PURE__*/
    requireConstants$3(),
        REGEX_BACKSLASH = _requireConstants$.REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH = _requireConstants$.REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS = _requireConstants$.REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL = _requireConstants$.REGEX_SPECIAL_CHARS_GLOBAL;

    exports.isObject = function (val) {
      return val !== null && _typeof(val) === 'object' && !Array.isArray(val);
    };

    exports.hasRegexChars = function (str) {
      return REGEX_SPECIAL_CHARS.test(str);
    };

    exports.isRegexChar = function (str) {
      return str.length === 1 && exports.hasRegexChars(str);
    };

    exports.escapeRegex = function (str) {
      return str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
    };

    exports.toPosixSlashes = function (str) {
      return str.replace(REGEX_BACKSLASH, '/');
    };

    exports.removeBackslashes = function (str) {
      return str.replace(REGEX_REMOVE_BACKSLASH, function (match) {
        return match === '\\' ? '' : match;
      });
    };

    exports.supportsLookbehinds = function () {
      var segs = process.version.slice(1).split('.').map(Number);

      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }

      return false;
    };

    exports.isWindows = function (options) {
      if (options && typeof options.windows === 'boolean') {
        return options.windows;
      }

      return win32 === true || path.sep === '\\';
    };

    exports.escapeLast = function (input, _char, lastIdx) {
      var idx = input.lastIndexOf(_char, lastIdx);
      if (idx === -1) return input;
      if (input[idx - 1] === '\\') return exports.escapeLast(input, _char, idx - 1);
      return "".concat(input.slice(0, idx), "\\").concat(input.slice(idx));
    };

    exports.removePrefix = function (input) {
      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var output = input;

      if (output.startsWith('./')) {
        output = output.slice(2);
        state.prefix = './';
      }

      return output;
    };

    exports.wrapOutput = function (input) {
      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var prepend = options.contains ? '' : '^';
      var append = options.contains ? '' : '$';
      var output = "".concat(prepend, "(?:").concat(input, ")").concat(append);

      if (state.negated === true) {
        output = "(?:^(?!".concat(output, ").*$)");
      }

      return output;
    };
  })(utils$2);

  return utils$2;
}

var scan_1$1;
var hasRequiredScan$1;

function requireScan$1() {
  if (hasRequiredScan$1) return scan_1$1;
  hasRequiredScan$1 = 1;
  var utils =
  /*@__PURE__*/
  requireUtils$2();

  var _requireConstants$2 =
  /*@__PURE__*/
  requireConstants$3(),
      CHAR_ASTERISK = _requireConstants$2.CHAR_ASTERISK,
      CHAR_AT = _requireConstants$2.CHAR_AT,
      CHAR_BACKWARD_SLASH = _requireConstants$2.CHAR_BACKWARD_SLASH,
      CHAR_COMMA = _requireConstants$2.CHAR_COMMA,
      CHAR_DOT = _requireConstants$2.CHAR_DOT,
      CHAR_EXCLAMATION_MARK = _requireConstants$2.CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH = _requireConstants$2.CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE = _requireConstants$2.CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES = _requireConstants$2.CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET = _requireConstants$2.CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS = _requireConstants$2.CHAR_PLUS,
      CHAR_QUESTION_MARK = _requireConstants$2.CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE = _requireConstants$2.CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES = _requireConstants$2.CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET = _requireConstants$2.CHAR_RIGHT_SQUARE_BRACKET;

  var isPathSeparator = function isPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  };

  var depth = function depth(token) {
    if (token.isPrefix !== true) {
      token.depth = token.isGlobstar ? Infinity : 1;
    }
  };
  /**
   * Quickly scans a glob pattern and returns an object with a handful of
   * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
   * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
   * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
   *
   * ```js
   * const pm = require('picomatch');
   * console.log(pm.scan('foo/bar/*.js'));
   * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
   * ```
   * @param {String} `str`
   * @param {Object} `options`
   * @return {Object} Returns an object with tokens and regex source string.
   * @api public
   */


  var scan = function scan(input, options) {
    var opts = options || {};
    var length = input.length - 1;
    var scanToEnd = opts.parts === true || opts.scanToEnd === true;
    var slashes = [];
    var tokens = [];
    var parts = [];
    var str = input;
    var index = -1;
    var start = 0;
    var lastIndex = 0;
    var isBrace = false;
    var isBracket = false;
    var isGlob = false;
    var isExtglob = false;
    var isGlobstar = false;
    var braceEscaped = false;
    var backslashes = false;
    var negated = false;
    var negatedExtglob = false;
    var finished = false;
    var braces = 0;
    var prev;
    var code;
    var token = {
      value: '',
      depth: 0,
      isGlob: false
    };

    var eos = function eos() {
      return index >= length;
    };

    var peek = function peek() {
      return str.charCodeAt(index + 1);
    };

    var advance = function advance() {
      prev = code;
      return str.charCodeAt(++index);
    };

    while (index < length) {
      code = advance();
      var next = void 0;

      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token.backslashes = true;
        code = advance();

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braceEscaped = true;
        }

        continue;
      }

      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
        braces++;

        while (eos() !== true && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }

          if (code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }

          if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;

            if (scanToEnd === true) {
              continue;
            }

            break;
          }

          if (braceEscaped !== true && code === CHAR_COMMA) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;

            if (scanToEnd === true) {
              continue;
            }

            break;
          }

          if (code === CHAR_RIGHT_CURLY_BRACE) {
            braces--;

            if (braces === 0) {
              braceEscaped = false;
              isBrace = token.isBrace = true;
              finished = true;
              break;
            }
          }
        }

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_FORWARD_SLASH) {
        slashes.push(index);
        tokens.push(token);
        token = {
          value: '',
          depth: 0,
          isGlob: false
        };
        if (finished === true) continue;

        if (prev === CHAR_DOT && index === start + 1) {
          start += 2;
          continue;
        }

        lastIndex = index + 1;
        continue;
      }

      if (opts.noext !== true) {
        var isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;

        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          isExtglob = token.isExtglob = true;
          finished = true;

          if (code === CHAR_EXCLAMATION_MARK && index === start) {
            negatedExtglob = true;
          }

          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }

              if (code === CHAR_RIGHT_PARENTHESES) {
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }

            continue;
          }

          break;
        }
      }

      if (code === CHAR_ASTERISK) {
        if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
        isGlob = token.isGlob = true;
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_QUESTION_MARK) {
        isGlob = token.isGlob = true;
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        while (eos() !== true && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }

          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isBracket = token.isBracket = true;
            isGlob = token.isGlob = true;
            finished = true;
            break;
          }
        }

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
        negated = token.negated = true;
        start++;
        continue;
      }

      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_LEFT_PARENTHESES) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              finished = true;
              break;
            }
          }

          continue;
        }

        break;
      }

      if (isGlob === true) {
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }
    }

    if (opts.noext === true) {
      isExtglob = false;
      isGlob = false;
    }

    var base = str;
    var prefix = '';
    var glob = '';

    if (start > 0) {
      prefix = str.slice(0, start);
      str = str.slice(start);
      lastIndex -= start;
    }

    if (base && isGlob === true && lastIndex > 0) {
      base = str.slice(0, lastIndex);
      glob = str.slice(lastIndex);
    } else if (isGlob === true) {
      base = '';
      glob = str;
    } else {
      base = str;
    }

    if (base && base !== '' && base !== '/' && base !== str) {
      if (isPathSeparator(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }

    if (opts.unescape === true) {
      if (glob) glob = utils.removeBackslashes(glob);

      if (base && backslashes === true) {
        base = utils.removeBackslashes(base);
      }
    }

    var state = {
      prefix: prefix,
      input: input,
      start: start,
      base: base,
      glob: glob,
      isBrace: isBrace,
      isBracket: isBracket,
      isGlob: isGlob,
      isExtglob: isExtglob,
      isGlobstar: isGlobstar,
      negated: negated,
      negatedExtglob: negatedExtglob
    };

    if (opts.tokens === true) {
      state.maxDepth = 0;

      if (!isPathSeparator(code)) {
        tokens.push(token);
      }

      state.tokens = tokens;
    }

    if (opts.parts === true || opts.tokens === true) {
      var prevIndex;

      for (var idx = 0; idx < slashes.length; idx++) {
        var n = prevIndex ? prevIndex + 1 : start;
        var i = slashes[idx];
        var value = input.slice(n, i);

        if (opts.tokens) {
          if (idx === 0 && start !== 0) {
            tokens[idx].isPrefix = true;
            tokens[idx].value = prefix;
          } else {
            tokens[idx].value = value;
          }

          depth(tokens[idx]);
          state.maxDepth += tokens[idx].depth;
        }

        if (idx !== 0 || value !== '') {
          parts.push(value);
        }

        prevIndex = i;
      }

      if (prevIndex && prevIndex + 1 < input.length) {
        var _value = input.slice(prevIndex + 1);

        parts.push(_value);

        if (opts.tokens) {
          tokens[tokens.length - 1].value = _value;
          depth(tokens[tokens.length - 1]);
          state.maxDepth += tokens[tokens.length - 1].depth;
        }
      }

      state.slashes = slashes;
      state.parts = parts;
    }

    return state;
  };

  scan_1$1 = scan;
  return scan_1$1;
}

var parse_1$2;
var hasRequiredParse$2;

function requireParse$2() {
  if (hasRequiredParse$2) return parse_1$2;
  hasRequiredParse$2 = 1;
  var constants =
  /*@__PURE__*/
  requireConstants$3();
  var utils =
  /*@__PURE__*/
  requireUtils$2();
  /**
   * Constants
   */

  var MAX_LENGTH = constants.MAX_LENGTH,
      POSIX_REGEX_SOURCE = constants.POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS = constants.REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF = constants.REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS = constants.REPLACEMENTS;
  /**
   * Helpers
   */

  var expandRange = function expandRange(args, options) {
    if (typeof options.expandRange === 'function') {
      return options.expandRange.apply(options, _toConsumableArray(args).concat([options]));
    }

    args.sort();
    var value = "[".concat(args.join('-'), "]");
    return value;
  };
  /**
   * Create the message for a syntax error
   */


  var syntaxError = function syntaxError(type, _char2) {
    return "Missing ".concat(type, ": \"").concat(_char2, "\" - use \"\\\\").concat(_char2, "\" to match literal characters");
  };
  /**
   * Parse the given input string.
   * @param {String} input
   * @param {Object} options
   * @return {Object}
   */


  var parse = function parse(input, options) {
    if (typeof input !== 'string') {
      throw new TypeError('Expected a string');
    }

    input = REPLACEMENTS[input] || input;

    var opts = _objectSpread({}, options);

    var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    var len = input.length;

    if (len > max) {
      throw new SyntaxError("Input length: ".concat(len, ", exceeds maximum allowed length: ").concat(max));
    }

    var bos = {
      type: 'bos',
      value: '',
      output: opts.prepend || ''
    };
    var tokens = [bos];
    var capture = opts.capture ? '' : '?:';
    var win32 = utils.isWindows(options); // create constants based on platform, for windows or posix

    var PLATFORM_CHARS = constants.globChars(win32);
    var EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
    var DOT_LITERAL = PLATFORM_CHARS.DOT_LITERAL,
        PLUS_LITERAL = PLATFORM_CHARS.PLUS_LITERAL,
        SLASH_LITERAL = PLATFORM_CHARS.SLASH_LITERAL,
        ONE_CHAR = PLATFORM_CHARS.ONE_CHAR,
        DOTS_SLASH = PLATFORM_CHARS.DOTS_SLASH,
        NO_DOT = PLATFORM_CHARS.NO_DOT,
        NO_DOT_SLASH = PLATFORM_CHARS.NO_DOT_SLASH,
        NO_DOTS_SLASH = PLATFORM_CHARS.NO_DOTS_SLASH,
        QMARK = PLATFORM_CHARS.QMARK,
        QMARK_NO_DOT = PLATFORM_CHARS.QMARK_NO_DOT,
        STAR = PLATFORM_CHARS.STAR,
        START_ANCHOR = PLATFORM_CHARS.START_ANCHOR;

    var globstar = function globstar(opts) {
      return "(".concat(capture, "(?:(?!").concat(START_ANCHOR).concat(opts.dot ? DOTS_SLASH : DOT_LITERAL, ").)*?)");
    };

    var nodot = opts.dot ? '' : NO_DOT;
    var qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    var star = opts.bash === true ? globstar(opts) : STAR;

    if (opts.capture) {
      star = "(".concat(star, ")");
    } // minimatch options support


    if (typeof opts.noext === 'boolean') {
      opts.noextglob = opts.noext;
    }

    var state = {
      input: input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: '',
      output: '',
      prefix: '',
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: false,
      tokens: tokens
    };
    input = utils.removePrefix(input, state);
    len = input.length;
    var extglobs = [];
    var braces = [];
    var stack = [];
    var prev = bos;
    var value;
    /**
     * Tokenizing helpers
     */

    var eos = function eos() {
      return state.index === len - 1;
    };

    var peek = state.peek = function () {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return input[state.index + n];
    };

    var advance = state.advance = function () {
      return input[++state.index] || '';
    };

    var remaining = function remaining() {
      return input.slice(state.index + 1);
    };

    var consume = function consume() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var num = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      state.consumed += value;
      state.index += num;
    };

    var append = function append(token) {
      state.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };

    var negate = function negate() {
      var count = 1;

      while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
        advance();
        state.start++;
        count++;
      }

      if (count % 2 === 0) {
        return false;
      }

      state.negated = true;
      state.start++;
      return true;
    };

    var increment = function increment(type) {
      state[type]++;
      stack.push(type);
    };

    var decrement = function decrement(type) {
      state[type]--;
      stack.pop();
    };
    /**
     * Push tokens onto the tokens array. This helper speeds up
     * tokenizing by 1) helping us avoid backtracking as much as possible,
     * and 2) helping us avoid creating extra tokens when consecutive
     * characters are plain text. This improves performance and simplifies
     * lookbehinds.
     */


    var push = function push(tok) {
      if (prev.type === 'globstar') {
        var isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');

        var _isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');

        if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !_isExtglob) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = 'star';
          prev.value = '*';
          prev.output = star;
          state.output += prev.output;
        }
      }

      if (extglobs.length && tok.type !== 'paren') {
        extglobs[extglobs.length - 1].inner += tok.value;
      }

      if (tok.value || tok.output) append(tok);

      if (prev && prev.type === 'text' && tok.type === 'text') {
        prev.value += tok.value;
        prev.output = (prev.output || '') + tok.value;
        return;
      }

      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };

    var extglobOpen = function extglobOpen(type, value) {
      var token = _objectSpread({}, EXTGLOB_CHARS[value], {
        conditions: 1,
        inner: ''
      });

      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      var output = (opts.capture ? '(' : '') + token.open;
      increment('parens');
      push({
        type: type,
        value: value,
        output: state.output ? '' : ONE_CHAR
      });
      push({
        type: 'paren',
        extglob: true,
        value: advance(),
        output: output
      });
      extglobs.push(token);
    };

    var extglobClose = function extglobClose(token) {
      var output = token.close + (opts.capture ? ')' : '');
      var rest;

      if (token.type === 'negate') {
        var extglobStar = star;

        if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
          extglobStar = globstar(opts);
        }

        if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
          output = token.close = ")$))".concat(extglobStar);
        }

        if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
          // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
          // In this case, we need to parse the string and use it in the output of the original pattern.
          // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
          //
          // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
          var expression = parse(rest, _objectSpread({}, options, {
            fastpaths: false
          })).output;
          output = token.close = ")".concat(expression, ")").concat(extglobStar, ")");
        }

        if (token.prev.type === 'bos') {
          state.negatedExtglob = true;
        }
      }

      push({
        type: 'paren',
        extglob: true,
        value: value,
        output: output
      });
      decrement('parens');
    };
    /**
     * Fast paths
     */


    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      var backslashes = false;
      var output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, function (m, esc, chars, first, rest, index) {
        if (first === '\\') {
          backslashes = true;
          return m;
        }

        if (first === '?') {
          if (esc) {
            return esc + first + (rest ? QMARK.repeat(rest.length) : '');
          }

          if (index === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
          }

          return QMARK.repeat(chars.length);
        }

        if (first === '.') {
          return DOT_LITERAL.repeat(chars.length);
        }

        if (first === '*') {
          if (esc) {
            return esc + first + (rest ? star : '');
          }

          return star;
        }

        return esc ? m : "\\".concat(m);
      });

      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, '');
        } else {
          output = output.replace(/\\+/g, function (m) {
            return m.length % 2 === 0 ? '\\\\' : m ? '\\' : '';
          });
        }
      }

      if (output === input && opts.contains === true) {
        state.output = input;
        return state;
      }

      state.output = utils.wrapOutput(output, state, options);
      return state;
    }
    /**
     * Tokenize input until we reach end-of-string
     */


    while (!eos()) {
      value = advance();

      if (value === "\0") {
        continue;
      }
      /**
       * Escaped characters
       */


      if (value === '\\') {
        var next = peek();

        if (next === '/' && opts.bash !== true) {
          continue;
        }

        if (next === '.' || next === ';') {
          continue;
        }

        if (!next) {
          value += '\\';
          push({
            type: 'text',
            value: value
          });
          continue;
        } // collapse slashes to reduce potential for exploits


        var match = /^\\+/.exec(remaining());
        var slashes = 0;

        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;

          if (slashes % 2 !== 0) {
            value += '\\';
          }
        }

        if (opts.unescape === true) {
          value = advance();
        } else {
          value += advance();
        }

        if (state.brackets === 0) {
          push({
            type: 'text',
            value: value
          });
          continue;
        }
      }
      /**
       * If we're inside a regex character class, continue
       * until we reach the closing bracket.
       */


      if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
        if (opts.posix !== false && value === ':') {
          var inner = prev.value.slice(1);

          if (inner.includes('[')) {
            prev.posix = true;

            if (inner.includes(':')) {
              var idx = prev.value.lastIndexOf('[');
              var pre = prev.value.slice(0, idx);

              var _rest = prev.value.slice(idx + 2);

              var posix = POSIX_REGEX_SOURCE[_rest];

              if (posix) {
                prev.value = pre + posix;
                state.backtrack = true;
                advance();

                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }

                continue;
              }
            }
          }
        }

        if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {
          value = "\\".concat(value);
        }

        if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
          value = "\\".concat(value);
        }

        if (opts.posix === true && value === '!' && prev.value === '[') {
          value = '^';
        }

        prev.value += value;
        append({
          value: value
        });
        continue;
      }
      /**
       * If we're inside a quoted string, continue
       * until we reach the closing double quote.
       */


      if (state.quotes === 1 && value !== '"') {
        value = utils.escapeRegex(value);
        prev.value += value;
        append({
          value: value
        });
        continue;
      }
      /**
       * Double quotes
       */


      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;

        if (opts.keepQuotes === true) {
          push({
            type: 'text',
            value: value
          });
        }

        continue;
      }
      /**
       * Parentheses
       */


      if (value === '(') {
        increment('parens');
        push({
          type: 'paren',
          value: value
        });
        continue;
      }

      if (value === ')') {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '('));
        }

        var extglob = extglobs[extglobs.length - 1];

        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }

        push({
          type: 'paren',
          value: value,
          output: state.parens ? ')' : '\\)'
        });
        decrement('parens');
        continue;
      }
      /**
       * Square brackets
       */


      if (value === '[') {
        if (opts.nobracket === true || !remaining().includes(']')) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError('closing', ']'));
          }

          value = "\\".concat(value);
        } else {
          increment('brackets');
        }

        push({
          type: 'bracket',
          value: value
        });
        continue;
      }

      if (value === ']') {
        if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {
          push({
            type: 'text',
            value: value,
            output: "\\".concat(value)
          });
          continue;
        }

        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError('opening', '['));
          }

          push({
            type: 'text',
            value: value,
            output: "\\".concat(value)
          });
          continue;
        }

        decrement('brackets');
        var prevValue = prev.value.slice(1);

        if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
          value = "/".concat(value);
        }

        prev.value += value;
        append({
          value: value
        }); // when literal brackets are explicitly disabled
        // assume we should match with a regex character class

        if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
          continue;
        }

        var escaped = utils.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length); // when literal brackets are explicitly enabled
        // assume we should escape the brackets to match literal characters

        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        } // when the user specifies nothing, try to match both


        prev.value = "(".concat(capture).concat(escaped, "|").concat(prev.value, ")");
        state.output += prev.value;
        continue;
      }
      /**
       * Braces
       */


      if (value === '{' && opts.nobrace !== true) {
        increment('braces');
        var open = {
          type: 'brace',
          value: value,
          output: '(',
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open);
        push(open);
        continue;
      }

      if (value === '}') {
        var brace = braces[braces.length - 1];

        if (opts.nobrace === true || !brace) {
          push({
            type: 'text',
            value: value,
            output: value
          });
          continue;
        }

        var _output = ')';

        if (brace.dots === true) {
          var arr = tokens.slice();
          var range = [];

          for (var i = arr.length - 1; i >= 0; i--) {
            tokens.pop();

            if (arr[i].type === 'brace') {
              break;
            }

            if (arr[i].type !== 'dots') {
              range.unshift(arr[i].value);
            }
          }

          _output = expandRange(range, opts);
          state.backtrack = true;
        }

        if (brace.comma !== true && brace.dots !== true) {
          var out = state.output.slice(0, brace.outputIndex);
          var toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = '\\{';
          value = _output = '\\}';
          state.output = out;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = toks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var t = _step.value;
              state.output += t.output || t.value;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }

        push({
          type: 'brace',
          value: value,
          output: _output
        });
        decrement('braces');
        braces.pop();
        continue;
      }
      /**
       * Pipes
       */


      if (value === '|') {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }

        push({
          type: 'text',
          value: value
        });
        continue;
      }
      /**
       * Commas
       */


      if (value === ',') {
        var _output2 = value;
        var _brace = braces[braces.length - 1];

        if (_brace && stack[stack.length - 1] === 'braces') {
          _brace.comma = true;
          _output2 = '|';
        }

        push({
          type: 'comma',
          value: value,
          output: _output2
        });
        continue;
      }
      /**
       * Slashes
       */


      if (value === '/') {
        // if the beginning of the glob is "./", advance the start
        // to the current index, and don't add the "./" characters
        // to the state. This greatly simplifies lookbehinds when
        // checking for BOS characters like "!" and "." (not "./")
        if (prev.type === 'dot' && state.index === state.start + 1) {
          state.start = state.index + 1;
          state.consumed = '';
          state.output = '';
          tokens.pop();
          prev = bos; // reset "prev" to the first token

          continue;
        }

        push({
          type: 'slash',
          value: value,
          output: SLASH_LITERAL
        });
        continue;
      }
      /**
       * Dots
       */


      if (value === '.') {
        if (state.braces > 0 && prev.type === 'dot') {
          if (prev.value === '.') prev.output = DOT_LITERAL;
          var _brace2 = braces[braces.length - 1];
          prev.type = 'dots';
          prev.output += value;
          prev.value += value;
          _brace2.dots = true;
          continue;
        }

        if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
          push({
            type: 'text',
            value: value,
            output: DOT_LITERAL
          });
          continue;
        }

        push({
          type: 'dot',
          value: value,
          output: DOT_LITERAL
        });
        continue;
      }
      /**
       * Question marks
       */


      if (value === '?') {
        var isGroup = prev && prev.value === '(';

        if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          extglobOpen('qmark', value);
          continue;
        }

        if (prev && prev.type === 'paren') {
          var _next = peek();

          var _output3 = value;

          if (_next === '<' && !utils.supportsLookbehinds()) {
            throw new Error('Node.js v10 or higher is required for regex lookbehinds');
          }

          if (prev.value === '(' && !/[!=<:]/.test(_next) || _next === '<' && !/<([!=]|\w+>)/.test(remaining())) {
            _output3 = "\\".concat(value);
          }

          push({
            type: 'text',
            value: value,
            output: _output3
          });
          continue;
        }

        if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
          push({
            type: 'qmark',
            value: value,
            output: QMARK_NO_DOT
          });
          continue;
        }

        push({
          type: 'qmark',
          value: value,
          output: QMARK
        });
        continue;
      }
      /**
       * Exclamation
       */


      if (value === '!') {
        if (opts.noextglob !== true && peek() === '(') {
          if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
            extglobOpen('negate', value);
            continue;
          }
        }

        if (opts.nonegate !== true && state.index === 0) {
          negate();
          continue;
        }
      }
      /**
       * Plus
       */


      if (value === '+') {
        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          extglobOpen('plus', value);
          continue;
        }

        if (prev && prev.value === '(' || opts.regex === false) {
          push({
            type: 'plus',
            value: value,
            output: PLUS_LITERAL
          });
          continue;
        }

        if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {
          push({
            type: 'plus',
            value: value
          });
          continue;
        }

        push({
          type: 'plus',
          value: PLUS_LITERAL
        });
        continue;
      }
      /**
       * Plain text
       */


      if (value === '@') {
        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          push({
            type: 'at',
            extglob: true,
            value: value,
            output: ''
          });
          continue;
        }

        push({
          type: 'text',
          value: value
        });
        continue;
      }
      /**
       * Plain text
       */


      if (value !== '*') {
        if (value === '$' || value === '^') {
          value = "\\".concat(value);
        }

        var _match = REGEX_NON_SPECIAL_CHARS.exec(remaining());

        if (_match) {
          value += _match[0];
          state.index += _match[0].length;
        }

        push({
          type: 'text',
          value: value
        });
        continue;
      }
      /**
       * Stars
       */


      if (prev && (prev.type === 'globstar' || prev.star === true)) {
        prev.type = 'star';
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state.backtrack = true;
        state.globstar = true;
        consume(value);
        continue;
      }

      var rest = remaining();

      if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
        extglobOpen('star', value);
        continue;
      }

      if (prev.type === 'star') {
        if (opts.noglobstar === true) {
          consume(value);
          continue;
        }

        var prior = prev.prev;
        var before = prior.prev;
        var isStart = prior.type === 'slash' || prior.type === 'bos';
        var afterStar = before && (before.type === 'star' || before.type === 'globstar');

        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {
          push({
            type: 'star',
            value: value,
            output: ''
          });
          continue;
        }

        var isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');

        var _isExtglob2 = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');

        if (!isStart && prior.type !== 'paren' && !isBrace && !_isExtglob2) {
          push({
            type: 'star',
            value: value,
            output: ''
          });
          continue;
        } // strip consecutive `/**/`


        while (rest.slice(0, 3) === '/**') {
          var after = input[state.index + 4];

          if (after && after !== '/') {
            break;
          }

          rest = rest.slice(3);
          consume('/**', 3);
        }

        if (prior.type === 'bos' && eos()) {
          prev.type = 'globstar';
          prev.value += value;
          prev.output = globstar(opts);
          state.output = prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }

        if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = "(?:".concat(prior.output);
          prev.type = 'globstar';
          prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
          prev.value += value;
          state.globstar = true;
          state.output += prior.output + prev.output;
          consume(value);
          continue;
        }

        if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
          var end = rest[1] !== void 0 ? '|$' : '';
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = "(?:".concat(prior.output);
          prev.type = 'globstar';
          prev.output = "".concat(globstar(opts)).concat(SLASH_LITERAL, "|").concat(SLASH_LITERAL).concat(end, ")");
          prev.value += value;
          state.output += prior.output + prev.output;
          state.globstar = true;
          consume(value + advance());
          push({
            type: 'slash',
            value: '/',
            output: ''
          });
          continue;
        }

        if (prior.type === 'bos' && rest[0] === '/') {
          prev.type = 'globstar';
          prev.value += value;
          prev.output = "(?:^|".concat(SLASH_LITERAL, "|").concat(globstar(opts)).concat(SLASH_LITERAL, ")");
          state.output = prev.output;
          state.globstar = true;
          consume(value + advance());
          push({
            type: 'slash',
            value: '/',
            output: ''
          });
          continue;
        } // remove single star from output


        state.output = state.output.slice(0, -prev.output.length); // reset previous token to globstar

        prev.type = 'globstar';
        prev.output = globstar(opts);
        prev.value += value; // reset output with globstar

        state.output += prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      var token = {
        type: 'star',
        value: value,
        output: star
      };

      if (opts.bash === true) {
        token.output = '.*?';

        if (prev.type === 'bos' || prev.type === 'slash') {
          token.output = nodot + token.output;
        }

        push(token);
        continue;
      }

      if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
        token.output = value;
        push(token);
        continue;
      }

      if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
        if (prev.type === 'dot') {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state.output += nodot;
          prev.output += nodot;
        }

        if (peek() !== '*') {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }

      push(token);
    }

    while (state.brackets > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
      state.output = utils.escapeLast(state.output, '[');
      decrement('brackets');
    }

    while (state.parens > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
      state.output = utils.escapeLast(state.output, '(');
      decrement('parens');
    }

    while (state.braces > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
      state.output = utils.escapeLast(state.output, '{');
      decrement('braces');
    }

    if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
      push({
        type: 'maybe_slash',
        value: '',
        output: "".concat(SLASH_LITERAL, "?")
      });
    } // rebuild the output if we had to backtrack at any point


    if (state.backtrack === true) {
      state.output = '';
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = state.tokens[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _token = _step2.value;
          state.output += _token.output != null ? _token.output : _token.value;

          if (_token.suffix) {
            state.output += _token.suffix;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }

    return state;
  };
  /**
   * Fast paths for creating regular expressions for common glob patterns.
   * This can significantly speed up processing and has very little downside
   * impact when none of the fast paths match.
   */


  parse.fastpaths = function (input, options) {
    var opts = _objectSpread({}, options);

    var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    var len = input.length;

    if (len > max) {
      throw new SyntaxError("Input length: ".concat(len, ", exceeds maximum allowed length: ").concat(max));
    }

    input = REPLACEMENTS[input] || input;
    var win32 = utils.isWindows(options); // create constants based on platform, for windows or posix

    var _constants$globChars = constants.globChars(win32),
        DOT_LITERAL = _constants$globChars.DOT_LITERAL,
        SLASH_LITERAL = _constants$globChars.SLASH_LITERAL,
        ONE_CHAR = _constants$globChars.ONE_CHAR,
        DOTS_SLASH = _constants$globChars.DOTS_SLASH,
        NO_DOT = _constants$globChars.NO_DOT,
        NO_DOTS = _constants$globChars.NO_DOTS,
        NO_DOTS_SLASH = _constants$globChars.NO_DOTS_SLASH,
        STAR = _constants$globChars.STAR,
        START_ANCHOR = _constants$globChars.START_ANCHOR;

    var nodot = opts.dot ? NO_DOTS : NO_DOT;
    var slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    var capture = opts.capture ? '' : '?:';
    var state = {
      negated: false,
      prefix: ''
    };
    var star = opts.bash === true ? '.*?' : STAR;

    if (opts.capture) {
      star = "(".concat(star, ")");
    }

    var globstar = function globstar(opts) {
      if (opts.noglobstar === true) return star;
      return "(".concat(capture, "(?:(?!").concat(START_ANCHOR).concat(opts.dot ? DOTS_SLASH : DOT_LITERAL, ").)*?)");
    };

    var create = function create(str) {
      switch (str) {
        case '*':
          return "".concat(nodot).concat(ONE_CHAR).concat(star);

        case '.*':
          return "".concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);

        case '*.*':
          return "".concat(nodot).concat(star).concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);

        case '*/*':
          return "".concat(nodot).concat(star).concat(SLASH_LITERAL).concat(ONE_CHAR).concat(slashDot).concat(star);

        case '**':
          return nodot + globstar(opts);

        case '**/*':
          return "(?:".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, ")?").concat(slashDot).concat(ONE_CHAR).concat(star);

        case '**/*.*':
          return "(?:".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, ")?").concat(slashDot).concat(star).concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);

        case '**/.*':
          return "(?:".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, ")?").concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);

        default:
          {
            var match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;

            var _source = create(match[1]);

            if (!_source) return;
            return _source + DOT_LITERAL + match[2];
          }
      }
    };

    var output = utils.removePrefix(input, state);
    var source = create(output);

    if (source && opts.strictSlashes !== true) {
      source += "".concat(SLASH_LITERAL, "?");
    }

    return source;
  };

  parse_1$2 = parse;
  return parse_1$2;
}

var picomatch_1$1;
var hasRequiredPicomatch$3;

function requirePicomatch$3() {
  if (hasRequiredPicomatch$3) return picomatch_1$1;
  hasRequiredPicomatch$3 = 1;
  var path = require$$0$1;
  var scan =
  /*@__PURE__*/
  requireScan$1();
  var parse =
  /*@__PURE__*/
  requireParse$2();
  var utils =
  /*@__PURE__*/
  requireUtils$2();
  var constants =
  /*@__PURE__*/
  requireConstants$3();

  var isObject = function isObject(val) {
    return val && _typeof(val) === 'object' && !Array.isArray(val);
  };
  /**
   * Creates a matcher function from one or more glob patterns. The
   * returned function takes a string to match as its first argument,
   * and returns true if the string is a match. The returned matcher
   * function also takes a boolean as the second argument that, when true,
   * returns an object with additional information.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch(glob[, options]);
   *
   * const isMatch = picomatch('*.!(*a)');
   * console.log(isMatch('a.a')); //=> false
   * console.log(isMatch('a.b')); //=> true
   * ```
   * @name picomatch
   * @param {String|Array} `globs` One or more glob patterns.
   * @param {Object=} `options`
   * @return {Function=} Returns a matcher function.
   * @api public
   */


  var picomatch = function picomatch(glob, options) {
    var returnState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (Array.isArray(glob)) {
      var fns = glob.map(function (input) {
        return picomatch(input, options, returnState);
      });

      var arrayMatcher = function arrayMatcher(str) {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = fns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var isMatch = _step3.value;

            var _state = isMatch(str);

            if (_state) return _state;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        return false;
      };

      return arrayMatcher;
    }

    var isState = isObject(glob) && glob.tokens && glob.input;

    if (glob === '' || typeof glob !== 'string' && !isState) {
      throw new TypeError('Expected pattern to be a non-empty string');
    }

    var opts = options || {};
    var posix = utils.isWindows(options);
    var regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
    var state = regex.state;
    delete regex.state;

    var isIgnored = function isIgnored() {
      return false;
    };

    if (opts.ignore) {
      var ignoreOpts = _objectSpread({}, options, {
        ignore: null,
        onMatch: null,
        onResult: null
      });

      isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
    }

    var matcher = function matcher(input) {
      var returnObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var _picomatch$test = picomatch.test(input, regex, options, {
        glob: glob,
        posix: posix
      }),
          isMatch = _picomatch$test.isMatch,
          match = _picomatch$test.match,
          output = _picomatch$test.output;

      var result = {
        glob: glob,
        state: state,
        regex: regex,
        posix: posix,
        input: input,
        output: output,
        match: match,
        isMatch: isMatch
      };

      if (typeof opts.onResult === 'function') {
        opts.onResult(result);
      }

      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }

      if (isIgnored(input)) {
        if (typeof opts.onIgnore === 'function') {
          opts.onIgnore(result);
        }

        result.isMatch = false;
        return returnObject ? result : false;
      }

      if (typeof opts.onMatch === 'function') {
        opts.onMatch(result);
      }

      return returnObject ? result : true;
    };

    if (returnState) {
      matcher.state = state;
    }

    return matcher;
  };
  /**
   * Test `input` with the given `regex`. This is used by the main
   * `picomatch()` function to test the input string.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.test(input, regex[, options]);
   *
   * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
   * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
   * ```
   * @param {String} `input` String to test.
   * @param {RegExp} `regex`
   * @return {Object} Returns an object with matching info.
   * @api public
   */


  picomatch.test = function (input, regex, options) {
    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        glob = _ref.glob,
        posix = _ref.posix;

    if (typeof input !== 'string') {
      throw new TypeError('Expected input to be a string');
    }

    if (input === '') {
      return {
        isMatch: false,
        output: ''
      };
    }

    var opts = options || {};
    var format = opts.format || (posix ? utils.toPosixSlashes : null);
    var match = input === glob;
    var output = match && format ? format(input) : input;

    if (match === false) {
      output = format ? format(input) : input;
      match = output === glob;
    }

    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch.matchBase(input, regex, options, posix);
      } else {
        match = regex.exec(output);
      }
    }

    return {
      isMatch: Boolean(match),
      match: match,
      output: output
    };
  };
  /**
   * Match the basename of a filepath.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.matchBase(input, glob[, options]);
   * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
   * ```
   * @param {String} `input` String to test.
   * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
   * @return {Boolean}
   * @api public
   */


  picomatch.matchBase = function (input, glob, options) {
    var posix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : utils.isWindows(options);
    var regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
    return regex.test(path.basename(input));
  };
  /**
   * Returns true if **any** of the given glob `patterns` match the specified `string`.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.isMatch(string, patterns[, options]);
   *
   * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
   * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
   * ```
   * @param {String|Array} str The string to test.
   * @param {String|Array} patterns One or more glob patterns to use for matching.
   * @param {Object} [options] See available [options](#options).
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */


  picomatch.isMatch = function (str, patterns, options) {
    return picomatch(patterns, options)(str);
  };
  /**
   * Parse a glob pattern to create the source string for a regular
   * expression.
   *
   * ```js
   * const picomatch = require('picomatch');
   * const result = picomatch.parse(pattern[, options]);
   * ```
   * @param {String} `pattern`
   * @param {Object} `options`
   * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
   * @api public
   */


  picomatch.parse = function (pattern, options) {
    if (Array.isArray(pattern)) return pattern.map(function (p) {
      return picomatch.parse(p, options);
    });
    return parse(pattern, _objectSpread({}, options, {
      fastpaths: false
    }));
  };
  /**
   * Scan a glob pattern to separate the pattern into segments.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.scan(input[, options]);
   *
   * const result = picomatch.scan('!./foo/*.js');
   * console.log(result);
   * { prefix: '!./',
   *   input: '!./foo/*.js',
   *   start: 3,
   *   base: 'foo',
   *   glob: '*.js',
   *   isBrace: false,
   *   isBracket: false,
   *   isGlob: true,
   *   isExtglob: false,
   *   isGlobstar: false,
   *   negated: true }
   * ```
   * @param {String} `input` Glob pattern to scan.
   * @param {Object} `options`
   * @return {Object} Returns an object with
   * @api public
   */


  picomatch.scan = function (input, options) {
    return scan(input, options);
  };
  /**
   * Compile a regular expression from the `state` object returned by the
   * [parse()](#parse) method.
   *
   * @param {Object} `state`
   * @param {Object} `options`
   * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
   * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
   * @return {RegExp}
   * @api public
   */


  picomatch.compileRe = function (state, options) {
    var returnOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var returnState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (returnOutput === true) {
      return state.output;
    }

    var opts = options || {};
    var prepend = opts.contains ? '' : '^';
    var append = opts.contains ? '' : '$';
    var source = "".concat(prepend, "(?:").concat(state.output, ")").concat(append);

    if (state && state.negated === true) {
      source = "^(?!".concat(source, ").*$");
    }

    var regex = picomatch.toRegex(source, options);

    if (returnState === true) {
      regex.state = state;
    }

    return regex;
  };
  /**
   * Create a regular expression from a parsed glob pattern.
   *
   * ```js
   * const picomatch = require('picomatch');
   * const state = picomatch.parse('*.js');
   * // picomatch.compileRe(state[, options]);
   *
   * console.log(picomatch.compileRe(state));
   * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
   * ```
   * @param {String} `state` The object returned from the `.parse` method.
   * @param {Object} `options`
   * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
   * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
   * @return {RegExp} Returns a regex created from the given pattern.
   * @api public
   */


  picomatch.makeRe = function (input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var returnOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var returnState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (!input || typeof input !== 'string') {
      throw new TypeError('Expected a non-empty string');
    }

    var parsed = {
      negated: false,
      fastpaths: true
    };

    if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
      parsed.output = parse.fastpaths(input, options);
    }

    if (!parsed.output) {
      parsed = parse(input, options);
    }

    return picomatch.compileRe(parsed, options, returnOutput, returnState);
  };
  /**
   * Create a regular expression from the given regex source string.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.toRegex(source[, options]);
   *
   * const { output } = picomatch.parse('*.js');
   * console.log(picomatch.toRegex(output));
   * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
   * ```
   * @param {String} `source` Regular expression source string.
   * @param {Object} `options`
   * @return {RegExp}
   * @api public
   */


  picomatch.toRegex = function (source, options) {
    try {
      var opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
    } catch (err) {
      if (options && options.debug === true) throw err;
      return /$^/;
    }
  };
  /**
   * Picomatch constants.
   * @return {Object}
   */


  picomatch.constants = constants;
  /**
   * Expose "picomatch"
   */

  picomatch_1$1 = picomatch;
  return picomatch_1$1;
}

var picomatch$1;
var hasRequiredPicomatch$2;

function requirePicomatch$2() {
  if (hasRequiredPicomatch$2) return picomatch$1;
  hasRequiredPicomatch$2 = 1;
  picomatch$1 =
  /*@__PURE__*/
  requirePicomatch$3();
  return picomatch$1;
}

var readdirp_1;
var hasRequiredReaddirp;

function requireReaddirp() {
  if (hasRequiredReaddirp) return readdirp_1;
  hasRequiredReaddirp = 1;
  var fs = require$$0$2;
  var Readable = require$$1.Readable;
  var sysPath = require$$0$1;
  var promisify = require$$2.promisify;
  var picomatch =
  /*@__PURE__*/
  requirePicomatch$2();
  var readdir = promisify(fs.readdir);
  var stat = promisify(fs.stat);
  var lstat = promisify(fs.lstat);
  var realpath = promisify(fs.realpath);
  /**
   * @typedef {Object} EntryInfo
   * @property {String} path
   * @property {String} fullPath
   * @property {fs.Stats=} stats
   * @property {fs.Dirent=} dirent
   * @property {String} basename
   */

  var BANG = '!';
  var RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';
  var NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);
  var FILE_TYPE = 'files';
  var DIR_TYPE = 'directories';
  var FILE_DIR_TYPE = 'files_directories';
  var EVERYTHING_TYPE = 'all';
  var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];

  var isNormalFlowError = function isNormalFlowError(error) {
    return NORMAL_FLOW_ERRORS.has(error.code);
  };

  var _process$versions$nod = process.versions.node.split('.').slice(0, 2).map(function (n) {
    return Number.parseInt(n, 10);
  }),
      _process$versions$nod2 = _slicedToArray(_process$versions$nod, 2),
      maj = _process$versions$nod2[0],
      min = _process$versions$nod2[1];

  var wantBigintFsStats = process.platform === 'win32' && (maj > 10 || maj === 10 && min >= 5);

  var normalizeFilter = function normalizeFilter(filter) {
    if (filter === undefined) return;
    if (typeof filter === 'function') return filter;

    if (typeof filter === 'string') {
      var glob = picomatch(filter.trim());
      return function (entry) {
        return glob(entry.basename);
      };
    }

    if (Array.isArray(filter)) {
      var positive = [];
      var negative = [];
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = filter[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var item = _step4.value;
          var trimmed = item.trim();

          if (trimmed.charAt(0) === BANG) {
            negative.push(picomatch(trimmed.slice(1)));
          } else {
            positive.push(picomatch(trimmed));
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      if (negative.length > 0) {
        if (positive.length > 0) {
          return function (entry) {
            return positive.some(function (f) {
              return f(entry.basename);
            }) && !negative.some(function (f) {
              return f(entry.basename);
            });
          };
        }

        return function (entry) {
          return !negative.some(function (f) {
            return f(entry.basename);
          });
        };
      }

      return function (entry) {
        return positive.some(function (f) {
          return f(entry.basename);
        });
      };
    }
  };

  var ReaddirpStream =
  /*#__PURE__*/
  function (_Readable) {
    _inherits(ReaddirpStream, _Readable);

    _createClass(ReaddirpStream, null, [{
      key: "defaultOptions",
      get: function get() {
        return {
          root: '.',

          /* eslint-disable no-unused-vars */
          fileFilter: function fileFilter(path) {
            return true;
          },
          directoryFilter: function directoryFilter(path) {
            return true;
          },

          /* eslint-enable no-unused-vars */
          type: FILE_TYPE,
          lstat: false,
          depth: 2147483648,
          alwaysStat: false
        };
      }
    }]);

    function ReaddirpStream() {
      var _this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, ReaddirpStream);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ReaddirpStream).call(this, {
        objectMode: true,
        autoDestroy: true,
        highWaterMark: options.highWaterMark || 4096
      }));

      var opts = _objectSpread({}, ReaddirpStream.defaultOptions, {}, options);

      var root = opts.root,
          type = opts.type;
      _this._fileFilter = normalizeFilter(opts.fileFilter);
      _this._directoryFilter = normalizeFilter(opts.directoryFilter);
      var statMethod = opts.lstat ? lstat : stat; // Use bigint stats if it's windows and stat() supports options (node 10+).

      if (wantBigintFsStats) {
        _this._stat = function (path) {
          return statMethod(path, {
            bigint: true
          });
        };
      } else {
        _this._stat = statMethod;
      }

      _this._maxDepth = opts.depth;
      _this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
      _this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
      _this._wantsEverything = type === EVERYTHING_TYPE;
      _this._root = sysPath.resolve(root);
      _this._isDirent = 'Dirent' in fs && !opts.alwaysStat;
      _this._statsProp = _this._isDirent ? 'dirent' : 'stats';
      _this._rdOptions = {
        encoding: 'utf8',
        withFileTypes: _this._isDirent
      }; // Launch stream with one parent, the root dir.

      _this.parents = [_this._exploreDir(root, 1)];
      _this.reading = false;
      _this.parent = undefined;
      return _this;
    }

    _createClass(ReaddirpStream, [{
      key: "_read",
      value: function _read(batch) {
        var _this2 = this;

        var _loop2, _ret;

        return regeneratorRuntime.async(function _read$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.reading) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return");

              case 2:
                this.reading = true;
                _context2.prev = 3;

                _loop2 = function _loop2() {
                  var _ref2, path, depth, _ref2$files, files, slice, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, entry, entryType, parent;

                  return regeneratorRuntime.async(function _loop2$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _ref2 = _this2.parent || {}, path = _ref2.path, depth = _ref2.depth, _ref2$files = _ref2.files, files = _ref2$files === void 0 ? [] : _ref2$files;

                          if (!(files.length > 0)) {
                            _context.next = 38;
                            break;
                          }

                          slice = files.splice(0, batch).map(function (dirent) {
                            return _this2._formatEntry(dirent, path);
                          });
                          _iteratorNormalCompletion5 = true;
                          _didIteratorError5 = false;
                          _iteratorError5 = undefined;
                          _context.prev = 6;
                          _context.next = 9;
                          return regeneratorRuntime.awrap(Promise.all(slice));

                        case 9:
                          _context.t0 = Symbol.iterator;
                          _iterator5 = _context.sent[_context.t0]();

                        case 11:
                          if (_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done) {
                            _context.next = 22;
                            break;
                          }

                          entry = _step5.value;

                          if (!_this2.destroyed) {
                            _context.next = 15;
                            break;
                          }

                          return _context.abrupt("return", {
                            v: void 0
                          });

                        case 15:
                          _context.next = 17;
                          return regeneratorRuntime.awrap(_this2._getEntryType(entry));

                        case 17:
                          entryType = _context.sent;

                          if (entryType === 'directory' && _this2._directoryFilter(entry)) {
                            if (depth <= _this2._maxDepth) {
                              _this2.parents.push(_this2._exploreDir(entry.fullPath, depth + 1));
                            }

                            if (_this2._wantsDir) {
                              _this2.push(entry);

                              batch--;
                            }
                          } else if ((entryType === 'file' || _this2._includeAsFile(entry)) && _this2._fileFilter(entry)) {
                            if (_this2._wantsFile) {
                              _this2.push(entry);

                              batch--;
                            }
                          }

                        case 19:
                          _iteratorNormalCompletion5 = true;
                          _context.next = 11;
                          break;

                        case 22:
                          _context.next = 28;
                          break;

                        case 24:
                          _context.prev = 24;
                          _context.t1 = _context["catch"](6);
                          _didIteratorError5 = true;
                          _iteratorError5 = _context.t1;

                        case 28:
                          _context.prev = 28;
                          _context.prev = 29;

                          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                            _iterator5["return"]();
                          }

                        case 31:
                          _context.prev = 31;

                          if (!_didIteratorError5) {
                            _context.next = 34;
                            break;
                          }

                          throw _iteratorError5;

                        case 34:
                          return _context.finish(31);

                        case 35:
                          return _context.finish(28);

                        case 36:
                          _context.next = 47;
                          break;

                        case 38:
                          parent = _this2.parents.pop();

                          if (parent) {
                            _context.next = 42;
                            break;
                          }

                          _this2.push(null);

                          return _context.abrupt("return", "break");

                        case 42:
                          _context.next = 44;
                          return regeneratorRuntime.awrap(parent);

                        case 44:
                          _this2.parent = _context.sent;

                          if (!_this2.destroyed) {
                            _context.next = 47;
                            break;
                          }

                          return _context.abrupt("return", {
                            v: void 0
                          });

                        case 47:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, null, null, [[6, 24, 28, 36], [29,, 31, 35]]);
                };

              case 5:
                if (!(!this.destroyed && batch > 0)) {
                  _context2.next = 17;
                  break;
                }

                _context2.next = 8;
                return regeneratorRuntime.awrap(_loop2());

              case 8:
                _ret = _context2.sent;
                _context2.t0 = _ret;
                _context2.next = _context2.t0 === "break" ? 12 : 13;
                break;

              case 12:
                return _context2.abrupt("break", 17);

              case 13:
                if (!(_typeof(_ret) === "object")) {
                  _context2.next = 15;
                  break;
                }

                return _context2.abrupt("return", _ret.v);

              case 15:
                _context2.next = 5;
                break;

              case 17:
                _context2.next = 22;
                break;

              case 19:
                _context2.prev = 19;
                _context2.t1 = _context2["catch"](3);
                this.destroy(_context2.t1);

              case 22:
                _context2.prev = 22;
                this.reading = false;
                return _context2.finish(22);

              case 25:
              case "end":
                return _context2.stop();
            }
          }
        }, null, this, [[3, 19, 22, 25]]);
      }
    }, {
      key: "_exploreDir",
      value: function _exploreDir(path, depth) {
        var files;
        return regeneratorRuntime.async(function _exploreDir$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                _context3.next = 3;
                return regeneratorRuntime.awrap(readdir(path, this._rdOptions));

              case 3:
                files = _context3.sent;
                _context3.next = 9;
                break;

              case 6:
                _context3.prev = 6;
                _context3.t0 = _context3["catch"](0);

                this._onError(_context3.t0);

              case 9:
                return _context3.abrupt("return", {
                  files: files,
                  depth: depth,
                  path: path
                });

              case 10:
              case "end":
                return _context3.stop();
            }
          }
        }, null, this, [[0, 6]]);
      }
    }, {
      key: "_formatEntry",
      value: function _formatEntry(dirent, path) {
        var entry, basename, fullPath;
        return regeneratorRuntime.async(function _formatEntry$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                basename = this._isDirent ? dirent.name : dirent;
                fullPath = sysPath.resolve(sysPath.join(path, basename));
                entry = {
                  path: sysPath.relative(this._root, fullPath),
                  fullPath: fullPath,
                  basename: basename
                };

                if (!this._isDirent) {
                  _context4.next = 8;
                  break;
                }

                _context4.t0 = dirent;
                _context4.next = 11;
                break;

              case 8:
                _context4.next = 10;
                return regeneratorRuntime.awrap(this._stat(fullPath));

              case 10:
                _context4.t0 = _context4.sent;

              case 11:
                entry[this._statsProp] = _context4.t0;
                _context4.next = 17;
                break;

              case 14:
                _context4.prev = 14;
                _context4.t1 = _context4["catch"](0);

                this._onError(_context4.t1);

              case 17:
                return _context4.abrupt("return", entry);

              case 18:
              case "end":
                return _context4.stop();
            }
          }
        }, null, this, [[0, 14]]);
      }
    }, {
      key: "_onError",
      value: function _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
          this.emit('warn', err);
        } else {
          this.destroy(err);
        }
      }
    }, {
      key: "_getEntryType",
      value: function _getEntryType(entry) {
        var stats, full, entryRealPath, entryRealPathStats, len, recursiveError;
        return regeneratorRuntime.async(function _getEntryType$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                // entry may be undefined, because a warning or an error were emitted
                // and the statsProp is undefined
                stats = entry && entry[this._statsProp];

                if (stats) {
                  _context5.next = 3;
                  break;
                }

                return _context5.abrupt("return");

              case 3:
                if (!stats.isFile()) {
                  _context5.next = 5;
                  break;
                }

                return _context5.abrupt("return", 'file');

              case 5:
                if (!stats.isDirectory()) {
                  _context5.next = 7;
                  break;
                }

                return _context5.abrupt("return", 'directory');

              case 7:
                if (!(stats && stats.isSymbolicLink())) {
                  _context5.next = 30;
                  break;
                }

                full = entry.fullPath;
                _context5.prev = 9;
                _context5.next = 12;
                return regeneratorRuntime.awrap(realpath(full));

              case 12:
                entryRealPath = _context5.sent;
                _context5.next = 15;
                return regeneratorRuntime.awrap(lstat(entryRealPath));

              case 15:
                entryRealPathStats = _context5.sent;

                if (!entryRealPathStats.isFile()) {
                  _context5.next = 18;
                  break;
                }

                return _context5.abrupt("return", 'file');

              case 18:
                if (!entryRealPathStats.isDirectory()) {
                  _context5.next = 25;
                  break;
                }

                len = entryRealPath.length;

                if (!(full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep)) {
                  _context5.next = 24;
                  break;
                }

                recursiveError = new Error("Circular symlink detected: \"".concat(full, "\" points to \"").concat(entryRealPath, "\""));
                recursiveError.code = RECURSIVE_ERROR_CODE;
                return _context5.abrupt("return", this._onError(recursiveError));

              case 24:
                return _context5.abrupt("return", 'directory');

              case 25:
                _context5.next = 30;
                break;

              case 27:
                _context5.prev = 27;
                _context5.t0 = _context5["catch"](9);

                this._onError(_context5.t0);

              case 30:
              case "end":
                return _context5.stop();
            }
          }
        }, null, this, [[9, 27]]);
      }
    }, {
      key: "_includeAsFile",
      value: function _includeAsFile(entry) {
        var stats = entry && entry[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    }]);

    return ReaddirpStream;
  }(Readable);
  /**
   * @typedef {Object} ReaddirpArguments
   * @property {Function=} fileFilter
   * @property {Function=} directoryFilter
   * @property {String=} type
   * @property {Number=} depth
   * @property {String=} root
   * @property {Boolean=} lstat
   * @property {Boolean=} bigint
   */

  /**
   * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
   * @param {String} root Root directory
   * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth
   */


  var readdirp = function readdirp(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var type = options.entryType || options.type;
    if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility

    if (type) options.type = type;

    if (!root) {
      throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');
    } else if (typeof root !== 'string') {
      throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');
    } else if (type && !ALL_TYPES.includes(type)) {
      throw new Error("readdirp: Invalid type passed. Use one of ".concat(ALL_TYPES.join(', ')));
    }

    options.root = root;
    return new ReaddirpStream(options);
  };

  var readdirpPromise = function readdirpPromise(root) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new Promise(function (resolve, reject) {
      var files = [];
      readdirp(root, options).on('data', function (entry) {
        return files.push(entry);
      }).on('end', function () {
        return resolve(files);
      }).on('error', function (error) {
        return reject(error);
      });
    });
  };

  readdirp.promise = readdirpPromise;
  readdirp.ReaddirpStream = ReaddirpStream;
  readdirp["default"] = readdirp;
  readdirp_1 = readdirp;
  return readdirp_1;
}

var anymatch = {
  exports: {}
};
var utils$1 = {};
var constants$2;
var hasRequiredConstants$2;

function requireConstants$2() {
  if (hasRequiredConstants$2) return constants$2;
  hasRequiredConstants$2 = 1;
  var path = require$$0$1;
  var WIN_SLASH = '\\\\/';
  var WIN_NO_SLASH = "[^".concat(WIN_SLASH, "]");
  /**
   * Posix glob regex
   */

  var DOT_LITERAL = '\\.';
  var PLUS_LITERAL = '\\+';
  var QMARK_LITERAL = '\\?';
  var SLASH_LITERAL = '\\/';
  var ONE_CHAR = '(?=.)';
  var QMARK = '[^/]';
  var END_ANCHOR = "(?:".concat(SLASH_LITERAL, "|$)");
  var START_ANCHOR = "(?:^|".concat(SLASH_LITERAL, ")");
  var DOTS_SLASH = "".concat(DOT_LITERAL, "{1,2}").concat(END_ANCHOR);
  var NO_DOT = "(?!".concat(DOT_LITERAL, ")");
  var NO_DOTS = "(?!".concat(START_ANCHOR).concat(DOTS_SLASH, ")");
  var NO_DOT_SLASH = "(?!".concat(DOT_LITERAL, "{0,1}").concat(END_ANCHOR, ")");
  var NO_DOTS_SLASH = "(?!".concat(DOTS_SLASH, ")");
  var QMARK_NO_DOT = "[^.".concat(SLASH_LITERAL, "]");
  var STAR = "".concat(QMARK, "*?");
  var POSIX_CHARS = {
    DOT_LITERAL: DOT_LITERAL,
    PLUS_LITERAL: PLUS_LITERAL,
    QMARK_LITERAL: QMARK_LITERAL,
    SLASH_LITERAL: SLASH_LITERAL,
    ONE_CHAR: ONE_CHAR,
    QMARK: QMARK,
    END_ANCHOR: END_ANCHOR,
    DOTS_SLASH: DOTS_SLASH,
    NO_DOT: NO_DOT,
    NO_DOTS: NO_DOTS,
    NO_DOT_SLASH: NO_DOT_SLASH,
    NO_DOTS_SLASH: NO_DOTS_SLASH,
    QMARK_NO_DOT: QMARK_NO_DOT,
    STAR: STAR,
    START_ANCHOR: START_ANCHOR
  };
  /**
   * Windows glob regex
   */

  var WINDOWS_CHARS = _objectSpread({}, POSIX_CHARS, {
    SLASH_LITERAL: "[".concat(WIN_SLASH, "]"),
    QMARK: WIN_NO_SLASH,
    STAR: "".concat(WIN_NO_SLASH, "*?"),
    DOTS_SLASH: "".concat(DOT_LITERAL, "{1,2}(?:[").concat(WIN_SLASH, "]|$)"),
    NO_DOT: "(?!".concat(DOT_LITERAL, ")"),
    NO_DOTS: "(?!(?:^|[".concat(WIN_SLASH, "])").concat(DOT_LITERAL, "{1,2}(?:[").concat(WIN_SLASH, "]|$))"),
    NO_DOT_SLASH: "(?!".concat(DOT_LITERAL, "{0,1}(?:[").concat(WIN_SLASH, "]|$))"),
    NO_DOTS_SLASH: "(?!".concat(DOT_LITERAL, "{1,2}(?:[").concat(WIN_SLASH, "]|$))"),
    QMARK_NO_DOT: "[^.".concat(WIN_SLASH, "]"),
    START_ANCHOR: "(?:^|[".concat(WIN_SLASH, "])"),
    END_ANCHOR: "(?:[".concat(WIN_SLASH, "]|$)")
  });
  /**
   * POSIX Bracket Regex
   */


  var POSIX_REGEX_SOURCE = {
    alnum: 'a-zA-Z0-9',
    alpha: 'a-zA-Z',
    ascii: '\\x00-\\x7F',
    blank: ' \\t',
    cntrl: '\\x00-\\x1F\\x7F',
    digit: '0-9',
    graph: '\\x21-\\x7E',
    lower: 'a-z',
    print: '\\x20-\\x7E ',
    punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
    space: ' \\t\\r\\n\\v\\f',
    upper: 'A-Z',
    word: 'A-Za-z0-9_',
    xdigit: 'A-Fa-f0-9'
  };
  constants$2 = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      '***': '*',
      '**/**': '**',
      '**/**/**': '**'
    },
    // Digits
    CHAR_0: 48,

    /* 0 */
    CHAR_9: 57,

    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 65,

    /* A */
    CHAR_LOWERCASE_A: 97,

    /* a */
    CHAR_UPPERCASE_Z: 90,

    /* Z */
    CHAR_LOWERCASE_Z: 122,

    /* z */
    CHAR_LEFT_PARENTHESES: 40,

    /* ( */
    CHAR_RIGHT_PARENTHESES: 41,

    /* ) */
    CHAR_ASTERISK: 42,

    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,

    /* & */
    CHAR_AT: 64,

    /* @ */
    CHAR_BACKWARD_SLASH: 92,

    /* \ */
    CHAR_CARRIAGE_RETURN: 13,

    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94,

    /* ^ */
    CHAR_COLON: 58,

    /* : */
    CHAR_COMMA: 44,

    /* , */
    CHAR_DOT: 46,

    /* . */
    CHAR_DOUBLE_QUOTE: 34,

    /* " */
    CHAR_EQUAL: 61,

    /* = */
    CHAR_EXCLAMATION_MARK: 33,

    /* ! */
    CHAR_FORM_FEED: 12,

    /* \f */
    CHAR_FORWARD_SLASH: 47,

    /* / */
    CHAR_GRAVE_ACCENT: 96,

    /* ` */
    CHAR_HASH: 35,

    /* # */
    CHAR_HYPHEN_MINUS: 45,

    /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60,

    /* < */
    CHAR_LEFT_CURLY_BRACE: 123,

    /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91,

    /* [ */
    CHAR_LINE_FEED: 10,

    /* \n */
    CHAR_NO_BREAK_SPACE: 160,

    /* \u00A0 */
    CHAR_PERCENT: 37,

    /* % */
    CHAR_PLUS: 43,

    /* + */
    CHAR_QUESTION_MARK: 63,

    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62,

    /* > */
    CHAR_RIGHT_CURLY_BRACE: 125,

    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93,

    /* ] */
    CHAR_SEMICOLON: 59,

    /* ; */
    CHAR_SINGLE_QUOTE: 39,

    /* ' */
    CHAR_SPACE: 32,

    /*   */
    CHAR_TAB: 9,

    /* \t */
    CHAR_UNDERSCORE: 95,

    /* _ */
    CHAR_VERTICAL_LINE: 124,

    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,

    /* \uFEFF */
    SEP: path.sep,

    /**
     * Create EXTGLOB_CHARS
     */
    extglobChars: function extglobChars(chars) {
      return {
        '!': {
          type: 'negate',
          open: '(?:(?!(?:',
          close: "))".concat(chars.STAR, ")")
        },
        '?': {
          type: 'qmark',
          open: '(?:',
          close: ')?'
        },
        '+': {
          type: 'plus',
          open: '(?:',
          close: ')+'
        },
        '*': {
          type: 'star',
          open: '(?:',
          close: ')*'
        },
        '@': {
          type: 'at',
          open: '(?:',
          close: ')'
        }
      };
    },

    /**
     * Create GLOB_CHARS
     */
    globChars: function globChars(win32) {
      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
  };
  return constants$2;
}

var hasRequiredUtils$1;

function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;

  (function (exports) {
    var path = require$$0$1;
    var win32 = process.platform === 'win32';

    var _requireConstants$3 =
    /*@__PURE__*/
    requireConstants$2(),
        REGEX_BACKSLASH = _requireConstants$3.REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH = _requireConstants$3.REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS = _requireConstants$3.REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL = _requireConstants$3.REGEX_SPECIAL_CHARS_GLOBAL;

    exports.isObject = function (val) {
      return val !== null && _typeof(val) === 'object' && !Array.isArray(val);
    };

    exports.hasRegexChars = function (str) {
      return REGEX_SPECIAL_CHARS.test(str);
    };

    exports.isRegexChar = function (str) {
      return str.length === 1 && exports.hasRegexChars(str);
    };

    exports.escapeRegex = function (str) {
      return str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
    };

    exports.toPosixSlashes = function (str) {
      return str.replace(REGEX_BACKSLASH, '/');
    };

    exports.removeBackslashes = function (str) {
      return str.replace(REGEX_REMOVE_BACKSLASH, function (match) {
        return match === '\\' ? '' : match;
      });
    };

    exports.supportsLookbehinds = function () {
      var segs = process.version.slice(1).split('.').map(Number);

      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }

      return false;
    };

    exports.isWindows = function (options) {
      if (options && typeof options.windows === 'boolean') {
        return options.windows;
      }

      return win32 === true || path.sep === '\\';
    };

    exports.escapeLast = function (input, _char3, lastIdx) {
      var idx = input.lastIndexOf(_char3, lastIdx);
      if (idx === -1) return input;
      if (input[idx - 1] === '\\') return exports.escapeLast(input, _char3, idx - 1);
      return "".concat(input.slice(0, idx), "\\").concat(input.slice(idx));
    };

    exports.removePrefix = function (input) {
      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var output = input;

      if (output.startsWith('./')) {
        output = output.slice(2);
        state.prefix = './';
      }

      return output;
    };

    exports.wrapOutput = function (input) {
      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var prepend = options.contains ? '' : '^';
      var append = options.contains ? '' : '$';
      var output = "".concat(prepend, "(?:").concat(input, ")").concat(append);

      if (state.negated === true) {
        output = "(?:^(?!".concat(output, ").*$)");
      }

      return output;
    };
  })(utils$1);

  return utils$1;
}

var scan_1;
var hasRequiredScan;

function requireScan() {
  if (hasRequiredScan) return scan_1;
  hasRequiredScan = 1;
  var utils =
  /*@__PURE__*/
  requireUtils$1();

  var _requireConstants$4 =
  /*@__PURE__*/
  requireConstants$2(),
      CHAR_ASTERISK = _requireConstants$4.CHAR_ASTERISK,
      CHAR_AT = _requireConstants$4.CHAR_AT,
      CHAR_BACKWARD_SLASH = _requireConstants$4.CHAR_BACKWARD_SLASH,
      CHAR_COMMA = _requireConstants$4.CHAR_COMMA,
      CHAR_DOT = _requireConstants$4.CHAR_DOT,
      CHAR_EXCLAMATION_MARK = _requireConstants$4.CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH = _requireConstants$4.CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE = _requireConstants$4.CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES = _requireConstants$4.CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET = _requireConstants$4.CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS = _requireConstants$4.CHAR_PLUS,
      CHAR_QUESTION_MARK = _requireConstants$4.CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE = _requireConstants$4.CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES = _requireConstants$4.CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET = _requireConstants$4.CHAR_RIGHT_SQUARE_BRACKET;

  var isPathSeparator = function isPathSeparator(code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  };

  var depth = function depth(token) {
    if (token.isPrefix !== true) {
      token.depth = token.isGlobstar ? Infinity : 1;
    }
  };
  /**
   * Quickly scans a glob pattern and returns an object with a handful of
   * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
   * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
   * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
   *
   * ```js
   * const pm = require('picomatch');
   * console.log(pm.scan('foo/bar/*.js'));
   * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
   * ```
   * @param {String} `str`
   * @param {Object} `options`
   * @return {Object} Returns an object with tokens and regex source string.
   * @api public
   */


  var scan = function scan(input, options) {
    var opts = options || {};
    var length = input.length - 1;
    var scanToEnd = opts.parts === true || opts.scanToEnd === true;
    var slashes = [];
    var tokens = [];
    var parts = [];
    var str = input;
    var index = -1;
    var start = 0;
    var lastIndex = 0;
    var isBrace = false;
    var isBracket = false;
    var isGlob = false;
    var isExtglob = false;
    var isGlobstar = false;
    var braceEscaped = false;
    var backslashes = false;
    var negated = false;
    var negatedExtglob = false;
    var finished = false;
    var braces = 0;
    var prev;
    var code;
    var token = {
      value: '',
      depth: 0,
      isGlob: false
    };

    var eos = function eos() {
      return index >= length;
    };

    var peek = function peek() {
      return str.charCodeAt(index + 1);
    };

    var advance = function advance() {
      prev = code;
      return str.charCodeAt(++index);
    };

    while (index < length) {
      code = advance();
      var next = void 0;

      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = token.backslashes = true;
        code = advance();

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braceEscaped = true;
        }

        continue;
      }

      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
        braces++;

        while (eos() !== true && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }

          if (code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }

          if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;

            if (scanToEnd === true) {
              continue;
            }

            break;
          }

          if (braceEscaped !== true && code === CHAR_COMMA) {
            isBrace = token.isBrace = true;
            isGlob = token.isGlob = true;
            finished = true;

            if (scanToEnd === true) {
              continue;
            }

            break;
          }

          if (code === CHAR_RIGHT_CURLY_BRACE) {
            braces--;

            if (braces === 0) {
              braceEscaped = false;
              isBrace = token.isBrace = true;
              finished = true;
              break;
            }
          }
        }

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_FORWARD_SLASH) {
        slashes.push(index);
        tokens.push(token);
        token = {
          value: '',
          depth: 0,
          isGlob: false
        };
        if (finished === true) continue;

        if (prev === CHAR_DOT && index === start + 1) {
          start += 2;
          continue;
        }

        lastIndex = index + 1;
        continue;
      }

      if (opts.noext !== true) {
        var isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;

        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          isExtglob = token.isExtglob = true;
          finished = true;

          if (code === CHAR_EXCLAMATION_MARK && index === start) {
            negatedExtglob = true;
          }

          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }

              if (code === CHAR_RIGHT_PARENTHESES) {
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }

            continue;
          }

          break;
        }
      }

      if (code === CHAR_ASTERISK) {
        if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
        isGlob = token.isGlob = true;
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_QUESTION_MARK) {
        isGlob = token.isGlob = true;
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        while (eos() !== true && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            advance();
            continue;
          }

          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isBracket = token.isBracket = true;
            isGlob = token.isGlob = true;
            finished = true;
            break;
          }
        }

        if (scanToEnd === true) {
          continue;
        }

        break;
      }

      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
        negated = token.negated = true;
        start++;
        continue;
      }

      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_LEFT_PARENTHESES) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              finished = true;
              break;
            }
          }

          continue;
        }

        break;
      }

      if (isGlob === true) {
        finished = true;

        if (scanToEnd === true) {
          continue;
        }

        break;
      }
    }

    if (opts.noext === true) {
      isExtglob = false;
      isGlob = false;
    }

    var base = str;
    var prefix = '';
    var glob = '';

    if (start > 0) {
      prefix = str.slice(0, start);
      str = str.slice(start);
      lastIndex -= start;
    }

    if (base && isGlob === true && lastIndex > 0) {
      base = str.slice(0, lastIndex);
      glob = str.slice(lastIndex);
    } else if (isGlob === true) {
      base = '';
      glob = str;
    } else {
      base = str;
    }

    if (base && base !== '' && base !== '/' && base !== str) {
      if (isPathSeparator(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }

    if (opts.unescape === true) {
      if (glob) glob = utils.removeBackslashes(glob);

      if (base && backslashes === true) {
        base = utils.removeBackslashes(base);
      }
    }

    var state = {
      prefix: prefix,
      input: input,
      start: start,
      base: base,
      glob: glob,
      isBrace: isBrace,
      isBracket: isBracket,
      isGlob: isGlob,
      isExtglob: isExtglob,
      isGlobstar: isGlobstar,
      negated: negated,
      negatedExtglob: negatedExtglob
    };

    if (opts.tokens === true) {
      state.maxDepth = 0;

      if (!isPathSeparator(code)) {
        tokens.push(token);
      }

      state.tokens = tokens;
    }

    if (opts.parts === true || opts.tokens === true) {
      var prevIndex;

      for (var idx = 0; idx < slashes.length; idx++) {
        var n = prevIndex ? prevIndex + 1 : start;
        var i = slashes[idx];
        var value = input.slice(n, i);

        if (opts.tokens) {
          if (idx === 0 && start !== 0) {
            tokens[idx].isPrefix = true;
            tokens[idx].value = prefix;
          } else {
            tokens[idx].value = value;
          }

          depth(tokens[idx]);
          state.maxDepth += tokens[idx].depth;
        }

        if (idx !== 0 || value !== '') {
          parts.push(value);
        }

        prevIndex = i;
      }

      if (prevIndex && prevIndex + 1 < input.length) {
        var _value2 = input.slice(prevIndex + 1);

        parts.push(_value2);

        if (opts.tokens) {
          tokens[tokens.length - 1].value = _value2;
          depth(tokens[tokens.length - 1]);
          state.maxDepth += tokens[tokens.length - 1].depth;
        }
      }

      state.slashes = slashes;
      state.parts = parts;
    }

    return state;
  };

  scan_1 = scan;
  return scan_1;
}

var parse_1$1;
var hasRequiredParse$1;

function requireParse$1() {
  if (hasRequiredParse$1) return parse_1$1;
  hasRequiredParse$1 = 1;
  var constants =
  /*@__PURE__*/
  requireConstants$2();
  var utils =
  /*@__PURE__*/
  requireUtils$1();
  /**
   * Constants
   */

  var MAX_LENGTH = constants.MAX_LENGTH,
      POSIX_REGEX_SOURCE = constants.POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS = constants.REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF = constants.REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS = constants.REPLACEMENTS;
  /**
   * Helpers
   */

  var expandRange = function expandRange(args, options) {
    if (typeof options.expandRange === 'function') {
      return options.expandRange.apply(options, _toConsumableArray(args).concat([options]));
    }

    args.sort();
    var value = "[".concat(args.join('-'), "]");
    return value;
  };
  /**
   * Create the message for a syntax error
   */


  var syntaxError = function syntaxError(type, _char4) {
    return "Missing ".concat(type, ": \"").concat(_char4, "\" - use \"\\\\").concat(_char4, "\" to match literal characters");
  };
  /**
   * Parse the given input string.
   * @param {String} input
   * @param {Object} options
   * @return {Object}
   */


  var parse = function parse(input, options) {
    if (typeof input !== 'string') {
      throw new TypeError('Expected a string');
    }

    input = REPLACEMENTS[input] || input;

    var opts = _objectSpread({}, options);

    var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    var len = input.length;

    if (len > max) {
      throw new SyntaxError("Input length: ".concat(len, ", exceeds maximum allowed length: ").concat(max));
    }

    var bos = {
      type: 'bos',
      value: '',
      output: opts.prepend || ''
    };
    var tokens = [bos];
    var capture = opts.capture ? '' : '?:';
    var win32 = utils.isWindows(options); // create constants based on platform, for windows or posix

    var PLATFORM_CHARS = constants.globChars(win32);
    var EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
    var DOT_LITERAL = PLATFORM_CHARS.DOT_LITERAL,
        PLUS_LITERAL = PLATFORM_CHARS.PLUS_LITERAL,
        SLASH_LITERAL = PLATFORM_CHARS.SLASH_LITERAL,
        ONE_CHAR = PLATFORM_CHARS.ONE_CHAR,
        DOTS_SLASH = PLATFORM_CHARS.DOTS_SLASH,
        NO_DOT = PLATFORM_CHARS.NO_DOT,
        NO_DOT_SLASH = PLATFORM_CHARS.NO_DOT_SLASH,
        NO_DOTS_SLASH = PLATFORM_CHARS.NO_DOTS_SLASH,
        QMARK = PLATFORM_CHARS.QMARK,
        QMARK_NO_DOT = PLATFORM_CHARS.QMARK_NO_DOT,
        STAR = PLATFORM_CHARS.STAR,
        START_ANCHOR = PLATFORM_CHARS.START_ANCHOR;

    var globstar = function globstar(opts) {
      return "(".concat(capture, "(?:(?!").concat(START_ANCHOR).concat(opts.dot ? DOTS_SLASH : DOT_LITERAL, ").)*?)");
    };

    var nodot = opts.dot ? '' : NO_DOT;
    var qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    var star = opts.bash === true ? globstar(opts) : STAR;

    if (opts.capture) {
      star = "(".concat(star, ")");
    } // minimatch options support


    if (typeof opts.noext === 'boolean') {
      opts.noextglob = opts.noext;
    }

    var state = {
      input: input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: '',
      output: '',
      prefix: '',
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: false,
      tokens: tokens
    };
    input = utils.removePrefix(input, state);
    len = input.length;
    var extglobs = [];
    var braces = [];
    var stack = [];
    var prev = bos;
    var value;
    /**
     * Tokenizing helpers
     */

    var eos = function eos() {
      return state.index === len - 1;
    };

    var peek = state.peek = function () {
      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return input[state.index + n];
    };

    var advance = state.advance = function () {
      return input[++state.index] || '';
    };

    var remaining = function remaining() {
      return input.slice(state.index + 1);
    };

    var consume = function consume() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var num = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      state.consumed += value;
      state.index += num;
    };

    var append = function append(token) {
      state.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };

    var negate = function negate() {
      var count = 1;

      while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
        advance();
        state.start++;
        count++;
      }

      if (count % 2 === 0) {
        return false;
      }

      state.negated = true;
      state.start++;
      return true;
    };

    var increment = function increment(type) {
      state[type]++;
      stack.push(type);
    };

    var decrement = function decrement(type) {
      state[type]--;
      stack.pop();
    };
    /**
     * Push tokens onto the tokens array. This helper speeds up
     * tokenizing by 1) helping us avoid backtracking as much as possible,
     * and 2) helping us avoid creating extra tokens when consecutive
     * characters are plain text. This improves performance and simplifies
     * lookbehinds.
     */


    var push = function push(tok) {
      if (prev.type === 'globstar') {
        var isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');

        var _isExtglob3 = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');

        if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !_isExtglob3) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = 'star';
          prev.value = '*';
          prev.output = star;
          state.output += prev.output;
        }
      }

      if (extglobs.length && tok.type !== 'paren') {
        extglobs[extglobs.length - 1].inner += tok.value;
      }

      if (tok.value || tok.output) append(tok);

      if (prev && prev.type === 'text' && tok.type === 'text') {
        prev.value += tok.value;
        prev.output = (prev.output || '') + tok.value;
        return;
      }

      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };

    var extglobOpen = function extglobOpen(type, value) {
      var token = _objectSpread({}, EXTGLOB_CHARS[value], {
        conditions: 1,
        inner: ''
      });

      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      var output = (opts.capture ? '(' : '') + token.open;
      increment('parens');
      push({
        type: type,
        value: value,
        output: state.output ? '' : ONE_CHAR
      });
      push({
        type: 'paren',
        extglob: true,
        value: advance(),
        output: output
      });
      extglobs.push(token);
    };

    var extglobClose = function extglobClose(token) {
      var output = token.close + (opts.capture ? ')' : '');
      var rest;

      if (token.type === 'negate') {
        var extglobStar = star;

        if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
          extglobStar = globstar(opts);
        }

        if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
          output = token.close = ")$))".concat(extglobStar);
        }

        if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
          // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
          // In this case, we need to parse the string and use it in the output of the original pattern.
          // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
          //
          // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
          var expression = parse(rest, _objectSpread({}, options, {
            fastpaths: false
          })).output;
          output = token.close = ")".concat(expression, ")").concat(extglobStar, ")");
        }

        if (token.prev.type === 'bos') {
          state.negatedExtglob = true;
        }
      }

      push({
        type: 'paren',
        extglob: true,
        value: value,
        output: output
      });
      decrement('parens');
    };
    /**
     * Fast paths
     */


    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      var backslashes = false;
      var output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, function (m, esc, chars, first, rest, index) {
        if (first === '\\') {
          backslashes = true;
          return m;
        }

        if (first === '?') {
          if (esc) {
            return esc + first + (rest ? QMARK.repeat(rest.length) : '');
          }

          if (index === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
          }

          return QMARK.repeat(chars.length);
        }

        if (first === '.') {
          return DOT_LITERAL.repeat(chars.length);
        }

        if (first === '*') {
          if (esc) {
            return esc + first + (rest ? star : '');
          }

          return star;
        }

        return esc ? m : "\\".concat(m);
      });

      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, '');
        } else {
          output = output.replace(/\\+/g, function (m) {
            return m.length % 2 === 0 ? '\\\\' : m ? '\\' : '';
          });
        }
      }

      if (output === input && opts.contains === true) {
        state.output = input;
        return state;
      }

      state.output = utils.wrapOutput(output, state, options);
      return state;
    }
    /**
     * Tokenize input until we reach end-of-string
     */


    while (!eos()) {
      value = advance();

      if (value === "\0") {
        continue;
      }
      /**
       * Escaped characters
       */


      if (value === '\\') {
        var next = peek();

        if (next === '/' && opts.bash !== true) {
          continue;
        }

        if (next === '.' || next === ';') {
          continue;
        }

        if (!next) {
          value += '\\';
          push({
            type: 'text',
            value: value
          });
          continue;
        } // collapse slashes to reduce potential for exploits


        var match = /^\\+/.exec(remaining());
        var slashes = 0;

        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;

          if (slashes % 2 !== 0) {
            value += '\\';
          }
        }

        if (opts.unescape === true) {
          value = advance();
        } else {
          value += advance();
        }

        if (state.brackets === 0) {
          push({
            type: 'text',
            value: value
          });
          continue;
        }
      }
      /**
       * If we're inside a regex character class, continue
       * until we reach the closing bracket.
       */


      if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
        if (opts.posix !== false && value === ':') {
          var inner = prev.value.slice(1);

          if (inner.includes('[')) {
            prev.posix = true;

            if (inner.includes(':')) {
              var idx = prev.value.lastIndexOf('[');
              var pre = prev.value.slice(0, idx);

              var _rest2 = prev.value.slice(idx + 2);

              var posix = POSIX_REGEX_SOURCE[_rest2];

              if (posix) {
                prev.value = pre + posix;
                state.backtrack = true;
                advance();

                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }

                continue;
              }
            }
          }
        }

        if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {
          value = "\\".concat(value);
        }

        if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
          value = "\\".concat(value);
        }

        if (opts.posix === true && value === '!' && prev.value === '[') {
          value = '^';
        }

        prev.value += value;
        append({
          value: value
        });
        continue;
      }
      /**
       * If we're inside a quoted string, continue
       * until we reach the closing double quote.
       */


      if (state.quotes === 1 && value !== '"') {
        value = utils.escapeRegex(value);
        prev.value += value;
        append({
          value: value
        });
        continue;
      }
      /**
       * Double quotes
       */


      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;

        if (opts.keepQuotes === true) {
          push({
            type: 'text',
            value: value
          });
        }

        continue;
      }
      /**
       * Parentheses
       */


      if (value === '(') {
        increment('parens');
        push({
          type: 'paren',
          value: value
        });
        continue;
      }

      if (value === ')') {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '('));
        }

        var extglob = extglobs[extglobs.length - 1];

        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }

        push({
          type: 'paren',
          value: value,
          output: state.parens ? ')' : '\\)'
        });
        decrement('parens');
        continue;
      }
      /**
       * Square brackets
       */


      if (value === '[') {
        if (opts.nobracket === true || !remaining().includes(']')) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError('closing', ']'));
          }

          value = "\\".concat(value);
        } else {
          increment('brackets');
        }

        push({
          type: 'bracket',
          value: value
        });
        continue;
      }

      if (value === ']') {
        if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {
          push({
            type: 'text',
            value: value,
            output: "\\".concat(value)
          });
          continue;
        }

        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError('opening', '['));
          }

          push({
            type: 'text',
            value: value,
            output: "\\".concat(value)
          });
          continue;
        }

        decrement('brackets');
        var prevValue = prev.value.slice(1);

        if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
          value = "/".concat(value);
        }

        prev.value += value;
        append({
          value: value
        }); // when literal brackets are explicitly disabled
        // assume we should match with a regex character class

        if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
          continue;
        }

        var escaped = utils.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length); // when literal brackets are explicitly enabled
        // assume we should escape the brackets to match literal characters

        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        } // when the user specifies nothing, try to match both


        prev.value = "(".concat(capture).concat(escaped, "|").concat(prev.value, ")");
        state.output += prev.value;
        continue;
      }
      /**
       * Braces
       */


      if (value === '{' && opts.nobrace !== true) {
        increment('braces');
        var open = {
          type: 'brace',
          value: value,
          output: '(',
          outputIndex: state.output.length,
          tokensIndex: state.tokens.length
        };
        braces.push(open);
        push(open);
        continue;
      }

      if (value === '}') {
        var brace = braces[braces.length - 1];

        if (opts.nobrace === true || !brace) {
          push({
            type: 'text',
            value: value,
            output: value
          });
          continue;
        }

        var _output4 = ')';

        if (brace.dots === true) {
          var arr = tokens.slice();
          var range = [];

          for (var i = arr.length - 1; i >= 0; i--) {
            tokens.pop();

            if (arr[i].type === 'brace') {
              break;
            }

            if (arr[i].type !== 'dots') {
              range.unshift(arr[i].value);
            }
          }

          _output4 = expandRange(range, opts);
          state.backtrack = true;
        }

        if (brace.comma !== true && brace.dots !== true) {
          var out = state.output.slice(0, brace.outputIndex);
          var toks = state.tokens.slice(brace.tokensIndex);
          brace.value = brace.output = '\\{';
          value = _output4 = '\\}';
          state.output = out;
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = toks[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var t = _step6.value;
              state.output += t.output || t.value;
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                _iterator6["return"]();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        }

        push({
          type: 'brace',
          value: value,
          output: _output4
        });
        decrement('braces');
        braces.pop();
        continue;
      }
      /**
       * Pipes
       */


      if (value === '|') {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }

        push({
          type: 'text',
          value: value
        });
        continue;
      }
      /**
       * Commas
       */


      if (value === ',') {
        var _output5 = value;
        var _brace3 = braces[braces.length - 1];

        if (_brace3 && stack[stack.length - 1] === 'braces') {
          _brace3.comma = true;
          _output5 = '|';
        }

        push({
          type: 'comma',
          value: value,
          output: _output5
        });
        continue;
      }
      /**
       * Slashes
       */


      if (value === '/') {
        // if the beginning of the glob is "./", advance the start
        // to the current index, and don't add the "./" characters
        // to the state. This greatly simplifies lookbehinds when
        // checking for BOS characters like "!" and "." (not "./")
        if (prev.type === 'dot' && state.index === state.start + 1) {
          state.start = state.index + 1;
          state.consumed = '';
          state.output = '';
          tokens.pop();
          prev = bos; // reset "prev" to the first token

          continue;
        }

        push({
          type: 'slash',
          value: value,
          output: SLASH_LITERAL
        });
        continue;
      }
      /**
       * Dots
       */


      if (value === '.') {
        if (state.braces > 0 && prev.type === 'dot') {
          if (prev.value === '.') prev.output = DOT_LITERAL;
          var _brace4 = braces[braces.length - 1];
          prev.type = 'dots';
          prev.output += value;
          prev.value += value;
          _brace4.dots = true;
          continue;
        }

        if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
          push({
            type: 'text',
            value: value,
            output: DOT_LITERAL
          });
          continue;
        }

        push({
          type: 'dot',
          value: value,
          output: DOT_LITERAL
        });
        continue;
      }
      /**
       * Question marks
       */


      if (value === '?') {
        var isGroup = prev && prev.value === '(';

        if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          extglobOpen('qmark', value);
          continue;
        }

        if (prev && prev.type === 'paren') {
          var _next2 = peek();

          var _output6 = value;

          if (_next2 === '<' && !utils.supportsLookbehinds()) {
            throw new Error('Node.js v10 or higher is required for regex lookbehinds');
          }

          if (prev.value === '(' && !/[!=<:]/.test(_next2) || _next2 === '<' && !/<([!=]|\w+>)/.test(remaining())) {
            _output6 = "\\".concat(value);
          }

          push({
            type: 'text',
            value: value,
            output: _output6
          });
          continue;
        }

        if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
          push({
            type: 'qmark',
            value: value,
            output: QMARK_NO_DOT
          });
          continue;
        }

        push({
          type: 'qmark',
          value: value,
          output: QMARK
        });
        continue;
      }
      /**
       * Exclamation
       */


      if (value === '!') {
        if (opts.noextglob !== true && peek() === '(') {
          if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
            extglobOpen('negate', value);
            continue;
          }
        }

        if (opts.nonegate !== true && state.index === 0) {
          negate();
          continue;
        }
      }
      /**
       * Plus
       */


      if (value === '+') {
        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          extglobOpen('plus', value);
          continue;
        }

        if (prev && prev.value === '(' || opts.regex === false) {
          push({
            type: 'plus',
            value: value,
            output: PLUS_LITERAL
          });
          continue;
        }

        if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {
          push({
            type: 'plus',
            value: value
          });
          continue;
        }

        push({
          type: 'plus',
          value: PLUS_LITERAL
        });
        continue;
      }
      /**
       * Plain text
       */


      if (value === '@') {
        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
          push({
            type: 'at',
            extglob: true,
            value: value,
            output: ''
          });
          continue;
        }

        push({
          type: 'text',
          value: value
        });
        continue;
      }
      /**
       * Plain text
       */


      if (value !== '*') {
        if (value === '$' || value === '^') {
          value = "\\".concat(value);
        }

        var _match2 = REGEX_NON_SPECIAL_CHARS.exec(remaining());

        if (_match2) {
          value += _match2[0];
          state.index += _match2[0].length;
        }

        push({
          type: 'text',
          value: value
        });
        continue;
      }
      /**
       * Stars
       */


      if (prev && (prev.type === 'globstar' || prev.star === true)) {
        prev.type = 'star';
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state.backtrack = true;
        state.globstar = true;
        consume(value);
        continue;
      }

      var rest = remaining();

      if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
        extglobOpen('star', value);
        continue;
      }

      if (prev.type === 'star') {
        if (opts.noglobstar === true) {
          consume(value);
          continue;
        }

        var prior = prev.prev;
        var before = prior.prev;
        var isStart = prior.type === 'slash' || prior.type === 'bos';
        var afterStar = before && (before.type === 'star' || before.type === 'globstar');

        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {
          push({
            type: 'star',
            value: value,
            output: ''
          });
          continue;
        }

        var isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');

        var _isExtglob4 = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');

        if (!isStart && prior.type !== 'paren' && !isBrace && !_isExtglob4) {
          push({
            type: 'star',
            value: value,
            output: ''
          });
          continue;
        } // strip consecutive `/**/`


        while (rest.slice(0, 3) === '/**') {
          var after = input[state.index + 4];

          if (after && after !== '/') {
            break;
          }

          rest = rest.slice(3);
          consume('/**', 3);
        }

        if (prior.type === 'bos' && eos()) {
          prev.type = 'globstar';
          prev.value += value;
          prev.output = globstar(opts);
          state.output = prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }

        if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = "(?:".concat(prior.output);
          prev.type = 'globstar';
          prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
          prev.value += value;
          state.globstar = true;
          state.output += prior.output + prev.output;
          consume(value);
          continue;
        }

        if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
          var end = rest[1] !== void 0 ? '|$' : '';
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = "(?:".concat(prior.output);
          prev.type = 'globstar';
          prev.output = "".concat(globstar(opts)).concat(SLASH_LITERAL, "|").concat(SLASH_LITERAL).concat(end, ")");
          prev.value += value;
          state.output += prior.output + prev.output;
          state.globstar = true;
          consume(value + advance());
          push({
            type: 'slash',
            value: '/',
            output: ''
          });
          continue;
        }

        if (prior.type === 'bos' && rest[0] === '/') {
          prev.type = 'globstar';
          prev.value += value;
          prev.output = "(?:^|".concat(SLASH_LITERAL, "|").concat(globstar(opts)).concat(SLASH_LITERAL, ")");
          state.output = prev.output;
          state.globstar = true;
          consume(value + advance());
          push({
            type: 'slash',
            value: '/',
            output: ''
          });
          continue;
        } // remove single star from output


        state.output = state.output.slice(0, -prev.output.length); // reset previous token to globstar

        prev.type = 'globstar';
        prev.output = globstar(opts);
        prev.value += value; // reset output with globstar

        state.output += prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      var token = {
        type: 'star',
        value: value,
        output: star
      };

      if (opts.bash === true) {
        token.output = '.*?';

        if (prev.type === 'bos' || prev.type === 'slash') {
          token.output = nodot + token.output;
        }

        push(token);
        continue;
      }

      if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
        token.output = value;
        push(token);
        continue;
      }

      if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
        if (prev.type === 'dot') {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state.output += nodot;
          prev.output += nodot;
        }

        if (peek() !== '*') {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }

      push(token);
    }

    while (state.brackets > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
      state.output = utils.escapeLast(state.output, '[');
      decrement('brackets');
    }

    while (state.parens > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
      state.output = utils.escapeLast(state.output, '(');
      decrement('parens');
    }

    while (state.braces > 0) {
      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
      state.output = utils.escapeLast(state.output, '{');
      decrement('braces');
    }

    if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
      push({
        type: 'maybe_slash',
        value: '',
        output: "".concat(SLASH_LITERAL, "?")
      });
    } // rebuild the output if we had to backtrack at any point


    if (state.backtrack === true) {
      state.output = '';
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = state.tokens[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var _token2 = _step7.value;
          state.output += _token2.output != null ? _token2.output : _token2.value;

          if (_token2.suffix) {
            state.output += _token2.suffix;
          }
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }

    return state;
  };
  /**
   * Fast paths for creating regular expressions for common glob patterns.
   * This can significantly speed up processing and has very little downside
   * impact when none of the fast paths match.
   */


  parse.fastpaths = function (input, options) {
    var opts = _objectSpread({}, options);

    var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    var len = input.length;

    if (len > max) {
      throw new SyntaxError("Input length: ".concat(len, ", exceeds maximum allowed length: ").concat(max));
    }

    input = REPLACEMENTS[input] || input;
    var win32 = utils.isWindows(options); // create constants based on platform, for windows or posix

    var _constants$globChars2 = constants.globChars(win32),
        DOT_LITERAL = _constants$globChars2.DOT_LITERAL,
        SLASH_LITERAL = _constants$globChars2.SLASH_LITERAL,
        ONE_CHAR = _constants$globChars2.ONE_CHAR,
        DOTS_SLASH = _constants$globChars2.DOTS_SLASH,
        NO_DOT = _constants$globChars2.NO_DOT,
        NO_DOTS = _constants$globChars2.NO_DOTS,
        NO_DOTS_SLASH = _constants$globChars2.NO_DOTS_SLASH,
        STAR = _constants$globChars2.STAR,
        START_ANCHOR = _constants$globChars2.START_ANCHOR;

    var nodot = opts.dot ? NO_DOTS : NO_DOT;
    var slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    var capture = opts.capture ? '' : '?:';
    var state = {
      negated: false,
      prefix: ''
    };
    var star = opts.bash === true ? '.*?' : STAR;

    if (opts.capture) {
      star = "(".concat(star, ")");
    }

    var globstar = function globstar(opts) {
      if (opts.noglobstar === true) return star;
      return "(".concat(capture, "(?:(?!").concat(START_ANCHOR).concat(opts.dot ? DOTS_SLASH : DOT_LITERAL, ").)*?)");
    };

    var create = function create(str) {
      switch (str) {
        case '*':
          return "".concat(nodot).concat(ONE_CHAR).concat(star);

        case '.*':
          return "".concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);

        case '*.*':
          return "".concat(nodot).concat(star).concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);

        case '*/*':
          return "".concat(nodot).concat(star).concat(SLASH_LITERAL).concat(ONE_CHAR).concat(slashDot).concat(star);

        case '**':
          return nodot + globstar(opts);

        case '**/*':
          return "(?:".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, ")?").concat(slashDot).concat(ONE_CHAR).concat(star);

        case '**/*.*':
          return "(?:".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, ")?").concat(slashDot).concat(star).concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);

        case '**/.*':
          return "(?:".concat(nodot).concat(globstar(opts)).concat(SLASH_LITERAL, ")?").concat(DOT_LITERAL).concat(ONE_CHAR).concat(star);

        default:
          {
            var match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;

            var _source2 = create(match[1]);

            if (!_source2) return;
            return _source2 + DOT_LITERAL + match[2];
          }
      }
    };

    var output = utils.removePrefix(input, state);
    var source = create(output);

    if (source && opts.strictSlashes !== true) {
      source += "".concat(SLASH_LITERAL, "?");
    }

    return source;
  };

  parse_1$1 = parse;
  return parse_1$1;
}

var picomatch_1;
var hasRequiredPicomatch$1;

function requirePicomatch$1() {
  if (hasRequiredPicomatch$1) return picomatch_1;
  hasRequiredPicomatch$1 = 1;
  var path = require$$0$1;
  var scan =
  /*@__PURE__*/
  requireScan();
  var parse =
  /*@__PURE__*/
  requireParse$1();
  var utils =
  /*@__PURE__*/
  requireUtils$1();
  var constants =
  /*@__PURE__*/
  requireConstants$2();

  var isObject = function isObject(val) {
    return val && _typeof(val) === 'object' && !Array.isArray(val);
  };
  /**
   * Creates a matcher function from one or more glob patterns. The
   * returned function takes a string to match as its first argument,
   * and returns true if the string is a match. The returned matcher
   * function also takes a boolean as the second argument that, when true,
   * returns an object with additional information.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch(glob[, options]);
   *
   * const isMatch = picomatch('*.!(*a)');
   * console.log(isMatch('a.a')); //=> false
   * console.log(isMatch('a.b')); //=> true
   * ```
   * @name picomatch
   * @param {String|Array} `globs` One or more glob patterns.
   * @param {Object=} `options`
   * @return {Function=} Returns a matcher function.
   * @api public
   */


  var picomatch = function picomatch(glob, options) {
    var returnState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (Array.isArray(glob)) {
      var fns = glob.map(function (input) {
        return picomatch(input, options, returnState);
      });

      var arrayMatcher = function arrayMatcher(str) {
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = fns[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var isMatch = _step8.value;

            var _state2 = isMatch(str);

            if (_state2) return _state2;
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
              _iterator8["return"]();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }

        return false;
      };

      return arrayMatcher;
    }

    var isState = isObject(glob) && glob.tokens && glob.input;

    if (glob === '' || typeof glob !== 'string' && !isState) {
      throw new TypeError('Expected pattern to be a non-empty string');
    }

    var opts = options || {};
    var posix = utils.isWindows(options);
    var regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
    var state = regex.state;
    delete regex.state;

    var isIgnored = function isIgnored() {
      return false;
    };

    if (opts.ignore) {
      var ignoreOpts = _objectSpread({}, options, {
        ignore: null,
        onMatch: null,
        onResult: null
      });

      isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
    }

    var matcher = function matcher(input) {
      var returnObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var _picomatch$test2 = picomatch.test(input, regex, options, {
        glob: glob,
        posix: posix
      }),
          isMatch = _picomatch$test2.isMatch,
          match = _picomatch$test2.match,
          output = _picomatch$test2.output;

      var result = {
        glob: glob,
        state: state,
        regex: regex,
        posix: posix,
        input: input,
        output: output,
        match: match,
        isMatch: isMatch
      };

      if (typeof opts.onResult === 'function') {
        opts.onResult(result);
      }

      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }

      if (isIgnored(input)) {
        if (typeof opts.onIgnore === 'function') {
          opts.onIgnore(result);
        }

        result.isMatch = false;
        return returnObject ? result : false;
      }

      if (typeof opts.onMatch === 'function') {
        opts.onMatch(result);
      }

      return returnObject ? result : true;
    };

    if (returnState) {
      matcher.state = state;
    }

    return matcher;
  };
  /**
   * Test `input` with the given `regex`. This is used by the main
   * `picomatch()` function to test the input string.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.test(input, regex[, options]);
   *
   * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
   * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
   * ```
   * @param {String} `input` String to test.
   * @param {RegExp} `regex`
   * @return {Object} Returns an object with matching info.
   * @api public
   */


  picomatch.test = function (input, regex, options) {
    var _ref3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        glob = _ref3.glob,
        posix = _ref3.posix;

    if (typeof input !== 'string') {
      throw new TypeError('Expected input to be a string');
    }

    if (input === '') {
      return {
        isMatch: false,
        output: ''
      };
    }

    var opts = options || {};
    var format = opts.format || (posix ? utils.toPosixSlashes : null);
    var match = input === glob;
    var output = match && format ? format(input) : input;

    if (match === false) {
      output = format ? format(input) : input;
      match = output === glob;
    }

    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch.matchBase(input, regex, options, posix);
      } else {
        match = regex.exec(output);
      }
    }

    return {
      isMatch: Boolean(match),
      match: match,
      output: output
    };
  };
  /**
   * Match the basename of a filepath.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.matchBase(input, glob[, options]);
   * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
   * ```
   * @param {String} `input` String to test.
   * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
   * @return {Boolean}
   * @api public
   */


  picomatch.matchBase = function (input, glob, options) {
    var posix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : utils.isWindows(options);
    var regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
    return regex.test(path.basename(input));
  };
  /**
   * Returns true if **any** of the given glob `patterns` match the specified `string`.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.isMatch(string, patterns[, options]);
   *
   * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
   * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
   * ```
   * @param {String|Array} str The string to test.
   * @param {String|Array} patterns One or more glob patterns to use for matching.
   * @param {Object} [options] See available [options](#options).
   * @return {Boolean} Returns true if any patterns match `str`
   * @api public
   */


  picomatch.isMatch = function (str, patterns, options) {
    return picomatch(patterns, options)(str);
  };
  /**
   * Parse a glob pattern to create the source string for a regular
   * expression.
   *
   * ```js
   * const picomatch = require('picomatch');
   * const result = picomatch.parse(pattern[, options]);
   * ```
   * @param {String} `pattern`
   * @param {Object} `options`
   * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
   * @api public
   */


  picomatch.parse = function (pattern, options) {
    if (Array.isArray(pattern)) return pattern.map(function (p) {
      return picomatch.parse(p, options);
    });
    return parse(pattern, _objectSpread({}, options, {
      fastpaths: false
    }));
  };
  /**
   * Scan a glob pattern to separate the pattern into segments.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.scan(input[, options]);
   *
   * const result = picomatch.scan('!./foo/*.js');
   * console.log(result);
   * { prefix: '!./',
   *   input: '!./foo/*.js',
   *   start: 3,
   *   base: 'foo',
   *   glob: '*.js',
   *   isBrace: false,
   *   isBracket: false,
   *   isGlob: true,
   *   isExtglob: false,
   *   isGlobstar: false,
   *   negated: true }
   * ```
   * @param {String} `input` Glob pattern to scan.
   * @param {Object} `options`
   * @return {Object} Returns an object with
   * @api public
   */


  picomatch.scan = function (input, options) {
    return scan(input, options);
  };
  /**
   * Compile a regular expression from the `state` object returned by the
   * [parse()](#parse) method.
   *
   * @param {Object} `state`
   * @param {Object} `options`
   * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
   * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
   * @return {RegExp}
   * @api public
   */


  picomatch.compileRe = function (state, options) {
    var returnOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var returnState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (returnOutput === true) {
      return state.output;
    }

    var opts = options || {};
    var prepend = opts.contains ? '' : '^';
    var append = opts.contains ? '' : '$';
    var source = "".concat(prepend, "(?:").concat(state.output, ")").concat(append);

    if (state && state.negated === true) {
      source = "^(?!".concat(source, ").*$");
    }

    var regex = picomatch.toRegex(source, options);

    if (returnState === true) {
      regex.state = state;
    }

    return regex;
  };
  /**
   * Create a regular expression from a parsed glob pattern.
   *
   * ```js
   * const picomatch = require('picomatch');
   * const state = picomatch.parse('*.js');
   * // picomatch.compileRe(state[, options]);
   *
   * console.log(picomatch.compileRe(state));
   * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
   * ```
   * @param {String} `state` The object returned from the `.parse` method.
   * @param {Object} `options`
   * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
   * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
   * @return {RegExp} Returns a regex created from the given pattern.
   * @api public
   */


  picomatch.makeRe = function (input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var returnOutput = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var returnState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (!input || typeof input !== 'string') {
      throw new TypeError('Expected a non-empty string');
    }

    var parsed = {
      negated: false,
      fastpaths: true
    };

    if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
      parsed.output = parse.fastpaths(input, options);
    }

    if (!parsed.output) {
      parsed = parse(input, options);
    }

    return picomatch.compileRe(parsed, options, returnOutput, returnState);
  };
  /**
   * Create a regular expression from the given regex source string.
   *
   * ```js
   * const picomatch = require('picomatch');
   * // picomatch.toRegex(source[, options]);
   *
   * const { output } = picomatch.parse('*.js');
   * console.log(picomatch.toRegex(output));
   * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
   * ```
   * @param {String} `source` Regular expression source string.
   * @param {Object} `options`
   * @return {RegExp}
   * @api public
   */


  picomatch.toRegex = function (source, options) {
    try {
      var opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
    } catch (err) {
      if (options && options.debug === true) throw err;
      return /$^/;
    }
  };
  /**
   * Picomatch constants.
   * @return {Object}
   */


  picomatch.constants = constants;
  /**
   * Expose "picomatch"
   */

  picomatch_1 = picomatch;
  return picomatch_1;
}

var picomatch;
var hasRequiredPicomatch;

function requirePicomatch() {
  if (hasRequiredPicomatch) return picomatch;
  hasRequiredPicomatch = 1;
  picomatch =
  /*@__PURE__*/
  requirePicomatch$1();
  return picomatch;
}
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */


var normalizePath;
var hasRequiredNormalizePath;

function requireNormalizePath() {
  if (hasRequiredNormalizePath) return normalizePath;
  hasRequiredNormalizePath = 1;

  normalizePath = function normalizePath(path, stripTrailing) {
    if (typeof path !== 'string') {
      throw new TypeError('expected path to be a string');
    }

    if (path === '\\' || path === '/') return '/';
    var len = path.length;
    if (len <= 1) return path; // ensure that win32 namespaces has two leading slashes, so that the path is
    // handled properly by the win32 version of path.parse() after being normalized
    // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces

    var prefix = '';

    if (len > 4 && path[3] === '\\') {
      var ch = path[2];

      if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
        path = path.slice(2);
        prefix = '//';
      }
    }

    var segs = path.split(/[/\\]+/);

    if (stripTrailing !== false && segs[segs.length - 1] === '') {
      segs.pop();
    }

    return prefix + segs.join('/');
  };

  return normalizePath;
}

var anymatch_1 = anymatch.exports;
var hasRequiredAnymatch;

function requireAnymatch() {
  if (hasRequiredAnymatch) return anymatch.exports;
  hasRequiredAnymatch = 1;
  Object.defineProperty(anymatch_1, "__esModule", {
    value: true
  });
  var picomatch =
  /*@__PURE__*/
  requirePicomatch();
  var normalizePath =
  /*@__PURE__*/
  requireNormalizePath();
  /**
   * @typedef {(testString: string) => boolean} AnymatchFn
   * @typedef {string|RegExp|AnymatchFn} AnymatchPattern
   * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher
   */

  var BANG = '!';
  var DEFAULT_OPTIONS = {
    returnIndex: false
  };

  var arrify = function arrify(item) {
    return Array.isArray(item) ? item : [item];
  };
  /**
   * @param {AnymatchPattern} matcher
   * @param {object} options
   * @returns {AnymatchFn}
   */


  var createPattern = function createPattern(matcher, options) {
    if (typeof matcher === 'function') {
      return matcher;
    }

    if (typeof matcher === 'string') {
      var glob = picomatch(matcher, options);
      return function (string) {
        return matcher === string || glob(string);
      };
    }

    if (matcher instanceof RegExp) {
      return function (string) {
        return matcher.test(string);
      };
    }

    return function (string) {
      return false;
    };
  };
  /**
   * @param {Array<Function>} patterns
   * @param {Array<Function>} negPatterns
   * @param {String|Array} args
   * @param {Boolean} returnIndex
   * @returns {boolean|number}
   */


  var matchPatterns = function matchPatterns(patterns, negPatterns, args, returnIndex) {
    var isList = Array.isArray(args);

    var _path = isList ? args[0] : args;

    if (!isList && typeof _path !== 'string') {
      throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));
    }

    var path = normalizePath(_path, false);

    for (var index = 0; index < negPatterns.length; index++) {
      var nglob = negPatterns[index];

      if (nglob(path)) {
        return returnIndex ? -1 : false;
      }
    }

    var applied = isList && [path].concat(args.slice(1));

    for (var _index = 0; _index < patterns.length; _index++) {
      var pattern = patterns[_index];

      if (isList ? pattern.apply(void 0, _toConsumableArray(applied)) : pattern(path)) {
        return returnIndex ? _index : true;
      }
    }

    return returnIndex ? -1 : false;
  };
  /**
   * @param {AnymatchMatcher} matchers
   * @param {Array|string} testString
   * @param {object} options
   * @returns {boolean|number|Function}
   */


  var anymatch$1 = function anymatch$1(matchers, testString) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;

    if (matchers == null) {
      throw new TypeError('anymatch: specify first argument');
    }

    var opts = typeof options === 'boolean' ? {
      returnIndex: options
    } : options;
    var returnIndex = opts.returnIndex || false; // Early cache for matchers.

    var mtchers = arrify(matchers);
    var negatedGlobs = mtchers.filter(function (item) {
      return typeof item === 'string' && item.charAt(0) === BANG;
    }).map(function (item) {
      return item.slice(1);
    }).map(function (item) {
      return picomatch(item, opts);
    });
    var patterns = mtchers.filter(function (item) {
      return typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG;
    }).map(function (matcher) {
      return createPattern(matcher, opts);
    });

    if (testString == null) {
      return function (testString) {
        var ri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var returnIndex = typeof ri === 'boolean' ? ri : false;
        return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
      };
    }

    return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
  };

  anymatch$1["default"] = anymatch$1;
  anymatch.exports = anymatch$1;
  return anymatch.exports;
}
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */


var isExtglob;
var hasRequiredIsExtglob;

function requireIsExtglob() {
  if (hasRequiredIsExtglob) return isExtglob;
  hasRequiredIsExtglob = 1;

  isExtglob = function isExtglob(str) {
    if (typeof str !== 'string' || str === '') {
      return false;
    }

    var match;

    while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
      if (match[2]) return true;
      str = str.slice(match.index + match[0].length);
    }

    return false;
  };

  return isExtglob;
}
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */


var isGlob;
var hasRequiredIsGlob;

function requireIsGlob() {
  if (hasRequiredIsGlob) return isGlob;
  hasRequiredIsGlob = 1;
  var isExtglob =
  /*@__PURE__*/
  requireIsExtglob();
  var chars = {
    '{': '}',
    '(': ')',
    '[': ']'
  };

  var strictCheck = function strictCheck(str) {
    if (str[0] === '!') {
      return true;
    }

    var index = 0;
    var pipeIndex = -2;
    var closeSquareIndex = -2;
    var closeCurlyIndex = -2;
    var closeParenIndex = -2;
    var backSlashIndex = -2;

    while (index < str.length) {
      if (str[index] === '*') {
        return true;
      }

      if (str[index + 1] === '?' && /[\].+)]/.test(str[index])) {
        return true;
      }

      if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {
        if (closeSquareIndex < index) {
          closeSquareIndex = str.indexOf(']', index);
        }

        if (closeSquareIndex > index) {
          if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
            return true;
          }

          backSlashIndex = str.indexOf('\\', index);

          if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
            return true;
          }
        }
      }

      if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {
        closeCurlyIndex = str.indexOf('}', index);

        if (closeCurlyIndex > index) {
          backSlashIndex = str.indexOf('\\', index);

          if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
            return true;
          }
        }
      }

      if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {
        closeParenIndex = str.indexOf(')', index);

        if (closeParenIndex > index) {
          backSlashIndex = str.indexOf('\\', index);

          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }

      if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {
        if (pipeIndex < index) {
          pipeIndex = str.indexOf('|', index);
        }

        if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {
          closeParenIndex = str.indexOf(')', pipeIndex);

          if (closeParenIndex > pipeIndex) {
            backSlashIndex = str.indexOf('\\', pipeIndex);

            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
      }

      if (str[index] === '\\') {
        var open = str[index + 1];
        index += 2;
        var close = chars[open];

        if (close) {
          var n = str.indexOf(close, index);

          if (n !== -1) {
            index = n + 1;
          }
        }

        if (str[index] === '!') {
          return true;
        }
      } else {
        index++;
      }
    }

    return false;
  };

  var relaxedCheck = function relaxedCheck(str) {
    if (str[0] === '!') {
      return true;
    }

    var index = 0;

    while (index < str.length) {
      if (/[*?{}()[\]]/.test(str[index])) {
        return true;
      }

      if (str[index] === '\\') {
        var open = str[index + 1];
        index += 2;
        var close = chars[open];

        if (close) {
          var n = str.indexOf(close, index);

          if (n !== -1) {
            index = n + 1;
          }
        }

        if (str[index] === '!') {
          return true;
        }
      } else {
        index++;
      }
    }

    return false;
  };

  isGlob = function isGlob(str, options) {
    if (typeof str !== 'string' || str === '') {
      return false;
    }

    if (isExtglob(str)) {
      return true;
    }

    var check = strictCheck; // optionally relax check

    if (options && options.strict === false) {
      check = relaxedCheck;
    }

    return check(str);
  };

  return isGlob;
}

var globParent;
var hasRequiredGlobParent;

function requireGlobParent() {
  if (hasRequiredGlobParent) return globParent;
  hasRequiredGlobParent = 1;
  var isGlob =
  /*@__PURE__*/
  requireIsGlob();
  var pathPosixDirname = require$$0$1.posix.dirname;
  var isWin32 = require$$2$1.platform() === 'win32';
  var slash = '/';
  var backslash = /\\/g;
  var enclosure = /[\{\[].*[\}\]]$/;
  var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
  var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
  /**
   * @param {string} str
   * @param {Object} opts
   * @param {boolean} [opts.flipBackslashes=true]
   * @returns {string}
   */

  globParent = function globParent(str, opts) {
    var options = Object.assign({
      flipBackslashes: true
    }, opts); // flip windows path separators

    if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
      str = str.replace(backslash, slash);
    } // special case for strings ending in enclosure containing path separator


    if (enclosure.test(str)) {
      str += slash;
    } // preserves full path in case of trailing path separator


    str += 'a'; // remove path parts that are globby

    do {
      str = pathPosixDirname(str);
    } while (isGlob(str) || globby.test(str)); // remove escape chars and return result


    return str.replace(escaped, '$1');
  };

  return globParent;
}

var utils = {};
var hasRequiredUtils;

function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;

  (function (exports) {
    exports.isInteger = function (num) {
      if (typeof num === 'number') {
        return Number.isInteger(num);
      }

      if (typeof num === 'string' && num.trim() !== '') {
        return Number.isInteger(Number(num));
      }

      return false;
    };
    /**
     * Find a node of the given type
     */


    exports.find = function (node, type) {
      return node.nodes.find(function (node) {
        return node.type === type;
      });
    };
    /**
     * Find a node of the given type
     */


    exports.exceedsLimit = function (min, max) {
      var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var limit = arguments.length > 3 ? arguments[3] : undefined;
      if (limit === false) return false;
      if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    /**
     * Escape the given node with '\\' before node.value
     */


    exports.escapeNode = function (block) {
      var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var type = arguments.length > 2 ? arguments[2] : undefined;
      var node = block.nodes[n];
      if (!node) return;

      if (type && node.type === type || node.type === 'open' || node.type === 'close') {
        if (node.escaped !== true) {
          node.value = '\\' + node.value;
          node.escaped = true;
        }
      }
    };
    /**
     * Returns true if the given brace node should be enclosed in literal braces
     */


    exports.encloseBrace = function (node) {
      if (node.type !== 'brace') return false;

      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }

      return false;
    };
    /**
     * Returns true if a brace node is invalid.
     */


    exports.isInvalidBrace = function (block) {
      if (block.type !== 'brace') return false;
      if (block.invalid === true || block.dollar) return true;

      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }

      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }

      return false;
    };
    /**
     * Returns true if a node is an open or close node
     */


    exports.isOpenOrClose = function (node) {
      if (node.type === 'open' || node.type === 'close') {
        return true;
      }

      return node.open === true || node.close === true;
    };
    /**
     * Reduce an array of text nodes.
     */


    exports.reduce = function (nodes) {
      return nodes.reduce(function (acc, node) {
        if (node.type === 'text') acc.push(node.value);
        if (node.type === 'range') node.type = 'text';
        return acc;
      }, []);
    };
    /**
     * Flatten an array
     */


    exports.flatten = function () {
      var result = [];

      var flat = function flat(arr) {
        for (var i = 0; i < arr.length; i++) {
          var ele = arr[i];

          if (Array.isArray(ele)) {
            flat(ele);
            continue;
          }

          if (ele !== undefined) {
            result.push(ele);
          }
        }

        return result;
      };

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      flat(args);
      return result;
    };
  })(utils);

  return utils;
}

var stringify;
var hasRequiredStringify;

function requireStringify() {
  if (hasRequiredStringify) return stringify;
  hasRequiredStringify = 1;
  var utils =
  /*@__PURE__*/
  requireUtils();

  stringify = function stringify(ast) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var stringify = function stringify(node) {
      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
      var invalidNode = node.invalid === true && options.escapeInvalid === true;
      var output = '';

      if (node.value) {
        if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
          return '\\' + node.value;
        }

        return node.value;
      }

      if (node.value) {
        return node.value;
      }

      if (node.nodes) {
        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = node.nodes[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var child = _step9.value;
            output += stringify(child);
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
              _iterator9["return"]();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }
      }

      return output;
    };

    return stringify(ast);
  };

  return stringify;
}
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */


var isNumber;
var hasRequiredIsNumber;

function requireIsNumber() {
  if (hasRequiredIsNumber) return isNumber;
  hasRequiredIsNumber = 1;

  isNumber = function isNumber(num) {
    if (typeof num === 'number') {
      return num - num === 0;
    }

    if (typeof num === 'string' && num.trim() !== '') {
      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }

    return false;
  };

  return isNumber;
}
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */


var toRegexRange_1;
var hasRequiredToRegexRange;

function requireToRegexRange() {
  if (hasRequiredToRegexRange) return toRegexRange_1;
  hasRequiredToRegexRange = 1;
  var isNumber =
  /*@__PURE__*/
  requireIsNumber();

  var toRegexRange = function toRegexRange(min, max, options) {
    if (isNumber(min) === false) {
      throw new TypeError('toRegexRange: expected the first argument to be a number');
    }

    if (max === void 0 || min === max) {
      return String(min);
    }

    if (isNumber(max) === false) {
      throw new TypeError('toRegexRange: expected the second argument to be a number.');
    }

    var opts = _objectSpread({
      relaxZeros: true
    }, options);

    if (typeof opts.strictZeros === 'boolean') {
      opts.relaxZeros = opts.strictZeros === false;
    }

    var relax = String(opts.relaxZeros);
    var shorthand = String(opts.shorthand);
    var capture = String(opts.capture);
    var wrap = String(opts.wrap);
    var cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
      return toRegexRange.cache[cacheKey].result;
    }

    var a = Math.min(min, max);
    var b = Math.max(min, max);

    if (Math.abs(a - b) === 1) {
      var result = min + '|' + max;

      if (opts.capture) {
        return "(".concat(result, ")");
      }

      if (opts.wrap === false) {
        return result;
      }

      return "(?:".concat(result, ")");
    }

    var isPadded = hasPadding(min) || hasPadding(max);
    var state = {
      min: min,
      max: max,
      a: a,
      b: b
    };
    var positives = [];
    var negatives = [];

    if (isPadded) {
      state.isPadded = isPadded;
      state.maxLen = String(state.max).length;
    }

    if (a < 0) {
      var newMin = b < 0 ? Math.abs(b) : 1;
      negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
      a = state.a = 0;
    }

    if (b >= 0) {
      positives = splitToPatterns(a, b, state, opts);
    }

    state.negatives = negatives;
    state.positives = positives;
    state.result = collatePatterns(negatives, positives);

    if (opts.capture === true) {
      state.result = "(".concat(state.result, ")");
    } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
      state.result = "(?:".concat(state.result, ")");
    }

    toRegexRange.cache[cacheKey] = state;
    return state.result;
  };

  function collatePatterns(neg, pos, options) {
    var onlyNegative = filterPatterns(neg, pos, '-', false) || [];
    var onlyPositive = filterPatterns(pos, neg, '', false) || [];
    var intersected = filterPatterns(neg, pos, '-?', true) || [];
    var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join('|');
  }

  function splitToRanges(min, max) {
    var nines = 1;
    var zeros = 1;
    var stop = countNines(min, nines);
    var stops = new Set([max]);

    while (min <= stop && stop <= max) {
      stops.add(stop);
      nines += 1;
      stop = countNines(min, nines);
    }

    stop = countZeros(max + 1, zeros) - 1;

    while (min < stop && stop <= max) {
      stops.add(stop);
      zeros += 1;
      stop = countZeros(max + 1, zeros) - 1;
    }

    stops = _toConsumableArray(stops);
    stops.sort(compare);
    return stops;
  }
  /**
   * Convert a range to a regex pattern
   * @param {Number} `start`
   * @param {Number} `stop`
   * @return {String}
   */


  function rangeToPattern(start, stop, options) {
    if (start === stop) {
      return {
        pattern: start,
        count: [],
        digits: 0
      };
    }

    var zipped = zip(start, stop);
    var digits = zipped.length;
    var pattern = '';
    var count = 0;

    for (var i = 0; i < digits; i++) {
      var _zipped$i = _slicedToArray(zipped[i], 2),
          startDigit = _zipped$i[0],
          stopDigit = _zipped$i[1];

      if (startDigit === stopDigit) {
        pattern += startDigit;
      } else if (startDigit !== '0' || stopDigit !== '9') {
        pattern += toCharacterClass(startDigit, stopDigit);
      } else {
        count++;
      }
    }

    if (count) {
      pattern += options.shorthand === true ? '\\d' : '[0-9]';
    }

    return {
      pattern: pattern,
      count: [count],
      digits: digits
    };
  }

  function splitToPatterns(min, max, tok, options) {
    var ranges = splitToRanges(min, max);
    var tokens = [];
    var start = min;
    var prev;

    for (var i = 0; i < ranges.length; i++) {
      var _max = ranges[i];
      var obj = rangeToPattern(String(start), String(_max), options);
      var zeros = '';

      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        if (prev.count.length > 1) {
          prev.count.pop();
        }

        prev.count.push(obj.count[0]);
        prev.string = prev.pattern + toQuantifier(prev.count);
        start = _max + 1;
        continue;
      }

      if (tok.isPadded) {
        zeros = padZeros(_max, tok, options);
      }

      obj.string = zeros + obj.pattern + toQuantifier(obj.count);
      tokens.push(obj);
      start = _max + 1;
      prev = obj;
    }

    return tokens;
  }

  function filterPatterns(arr, comparison, prefix, intersection, options) {
    var result = [];
    var _iteratorNormalCompletion10 = true;
    var _didIteratorError10 = false;
    var _iteratorError10 = undefined;

    try {
      for (var _iterator10 = arr[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
        var ele = _step10.value;
        var string = ele.string; // only push if _both_ are negative...

        if (!intersection && !contains(comparison, 'string', string)) {
          result.push(prefix + string);
        } // or _both_ are positive


        if (intersection && contains(comparison, 'string', string)) {
          result.push(prefix + string);
        }
      }
    } catch (err) {
      _didIteratorError10 = true;
      _iteratorError10 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
          _iterator10["return"]();
        }
      } finally {
        if (_didIteratorError10) {
          throw _iteratorError10;
        }
      }
    }

    return result;
  }
  /**
   * Zip strings
   */


  function zip(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i++) {
      arr.push([a[i], b[i]]);
    }

    return arr;
  }

  function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  }

  function contains(arr, key, val) {
    return arr.some(function (ele) {
      return ele[key] === val;
    });
  }

  function countNines(min, len) {
    return Number(String(min).slice(0, -len) + '9'.repeat(len));
  }

  function countZeros(integer, zeros) {
    return integer - integer % Math.pow(10, zeros);
  }

  function toQuantifier(digits) {
    var _digits = _slicedToArray(digits, 2),
        _digits$ = _digits[0],
        start = _digits$ === void 0 ? 0 : _digits$,
        _digits$2 = _digits[1],
        stop = _digits$2 === void 0 ? '' : _digits$2;

    if (stop || start > 1) {
      return "{".concat(start + (stop ? ',' + stop : ''), "}");
    }

    return '';
  }

  function toCharacterClass(a, b, options) {
    return "[".concat(a).concat(b - a === 1 ? '' : '-').concat(b, "]");
  }

  function hasPadding(str) {
    return /^-?(0+)\d/.test(str);
  }

  function padZeros(value, tok, options) {
    if (!tok.isPadded) {
      return value;
    }

    var diff = Math.abs(tok.maxLen - String(value).length);
    var relax = options.relaxZeros !== false;

    switch (diff) {
      case 0:
        return '';

      case 1:
        return relax ? '0?' : '0';

      case 2:
        return relax ? '0{0,2}' : '00';

      default:
        {
          return relax ? "0{0,".concat(diff, "}") : "0{".concat(diff, "}");
        }
    }
  }
  /**
   * Cache
   */


  toRegexRange.cache = {};

  toRegexRange.clearCache = function () {
    return toRegexRange.cache = {};
  };
  /**
   * Expose `toRegexRange`
   */


  toRegexRange_1 = toRegexRange;
  return toRegexRange_1;
}
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */


var fillRange;
var hasRequiredFillRange;

function requireFillRange() {
  if (hasRequiredFillRange) return fillRange;
  hasRequiredFillRange = 1;
  var util = require$$2;
  var toRegexRange =
  /*@__PURE__*/
  requireToRegexRange();

  var isObject = function isObject(val) {
    return val !== null && _typeof(val) === 'object' && !Array.isArray(val);
  };

  var transform = function transform(toNumber) {
    return function (value) {
      return toNumber === true ? Number(value) : String(value);
    };
  };

  var isValidValue = function isValidValue(value) {
    return typeof value === 'number' || typeof value === 'string' && value !== '';
  };

  var isNumber = function isNumber(num) {
    return Number.isInteger(+num);
  };

  var zeros = function zeros(input) {
    var value = "".concat(input);
    var index = -1;
    if (value[0] === '-') value = value.slice(1);
    if (value === '0') return false;

    while (value[++index] === '0') {
      ;
    }

    return index > 0;
  };

  var stringify = function stringify(start, end, options) {
    if (typeof start === 'string' || typeof end === 'string') {
      return true;
    }

    return options.stringify === true;
  };

  var pad = function pad(input, maxLength, toNumber) {
    if (maxLength > 0) {
      var dash = input[0] === '-' ? '-' : '';
      if (dash) input = input.slice(1);
      input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');
    }

    if (toNumber === false) {
      return String(input);
    }

    return input;
  };

  var toMaxLen = function toMaxLen(input, maxLength) {
    var negative = input[0] === '-' ? '-' : '';

    if (negative) {
      input = input.slice(1);
      maxLength--;
    }

    while (input.length < maxLength) {
      input = '0' + input;
    }

    return negative ? '-' + input : input;
  };

  var toSequence = function toSequence(parts, options, maxLen) {
    parts.negatives.sort(function (a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    });
    parts.positives.sort(function (a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    });
    var prefix = options.capture ? '' : '?:';
    var positives = '';
    var negatives = '';
    var result;

    if (parts.positives.length) {
      positives = parts.positives.map(function (v) {
        return toMaxLen(String(v), maxLen);
      }).join('|');
    }

    if (parts.negatives.length) {
      negatives = "-(".concat(prefix).concat(parts.negatives.map(function (v) {
        return toMaxLen(String(v), maxLen);
      }).join('|'), ")");
    }

    if (positives && negatives) {
      result = "".concat(positives, "|").concat(negatives);
    } else {
      result = positives || negatives;
    }

    if (options.wrap) {
      return "(".concat(prefix).concat(result, ")");
    }

    return result;
  };

  var toRange = function toRange(a, b, isNumbers, options) {
    if (isNumbers) {
      return toRegexRange(a, b, _objectSpread({
        wrap: false
      }, options));
    }

    var start = String.fromCharCode(a);
    if (a === b) return start;
    var stop = String.fromCharCode(b);
    return "[".concat(start, "-").concat(stop, "]");
  };

  var toRegex = function toRegex(start, end, options) {
    if (Array.isArray(start)) {
      var wrap = options.wrap === true;
      var prefix = options.capture ? '' : '?:';
      return wrap ? "(".concat(prefix).concat(start.join('|'), ")") : start.join('|');
    }

    return toRegexRange(start, end, options);
  };

  var rangeError = function rangeError() {
    return new RangeError('Invalid range arguments: ' + util.inspect.apply(util, arguments));
  };

  var invalidRange = function invalidRange(start, end, options) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  };

  var invalidStep = function invalidStep(step, options) {
    if (options.strictRanges === true) {
      throw new TypeError("Expected step \"".concat(step, "\" to be a number"));
    }

    return [];
  };

  var fillNumbers = function fillNumbers(start, end) {
    var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var a = Number(start);
    var b = Number(end);

    if (!Number.isInteger(a) || !Number.isInteger(b)) {
      if (options.strictRanges === true) throw rangeError([start, end]);
      return [];
    } // fix negative zero


    if (a === 0) a = 0;
    if (b === 0) b = 0;
    var descending = a > b;
    var startString = String(start);
    var endString = String(end);
    var stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    var padded = zeros(startString) || zeros(endString) || zeros(stepString);
    var maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    var toNumber = padded === false && stringify(start, end, options) === false;
    var format = options.transform || transform(toNumber);

    if (options.toRegex && step === 1) {
      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
    }

    var parts = {
      negatives: [],
      positives: []
    };

    var push = function push(num) {
      return parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
    };

    var range = [];
    var index = 0;

    while (descending ? a >= b : a <= b) {
      if (options.toRegex === true && step > 1) {
        push(a);
      } else {
        range.push(pad(format(a, index), maxLen, toNumber));
      }

      a = descending ? a - step : a + step;
      index++;
    }

    if (options.toRegex === true) {
      return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range, null, _objectSpread({
        wrap: false
      }, options));
    }

    return range;
  };

  var fillLetters = function fillLetters(start, end) {
    var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
      return invalidRange(start, end, options);
    }

    var format = options.transform || function (val) {
      return String.fromCharCode(val);
    };

    var a = "".concat(start).charCodeAt(0);
    var b = "".concat(end).charCodeAt(0);
    var descending = a > b;
    var min = Math.min(a, b);
    var max = Math.max(a, b);

    if (options.toRegex && step === 1) {
      return toRange(min, max, false, options);
    }

    var range = [];
    var index = 0;

    while (descending ? a >= b : a <= b) {
      range.push(format(a, index));
      a = descending ? a - step : a + step;
      index++;
    }

    if (options.toRegex === true) {
      return toRegex(range, null, {
        wrap: false,
        options: options
      });
    }

    return range;
  };

  var fill = function fill(start, end, step) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    if (end == null && isValidValue(start)) {
      return [start];
    }

    if (!isValidValue(start) || !isValidValue(end)) {
      return invalidRange(start, end, options);
    }

    if (typeof step === 'function') {
      return fill(start, end, 1, {
        transform: step
      });
    }

    if (isObject(step)) {
      return fill(start, end, 0, step);
    }

    var opts = _objectSpread({}, options);

    if (opts.capture === true) opts.wrap = true;
    step = step || opts.step || 1;

    if (!isNumber(step)) {
      if (step != null && !isObject(step)) return invalidStep(step, opts);
      return fill(start, end, 1, step);
    }

    if (isNumber(start) && isNumber(end)) {
      return fillNumbers(start, end, step, opts);
    }

    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
  };

  fillRange = fill;
  return fillRange;
}

var compile_1;
var hasRequiredCompile;

function requireCompile() {
  if (hasRequiredCompile) return compile_1;
  hasRequiredCompile = 1;
  var fill =
  /*@__PURE__*/
  requireFillRange();
  var utils =
  /*@__PURE__*/
  requireUtils();

  var compile = function compile(ast) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var walk = function walk(node) {
      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var invalidBlock = utils.isInvalidBrace(parent);
      var invalidNode = node.invalid === true && options.escapeInvalid === true;
      var invalid = invalidBlock === true || invalidNode === true;
      var prefix = options.escapeInvalid === true ? '\\' : '';
      var output = '';

      if (node.isOpen === true) {
        return prefix + node.value;
      }

      if (node.isClose === true) {
        console.log('node.isClose', prefix, node.value);
        return prefix + node.value;
      }

      if (node.type === 'open') {
        return invalid ? prefix + node.value : '(';
      }

      if (node.type === 'close') {
        return invalid ? prefix + node.value : ')';
      }

      if (node.type === 'comma') {
        return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';
      }

      if (node.value) {
        return node.value;
      }

      if (node.nodes && node.ranges > 0) {
        var args = utils.reduce(node.nodes);
        var range = fill.apply(void 0, _toConsumableArray(args).concat([_objectSpread({}, options, {
          wrap: false,
          toRegex: true,
          strictZeros: true
        })]));

        if (range.length !== 0) {
          return args.length > 1 && range.length > 1 ? "(".concat(range, ")") : range;
        }
      }

      if (node.nodes) {
        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = node.nodes[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var child = _step11.value;
            output += walk(child, node);
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
              _iterator11["return"]();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }
      }

      return output;
    };

    return walk(ast);
  };

  compile_1 = compile;
  return compile_1;
}

var expand_1;
var hasRequiredExpand;

function requireExpand() {
  if (hasRequiredExpand) return expand_1;
  hasRequiredExpand = 1;
  var fill =
  /*@__PURE__*/
  requireFillRange();
  var stringify =
  /*@__PURE__*/
  requireStringify();
  var utils =
  /*@__PURE__*/
  requireUtils();

  var append = function append() {
    var queue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var stash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var enclose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var result = [];
    queue = [].concat(queue);
    stash = [].concat(stash);
    if (!stash.length) return queue;

    if (!queue.length) {
      return enclose ? utils.flatten(stash).map(function (ele) {
        return "{".concat(ele, "}");
      }) : stash;
    }

    var _iteratorNormalCompletion12 = true;
    var _didIteratorError12 = false;
    var _iteratorError12 = undefined;

    try {
      for (var _iterator12 = queue[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
        var item = _step12.value;

        if (Array.isArray(item)) {
          var _iteratorNormalCompletion13 = true;
          var _didIteratorError13 = false;
          var _iteratorError13 = undefined;

          try {
            for (var _iterator13 = item[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
              var value = _step13.value;
              result.push(append(value, stash, enclose));
            }
          } catch (err) {
            _didIteratorError13 = true;
            _iteratorError13 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
                _iterator13["return"]();
              }
            } finally {
              if (_didIteratorError13) {
                throw _iteratorError13;
              }
            }
          }
        } else {
          var _iteratorNormalCompletion14 = true;
          var _didIteratorError14 = false;
          var _iteratorError14 = undefined;

          try {
            for (var _iterator14 = stash[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
              var ele = _step14.value;
              if (enclose === true && typeof ele === 'string') ele = "{".concat(ele, "}");
              result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
            }
          } catch (err) {
            _didIteratorError14 = true;
            _iteratorError14 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
                _iterator14["return"]();
              }
            } finally {
              if (_didIteratorError14) {
                throw _iteratorError14;
              }
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError12 = true;
      _iteratorError12 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
          _iterator12["return"]();
        }
      } finally {
        if (_didIteratorError12) {
          throw _iteratorError12;
        }
      }
    }

    return utils.flatten(result);
  };

  var expand = function expand(ast) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;

    var walk = function walk(node) {
      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      node.queue = [];
      var p = parent;
      var q = parent.queue;

      while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
        p = p.parent;
        q = p.queue;
      }

      if (node.invalid || node.dollar) {
        q.push(append(q.pop(), stringify(node, options)));
        return;
      }

      if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
        q.push(append(q.pop(), ['{}']));
        return;
      }

      if (node.nodes && node.ranges > 0) {
        var args = utils.reduce(node.nodes);

        if (utils.exceedsLimit.apply(utils, _toConsumableArray(args).concat([options.step, rangeLimit]))) {
          throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
        }

        var range = fill.apply(void 0, _toConsumableArray(args).concat([options]));

        if (range.length === 0) {
          range = stringify(node, options);
        }

        q.push(append(q.pop(), range));
        node.nodes = [];
        return;
      }

      var enclose = utils.encloseBrace(node);
      var queue = node.queue;
      var block = node;

      while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
        block = block.parent;
        queue = block.queue;
      }

      for (var i = 0; i < node.nodes.length; i++) {
        var child = node.nodes[i];

        if (child.type === 'comma' && node.type === 'brace') {
          if (i === 1) queue.push('');
          queue.push('');
          continue;
        }

        if (child.type === 'close') {
          q.push(append(q.pop(), queue, enclose));
          continue;
        }

        if (child.value && child.type !== 'open') {
          queue.push(append(queue.pop(), child.value));
          continue;
        }

        if (child.nodes) {
          walk(child, node);
        }
      }

      return queue;
    };

    return utils.flatten(walk(ast));
  };

  expand_1 = expand;
  return expand_1;
}

var constants$1;
var hasRequiredConstants$1;

function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  constants$1 = {
    MAX_LENGTH: 10000,
    // Digits
    CHAR_0: '0',

    /* 0 */
    CHAR_9: '9',

    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 'A',

    /* A */
    CHAR_LOWERCASE_A: 'a',

    /* a */
    CHAR_UPPERCASE_Z: 'Z',

    /* Z */
    CHAR_LOWERCASE_Z: 'z',

    /* z */
    CHAR_LEFT_PARENTHESES: '(',

    /* ( */
    CHAR_RIGHT_PARENTHESES: ')',

    /* ) */
    CHAR_ASTERISK: '*',

    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: '&',

    /* & */
    CHAR_AT: '@',

    /* @ */
    CHAR_BACKSLASH: '\\',

    /* \ */
    CHAR_BACKTICK: '`',

    /* ` */
    CHAR_CARRIAGE_RETURN: '\r',

    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: '^',

    /* ^ */
    CHAR_COLON: ':',

    /* : */
    CHAR_COMMA: ',',

    /* , */
    CHAR_DOLLAR: '$',

    /* . */
    CHAR_DOT: '.',

    /* . */
    CHAR_DOUBLE_QUOTE: '"',

    /* " */
    CHAR_EQUAL: '=',

    /* = */
    CHAR_EXCLAMATION_MARK: '!',

    /* ! */
    CHAR_FORM_FEED: '\f',

    /* \f */
    CHAR_FORWARD_SLASH: '/',

    /* / */
    CHAR_HASH: '#',

    /* # */
    CHAR_HYPHEN_MINUS: '-',

    /* - */
    CHAR_LEFT_ANGLE_BRACKET: '<',

    /* < */
    CHAR_LEFT_CURLY_BRACE: '{',

    /* { */
    CHAR_LEFT_SQUARE_BRACKET: '[',

    /* [ */
    CHAR_LINE_FEED: '\n',

    /* \n */
    CHAR_NO_BREAK_SPACE: "\xA0",

    /* \u00A0 */
    CHAR_PERCENT: '%',

    /* % */
    CHAR_PLUS: '+',

    /* + */
    CHAR_QUESTION_MARK: '?',

    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: '>',

    /* > */
    CHAR_RIGHT_CURLY_BRACE: '}',

    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: ']',

    /* ] */
    CHAR_SEMICOLON: ';',

    /* ; */
    CHAR_SINGLE_QUOTE: '\'',

    /* ' */
    CHAR_SPACE: ' ',

    /*   */
    CHAR_TAB: '\t',

    /* \t */
    CHAR_UNDERSCORE: '_',

    /* _ */
    CHAR_VERTICAL_LINE: '|',

    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    /* \uFEFF */

  };
  return constants$1;
}

var parse_1;
var hasRequiredParse;

function requireParse() {
  if (hasRequiredParse) return parse_1;
  hasRequiredParse = 1;
  var stringify =
  /*@__PURE__*/
  requireStringify();
  /**
   * Constants
   */

  var _requireConstants$5 =
  /*@__PURE__*/
  requireConstants$1(),
      MAX_LENGTH = _requireConstants$5.MAX_LENGTH,
      CHAR_BACKSLASH = _requireConstants$5.CHAR_BACKSLASH,
      CHAR_BACKTICK = _requireConstants$5.CHAR_BACKTICK,
      CHAR_COMMA = _requireConstants$5.CHAR_COMMA,
      CHAR_DOT = _requireConstants$5.CHAR_DOT,
      CHAR_LEFT_PARENTHESES = _requireConstants$5.CHAR_LEFT_PARENTHESES,
      CHAR_RIGHT_PARENTHESES = _requireConstants$5.CHAR_RIGHT_PARENTHESES,
      CHAR_LEFT_CURLY_BRACE = _requireConstants$5.CHAR_LEFT_CURLY_BRACE,
      CHAR_RIGHT_CURLY_BRACE = _requireConstants$5.CHAR_RIGHT_CURLY_BRACE,
      CHAR_LEFT_SQUARE_BRACKET = _requireConstants$5.CHAR_LEFT_SQUARE_BRACKET,
      CHAR_RIGHT_SQUARE_BRACKET = _requireConstants$5.CHAR_RIGHT_SQUARE_BRACKET,
      CHAR_DOUBLE_QUOTE = _requireConstants$5.CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE = _requireConstants$5.CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE = _requireConstants$5.CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE = _requireConstants$5.CHAR_ZERO_WIDTH_NOBREAK_SPACE;
  /**
   * parse
   */


  var parse = function parse(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (typeof input !== 'string') {
      throw new TypeError('Expected a string');
    }

    var opts = options || {};
    var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

    if (input.length > max) {
      throw new SyntaxError("Input length (".concat(input.length, "), exceeds max characters (").concat(max, ")"));
    }

    var ast = {
      type: 'root',
      input: input,
      nodes: []
    };
    var stack = [ast];
    var block = ast;
    var prev = ast;
    var brackets = 0;
    var length = input.length;
    var index = 0;
    var depth = 0;
    var value;
    /**
     * Helpers
     */

    var advance = function advance() {
      return input[index++];
    };

    var push = function push(node) {
      if (node.type === 'text' && prev.type === 'dot') {
        prev.type = 'text';
      }

      if (prev && prev.type === 'text' && node.type === 'text') {
        prev.value += node.value;
        return;
      }

      block.nodes.push(node);
      node.parent = block;
      node.prev = prev;
      prev = node;
      return node;
    };

    push({
      type: 'bos'
    });

    while (index < length) {
      block = stack[stack.length - 1];
      value = advance();
      /**
       * Invalid chars
       */

      if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
        continue;
      }
      /**
       * Escaped chars
       */


      if (value === CHAR_BACKSLASH) {
        push({
          type: 'text',
          value: (options.keepEscaping ? value : '') + advance()
        });
        continue;
      }
      /**
       * Right square bracket (literal): ']'
       */


      if (value === CHAR_RIGHT_SQUARE_BRACKET) {
        push({
          type: 'text',
          value: '\\' + value
        });
        continue;
      }
      /**
       * Left square bracket: '['
       */


      if (value === CHAR_LEFT_SQUARE_BRACKET) {
        brackets++;
        var next = void 0;

        while (index < length && (next = advance())) {
          value += next;

          if (next === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            continue;
          }

          if (next === CHAR_BACKSLASH) {
            value += advance();
            continue;
          }

          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            brackets--;

            if (brackets === 0) {
              break;
            }
          }
        }

        push({
          type: 'text',
          value: value
        });
        continue;
      }
      /**
       * Parentheses
       */


      if (value === CHAR_LEFT_PARENTHESES) {
        block = push({
          type: 'paren',
          nodes: []
        });
        stack.push(block);
        push({
          type: 'text',
          value: value
        });
        continue;
      }

      if (value === CHAR_RIGHT_PARENTHESES) {
        if (block.type !== 'paren') {
          push({
            type: 'text',
            value: value
          });
          continue;
        }

        block = stack.pop();
        push({
          type: 'text',
          value: value
        });
        block = stack[stack.length - 1];
        continue;
      }
      /**
       * Quotes: '|"|`
       */


      if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
        var open = value;

        var _next3 = void 0;

        if (options.keepQuotes !== true) {
          value = '';
        }

        while (index < length && (_next3 = advance())) {
          if (_next3 === CHAR_BACKSLASH) {
            value += _next3 + advance();
            continue;
          }

          if (_next3 === open) {
            if (options.keepQuotes === true) value += _next3;
            break;
          }

          value += _next3;
        }

        push({
          type: 'text',
          value: value
        });
        continue;
      }
      /**
       * Left curly brace: '{'
       */


      if (value === CHAR_LEFT_CURLY_BRACE) {
        depth++;
        var dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
        var brace = {
          type: 'brace',
          open: true,
          close: false,
          dollar: dollar,
          depth: depth,
          commas: 0,
          ranges: 0,
          nodes: []
        };
        block = push(brace);
        stack.push(block);
        push({
          type: 'open',
          value: value
        });
        continue;
      }
      /**
       * Right curly brace: '}'
       */


      if (value === CHAR_RIGHT_CURLY_BRACE) {
        if (block.type !== 'brace') {
          push({
            type: 'text',
            value: value
          });
          continue;
        }

        var type = 'close';
        block = stack.pop();
        block.close = true;
        push({
          type: type,
          value: value
        });
        depth--;
        block = stack[stack.length - 1];
        continue;
      }
      /**
       * Comma: ','
       */


      if (value === CHAR_COMMA && depth > 0) {
        if (block.ranges > 0) {
          block.ranges = 0;

          var _open = block.nodes.shift();

          block.nodes = [_open, {
            type: 'text',
            value: stringify(block)
          }];
        }

        push({
          type: 'comma',
          value: value
        });
        block.commas++;
        continue;
      }
      /**
       * Dot: '.'
       */


      if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
        var siblings = block.nodes;

        if (depth === 0 || siblings.length === 0) {
          push({
            type: 'text',
            value: value
          });
          continue;
        }

        if (prev.type === 'dot') {
          block.range = [];
          prev.value += value;
          prev.type = 'range';

          if (block.nodes.length !== 3 && block.nodes.length !== 5) {
            block.invalid = true;
            block.ranges = 0;
            prev.type = 'text';
            continue;
          }

          block.ranges++;
          block.args = [];
          continue;
        }

        if (prev.type === 'range') {
          siblings.pop();
          var before = siblings[siblings.length - 1];
          before.value += prev.value + value;
          prev = before;
          block.ranges--;
          continue;
        }

        push({
          type: 'dot',
          value: value
        });
        continue;
      }
      /**
       * Text
       */


      push({
        type: 'text',
        value: value
      });
    } // Mark imbalanced braces and brackets as invalid


    do {
      block = stack.pop();

      if (block.type !== 'root') {
        var _parent$nodes;

        block.nodes.forEach(function (node) {
          if (!node.nodes) {
            if (node.type === 'open') node.isOpen = true;
            if (node.type === 'close') node.isClose = true;
            if (!node.nodes) node.type = 'text';
            node.invalid = true;
          }
        }); // get the location of the block on parent.nodes (block's siblings)

        var parent = stack[stack.length - 1];

        var _index2 = parent.nodes.indexOf(block); // replace the (invalid) block with it's nodes


        (_parent$nodes = parent.nodes).splice.apply(_parent$nodes, [_index2, 1].concat(_toConsumableArray(block.nodes)));
      }
    } while (stack.length > 0);

    push({
      type: 'eos'
    });
    return ast;
  };

  parse_1 = parse;
  return parse_1;
}

var braces_1;
var hasRequiredBraces;

function requireBraces() {
  if (hasRequiredBraces) return braces_1;
  hasRequiredBraces = 1;
  var stringify =
  /*@__PURE__*/
  requireStringify();
  var compile =
  /*@__PURE__*/
  requireCompile();
  var expand =
  /*@__PURE__*/
  requireExpand();
  var parse =
  /*@__PURE__*/
  requireParse();
  /**
   * Expand the given pattern or create a regex-compatible string.
   *
   * ```js
   * const braces = require('braces');
   * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
   * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
   * ```
   * @param {String} `str`
   * @param {Object} `options`
   * @return {String}
   * @api public
   */

  var braces = function braces(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var output = [];

    if (Array.isArray(input)) {
      var _iteratorNormalCompletion15 = true;
      var _didIteratorError15 = false;
      var _iteratorError15 = undefined;

      try {
        for (var _iterator15 = input[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
          var pattern = _step15.value;
          var result = braces.create(pattern, options);

          if (Array.isArray(result)) {
            var _output7;

            (_output7 = output).push.apply(_output7, _toConsumableArray(result));
          } else {
            output.push(result);
          }
        }
      } catch (err) {
        _didIteratorError15 = true;
        _iteratorError15 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
            _iterator15["return"]();
          }
        } finally {
          if (_didIteratorError15) {
            throw _iteratorError15;
          }
        }
      }
    } else {
      output = [].concat(braces.create(input, options));
    }

    if (options && options.expand === true && options.nodupes === true) {
      output = _toConsumableArray(new Set(output));
    }

    return output;
  };
  /**
   * Parse the given `str` with the given `options`.
   *
   * ```js
   * // braces.parse(pattern, [, options]);
   * const ast = braces.parse('a/{b,c}/d');
   * console.log(ast);
   * ```
   * @param {String} pattern Brace pattern to parse
   * @param {Object} options
   * @return {Object} Returns an AST
   * @api public
   */


  braces.parse = function (input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return parse(input, options);
  };
  /**
   * Creates a braces string from an AST, or an AST node.
   *
   * ```js
   * const braces = require('braces');
   * let ast = braces.parse('foo/{a,b}/bar');
   * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
   * ```
   * @param {String} `input` Brace pattern or AST.
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */


  braces.stringify = function (input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (typeof input === 'string') {
      return stringify(braces.parse(input, options), options);
    }

    return stringify(input, options);
  };
  /**
   * Compiles a brace pattern into a regex-compatible, optimized string.
   * This method is called by the main [braces](#braces) function by default.
   *
   * ```js
   * const braces = require('braces');
   * console.log(braces.compile('a/{b,c}/d'));
   * //=> ['a/(b|c)/d']
   * ```
   * @param {String} `input` Brace pattern or AST.
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */


  braces.compile = function (input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (typeof input === 'string') {
      input = braces.parse(input, options);
    }

    return compile(input, options);
  };
  /**
   * Expands a brace pattern into an array. This method is called by the
   * main [braces](#braces) function when `options.expand` is true. Before
   * using this method it's recommended that you read the [performance notes](#performance))
   * and advantages of using [.compile](#compile) instead.
   *
   * ```js
   * const braces = require('braces');
   * console.log(braces.expand('a/{b,c}/d'));
   * //=> ['a/b/d', 'a/c/d'];
   * ```
   * @param {String} `pattern` Brace pattern
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */


  braces.expand = function (input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (typeof input === 'string') {
      input = braces.parse(input, options);
    }

    var result = expand(input, options); // filter out empty strings if specified

    if (options.noempty === true) {
      result = result.filter(Boolean);
    } // filter out duplicates if specified


    if (options.nodupes === true) {
      result = _toConsumableArray(new Set(result));
    }

    return result;
  };
  /**
   * Processes a brace pattern and returns either an expanded array
   * (if `options.expand` is true), a highly optimized regex-compatible string.
   * This method is called by the main [braces](#braces) function.
   *
   * ```js
   * const braces = require('braces');
   * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
   * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
   * ```
   * @param {String} `pattern` Brace pattern
   * @param {Object} `options`
   * @return {Array} Returns an array of expanded values.
   * @api public
   */


  braces.create = function (input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (input === '' || input.length < 3) {
      return [input];
    }

    return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
  };
  /**
   * Expose "braces"
   */


  braces_1 = braces;
  return braces_1;
}

var require$$0 = ["3dm", "3ds", "3g2", "3gp", "7z", "a", "aac", "adp", "afdesign", "afphoto", "afpub", "ai", "aif", "aiff", "alz", "ape", "apk", "appimage", "ar", "arj", "asf", "au", "avi", "bak", "baml", "bh", "bin", "bk", "bmp", "btif", "bz2", "bzip2", "cab", "caf", "cgm", "class", "cmx", "cpio", "cr2", "cur", "dat", "dcm", "deb", "dex", "djvu", "dll", "dmg", "dng", "doc", "docm", "docx", "dot", "dotm", "dra", "DS_Store", "dsk", "dts", "dtshd", "dvb", "dwg", "dxf", "ecelp4800", "ecelp7470", "ecelp9600", "egg", "eol", "eot", "epub", "exe", "f4v", "fbs", "fh", "fla", "flac", "flatpak", "fli", "flv", "fpx", "fst", "fvt", "g3", "gh", "gif", "graffle", "gz", "gzip", "h261", "h263", "h264", "icns", "ico", "ief", "img", "ipa", "iso", "jar", "jpeg", "jpg", "jpgv", "jpm", "jxr", "key", "ktx", "lha", "lib", "lvp", "lz", "lzh", "lzma", "lzo", "m3u", "m4a", "m4v", "mar", "mdi", "mht", "mid", "midi", "mj2", "mka", "mkv", "mmr", "mng", "mobi", "mov", "movie", "mp3", "mp4", "mp4a", "mpeg", "mpg", "mpga", "mxu", "nef", "npx", "numbers", "nupkg", "o", "odp", "ods", "odt", "oga", "ogg", "ogv", "otf", "ott", "pages", "pbm", "pcx", "pdb", "pdf", "pea", "pgm", "pic", "png", "pnm", "pot", "potm", "potx", "ppa", "ppam", "ppm", "pps", "ppsm", "ppsx", "ppt", "pptm", "pptx", "psd", "pya", "pyc", "pyo", "pyv", "qt", "rar", "ras", "raw", "resources", "rgb", "rip", "rlc", "rmf", "rmvb", "rpm", "rtf", "rz", "s3m", "s7z", "scpt", "sgi", "shar", "snap", "sil", "sketch", "slk", "smv", "snk", "so", "stl", "suo", "sub", "swf", "tar", "tbz", "tbz2", "tga", "tgz", "thmx", "tif", "tiff", "tlz", "ttc", "ttf", "txz", "udf", "uvh", "uvi", "uvm", "uvp", "uvs", "uvu", "viv", "vob", "war", "wav", "wax", "wbmp", "wdp", "weba", "webm", "webp", "whl", "wim", "wm", "wma", "wmv", "wmx", "woff", "woff2", "wrm", "wvx", "xbm", "xif", "xla", "xlam", "xls", "xlsb", "xlsm", "xlsx", "xlt", "xltm", "xltx", "xm", "xmind", "xpi", "xpm", "xwd", "xz", "z", "zip", "zipx"];
var binaryExtensions;
var hasRequiredBinaryExtensions;

function requireBinaryExtensions() {
  if (hasRequiredBinaryExtensions) return binaryExtensions;
  hasRequiredBinaryExtensions = 1;
  binaryExtensions = require$$0;
  return binaryExtensions;
}

var isBinaryPath;
var hasRequiredIsBinaryPath;

function requireIsBinaryPath() {
  if (hasRequiredIsBinaryPath) return isBinaryPath;
  hasRequiredIsBinaryPath = 1;
  var path = require$$0$1;
  var binaryExtensions =
  /*@__PURE__*/
  requireBinaryExtensions();
  var extensions = new Set(binaryExtensions);

  isBinaryPath = function isBinaryPath(filePath) {
    return extensions.has(path.extname(filePath).slice(1).toLowerCase());
  };

  return isBinaryPath;
}

var constants = {};
var hasRequiredConstants;

function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;

  (function (exports) {
    var sep = require$$0$1.sep;
    var _process = process,
        platform = _process.platform;
    var os = require$$2$1;
    exports.EV_ALL = 'all';
    exports.EV_READY = 'ready';
    exports.EV_ADD = 'add';
    exports.EV_CHANGE = 'change';
    exports.EV_ADD_DIR = 'addDir';
    exports.EV_UNLINK = 'unlink';
    exports.EV_UNLINK_DIR = 'unlinkDir';
    exports.EV_RAW = 'raw';
    exports.EV_ERROR = 'error';
    exports.STR_DATA = 'data';
    exports.STR_END = 'end';
    exports.STR_CLOSE = 'close';
    exports.FSEVENT_CREATED = 'created';
    exports.FSEVENT_MODIFIED = 'modified';
    exports.FSEVENT_DELETED = 'deleted';
    exports.FSEVENT_MOVED = 'moved';
    exports.FSEVENT_CLONED = 'cloned';
    exports.FSEVENT_UNKNOWN = 'unknown';
    exports.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;
    exports.FSEVENT_TYPE_FILE = 'file';
    exports.FSEVENT_TYPE_DIRECTORY = 'directory';
    exports.FSEVENT_TYPE_SYMLINK = 'symlink';
    exports.KEY_LISTENERS = 'listeners';
    exports.KEY_ERR = 'errHandlers';
    exports.KEY_RAW = 'rawEmitters';
    exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];
    exports.DOT_SLASH = ".".concat(sep);
    exports.BACK_SLASH_RE = /\\/g;
    exports.DOUBLE_SLASH_RE = /\/\//;
    exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
    exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
    exports.REPLACER_RE = /^\.[/\\]/;
    exports.SLASH = '/';
    exports.SLASH_SLASH = '//';
    exports.BRACE_START = '{';
    exports.BANG = '!';
    exports.ONE_DOT = '.';
    exports.TWO_DOTS = '..';
    exports.STAR = '*';
    exports.GLOBSTAR = '**';
    exports.ROOT_GLOBSTAR = '/**/*';
    exports.SLASH_GLOBSTAR = '/**';
    exports.DIR_SUFFIX = 'Dir';
    exports.ANYMATCH_OPTS = {
      dot: true
    };
    exports.STRING_TYPE = 'string';
    exports.FUNCTION_TYPE = 'function';
    exports.EMPTY_STR = '';

    exports.EMPTY_FN = function () {};

    exports.IDENTITY_FN = function (val) {
      return val;
    };

    exports.isWindows = platform === 'win32';
    exports.isMacos = platform === 'darwin';
    exports.isLinux = platform === 'linux';
    exports.isIBMi = os.type() === 'OS400';
  })(constants);

  return constants;
}

var nodefsHandler;
var hasRequiredNodefsHandler;

function requireNodefsHandler() {
  if (hasRequiredNodefsHandler) return nodefsHandler;
  hasRequiredNodefsHandler = 1;
  var fs = require$$0$2;
  var sysPath = require$$0$1;
  var promisify = require$$2.promisify;
  var isBinaryPath =
  /*@__PURE__*/
  requireIsBinaryPath();

  var _requireConstants =
  /*@__PURE__*/
  requireConstants(),
      isWindows = _requireConstants.isWindows,
      isLinux = _requireConstants.isLinux,
      EMPTY_FN = _requireConstants.EMPTY_FN,
      EMPTY_STR = _requireConstants.EMPTY_STR,
      KEY_LISTENERS = _requireConstants.KEY_LISTENERS,
      KEY_ERR = _requireConstants.KEY_ERR,
      KEY_RAW = _requireConstants.KEY_RAW,
      HANDLER_KEYS = _requireConstants.HANDLER_KEYS,
      EV_CHANGE = _requireConstants.EV_CHANGE,
      EV_ADD = _requireConstants.EV_ADD,
      EV_ADD_DIR = _requireConstants.EV_ADD_DIR,
      EV_ERROR = _requireConstants.EV_ERROR,
      STR_DATA = _requireConstants.STR_DATA,
      STR_END = _requireConstants.STR_END,
      BRACE_START = _requireConstants.BRACE_START,
      STAR = _requireConstants.STAR;

  var THROTTLE_MODE_WATCH = 'watch';
  var open = promisify(fs.open);
  var stat = promisify(fs.stat);
  var lstat = promisify(fs.lstat);
  var close = promisify(fs.close);
  var fsrealpath = promisify(fs.realpath);
  var statMethods = {
    lstat: lstat,
    stat: stat
  }; // TODO: emit errors properly. Example: EMFILE on Macos.

  var foreach = function foreach(val, fn) {
    if (val instanceof Set) {
      val.forEach(fn);
    } else {
      fn(val);
    }
  };

  var addAndConvert = function addAndConvert(main, prop, item) {
    var container = main[prop];

    if (!(container instanceof Set)) {
      main[prop] = container = new Set([container]);
    }

    container.add(item);
  };

  var clearItem = function clearItem(cont) {
    return function (key) {
      var set = cont[key];

      if (set instanceof Set) {
        set.clear();
      } else {
        delete cont[key];
      }
    };
  };

  var delFromSet = function delFromSet(main, prop, item) {
    var container = main[prop];

    if (container instanceof Set) {
      container["delete"](item);
    } else if (container === item) {
      delete main[prop];
    }
  };

  var isEmptySet = function isEmptySet(val) {
    return val instanceof Set ? val.size === 0 : !val;
  };
  /**
   * @typedef {String} Path
   */
  // fs_watch helpers
  // object to hold per-process fs_watch instances
  // (may be shared across chokidar FSWatcher instances)

  /**
   * @typedef {Object} FsWatchContainer
   * @property {Set} listeners
   * @property {Set} errHandlers
   * @property {Set} rawEmitters
   * @property {fs.FSWatcher=} watcher
   * @property {Boolean=} watcherUnusable
   */

  /**
   * @type {Map<String,FsWatchContainer>}
   */


  var FsWatchInstances = new Map();
  /**
   * Instantiates the fs_watch interface
   * @param {String} path to be watched
   * @param {Object} options to be passed to fs_watch
   * @param {Function} listener main event handler
   * @param {Function} errHandler emits info about errors
   * @param {Function} emitRaw emits raw event data
   * @returns {fs.FSWatcher} new fsevents instance
   */

  function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
    var handleEvent = function handleEvent(rawEvent, evPath) {
      listener(path);
      emitRaw(rawEvent, evPath, {
        watchedPath: path
      }); // emit based on events occurring for files from a directory's watcher in
      // case the file's watcher misses it (and rely on throttling to de-dupe)

      if (evPath && path !== evPath) {
        fsWatchBroadcast(sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath));
      }
    };

    try {
      return fs.watch(path, options, handleEvent);
    } catch (error) {
      errHandler(error);
    }
  }
  /**
   * Helper for passing fs_watch event data to a collection of listeners
   * @param {Path} fullPath absolute path bound to fs_watch instance
   * @param {String} type listener type
   * @param {*=} val1 arguments to be passed to listeners
   * @param {*=} val2
   * @param {*=} val3
   */


  var fsWatchBroadcast = function fsWatchBroadcast(fullPath, type, val1, val2, val3) {
    var cont = FsWatchInstances.get(fullPath);
    if (!cont) return;
    foreach(cont[type], function (listener) {
      listener(val1, val2, val3);
    });
  };
  /**
   * Instantiates the fs_watch interface or binds listeners
   * to an existing one covering the same file system entry
   * @param {String} path
   * @param {String} fullPath absolute path
   * @param {Object} options to be passed to fs_watch
   * @param {Object} handlers container for event listener functions
   */


  var setFsWatchListener = function setFsWatchListener(path, fullPath, options, handlers) {
    var listener = handlers.listener,
        errHandler = handlers.errHandler,
        rawEmitter = handlers.rawEmitter;
    var cont = FsWatchInstances.get(fullPath);
    /** @type {fs.FSWatcher=} */

    var watcher;

    if (!options.persistent) {
      watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);
      return watcher.close.bind(watcher);
    }

    if (cont) {
      addAndConvert(cont, KEY_LISTENERS, listener);
      addAndConvert(cont, KEY_ERR, errHandler);
      addAndConvert(cont, KEY_RAW, rawEmitter);
    } else {
      watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here
      fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
      if (!watcher) return;
      watcher.on(EV_ERROR, function _callee(error) {
        var broadcastErr, fd;
        return regeneratorRuntime.async(function _callee$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
                cont.watcherUnusable = true; // documented since Node 10.4.1
                // Workaround for https://github.com/joyent/node/issues/4337

                if (!(isWindows && error.code === 'EPERM')) {
                  _context6.next = 16;
                  break;
                }

                _context6.prev = 3;
                _context6.next = 6;
                return regeneratorRuntime.awrap(open(path, 'r'));

              case 6:
                fd = _context6.sent;
                _context6.next = 9;
                return regeneratorRuntime.awrap(close(fd));

              case 9:
                broadcastErr(error);
                _context6.next = 14;
                break;

              case 12:
                _context6.prev = 12;
                _context6.t0 = _context6["catch"](3);

              case 14:
                _context6.next = 17;
                break;

              case 16:
                broadcastErr(error);

              case 17:
              case "end":
                return _context6.stop();
            }
          }
        }, null, null, [[3, 12]]);
      });
      cont = {
        listeners: listener,
        errHandlers: errHandler,
        rawEmitters: rawEmitter,
        watcher: watcher
      };
      FsWatchInstances.set(fullPath, cont);
    } // const index = cont.listeners.indexOf(listener);
    // removes this instance's listeners and closes the underlying fs_watch
    // instance if there are no more listeners left


    return function () {
      delFromSet(cont, KEY_LISTENERS, listener);
      delFromSet(cont, KEY_ERR, errHandler);
      delFromSet(cont, KEY_RAW, rawEmitter);

      if (isEmptySet(cont.listeners)) {
        // Check to protect against issue gh-730.
        // if (cont.watcherUnusable) {
        cont.watcher.close(); // }

        FsWatchInstances["delete"](fullPath);
        HANDLER_KEYS.forEach(clearItem(cont));
        cont.watcher = undefined;
        Object.freeze(cont);
      }
    };
  }; // fs_watchFile helpers
  // object to hold per-process fs_watchFile instances
  // (may be shared across chokidar FSWatcher instances)


  var FsWatchFileInstances = new Map();
  /**
   * Instantiates the fs_watchFile interface or binds listeners
   * to an existing one covering the same file system entry
   * @param {String} path to be watched
   * @param {String} fullPath absolute path
   * @param {Object} options options to be passed to fs_watchFile
   * @param {Object} handlers container for event listener functions
   * @returns {Function} closer
   */

  var setFsWatchFileListener = function setFsWatchFileListener(path, fullPath, options, handlers) {
    var listener = handlers.listener,
        rawEmitter = handlers.rawEmitter;
    var cont = FsWatchFileInstances.get(fullPath);
    var copts = cont && cont.options;

    if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
      fs.unwatchFile(fullPath);
      cont = undefined;
    }
    /* eslint-enable no-unused-vars, prefer-destructuring */


    if (cont) {
      addAndConvert(cont, KEY_LISTENERS, listener);
      addAndConvert(cont, KEY_RAW, rawEmitter);
    } else {
      // TODO
      // listeners.add(listener);
      // rawEmitters.add(rawEmitter);
      cont = {
        listeners: listener,
        rawEmitters: rawEmitter,
        options: options,
        watcher: fs.watchFile(fullPath, options, function (curr, prev) {
          foreach(cont.rawEmitters, function (rawEmitter) {
            rawEmitter(EV_CHANGE, fullPath, {
              curr: curr,
              prev: prev
            });
          });
          var currmtime = curr.mtimeMs;

          if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
            foreach(cont.listeners, function (listener) {
              return listener(path, curr);
            });
          }
        })
      };
      FsWatchFileInstances.set(fullPath, cont);
    } // const index = cont.listeners.indexOf(listener);
    // Removes this instance's listeners and closes the underlying fs_watchFile
    // instance if there are no more listeners left.


    return function () {
      delFromSet(cont, KEY_LISTENERS, listener);
      delFromSet(cont, KEY_RAW, rawEmitter);

      if (isEmptySet(cont.listeners)) {
        FsWatchFileInstances["delete"](fullPath);
        fs.unwatchFile(fullPath);
        cont.options = cont.watcher = undefined;
        Object.freeze(cont);
      }
    };
  };
  /**
   * @mixin
   */


  var NodeFsHandler =
  /*#__PURE__*/
  function () {
    /**
     * @param {import("../index").FSWatcher} fsW
     */
    function NodeFsHandler(fsW) {
      _classCallCheck(this, NodeFsHandler);

      this.fsw = fsW;

      this._boundHandleError = function (error) {
        return fsW._handleError(error);
      };
    }
    /**
     * Watch file for changes with fs_watchFile or fs_watch.
     * @param {String} path to file or dir
     * @param {Function} listener on fs change
     * @returns {Function} closer for the watcher instance
     */


    _createClass(NodeFsHandler, [{
      key: "_watchWithNodeFs",
      value: function _watchWithNodeFs(path, listener) {
        var opts = this.fsw.options;
        var directory = sysPath.dirname(path);
        var basename = sysPath.basename(path);

        var parent = this.fsw._getWatchedDir(directory);

        parent.add(basename);
        var absolutePath = sysPath.resolve(path);
        var options = {
          persistent: opts.persistent
        };
        if (!listener) listener = EMPTY_FN;
        var closer;

        if (opts.usePolling) {
          options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener(path, absolutePath, options, {
            listener: listener,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener(path, absolutePath, options, {
            listener: listener,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }

        return closer;
      }
      /**
       * Watch a file and emit add event if warranted.
       * @param {Path} file Path
       * @param {fs.Stats} stats result of fs_stat
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @returns {Function} closer for the watcher instance
       */

    }, {
      key: "_handleFile",
      value: function _handleFile(file, stats, initialAdd) {
        var _this3 = this;

        if (this.fsw.closed) {
          return;
        }

        var dirname = sysPath.dirname(file);
        var basename = sysPath.basename(file);

        var parent = this.fsw._getWatchedDir(dirname); // stats is always present


        var prevStats = stats; // if the file is already being watched, do nothing

        if (parent.has(basename)) return;

        var listener = function listener(path, newStats) {
          var _newStats, at, mt, _at, _mt;

          return regeneratorRuntime.async(function listener$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  if (_this3.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) {
                    _context7.next = 2;
                    break;
                  }

                  return _context7.abrupt("return");

                case 2:
                  if (!(!newStats || newStats.mtimeMs === 0)) {
                    _context7.next = 20;
                    break;
                  }

                  _context7.prev = 3;
                  _context7.next = 6;
                  return regeneratorRuntime.awrap(stat(file));

                case 6:
                  _newStats = _context7.sent;

                  if (!_this3.fsw.closed) {
                    _context7.next = 9;
                    break;
                  }

                  return _context7.abrupt("return");

                case 9:
                  // Check that change event was not fired because of changed only accessTime.
                  at = _newStats.atimeMs;
                  mt = _newStats.mtimeMs;

                  if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                    _this3.fsw._emit(EV_CHANGE, file, _newStats);
                  }

                  if (isLinux && prevStats.ino !== _newStats.ino) {
                    _this3.fsw._closeFile(path);

                    prevStats = _newStats;

                    _this3.fsw._addPathCloser(path, _this3._watchWithNodeFs(file, listener));
                  } else {
                    prevStats = _newStats;
                  }

                  _context7.next = 18;
                  break;

                case 15:
                  _context7.prev = 15;
                  _context7.t0 = _context7["catch"](3);

                  // Fix issues where mtime is null but file is still present
                  _this3.fsw._remove(dirname, basename);

                case 18:
                  _context7.next = 21;
                  break;

                case 20:
                  if (parent.has(basename)) {
                    // Check that change event was not fired because of changed only accessTime.
                    _at = newStats.atimeMs;
                    _mt = newStats.mtimeMs;

                    if (!_at || _at <= _mt || _mt !== prevStats.mtimeMs) {
                      _this3.fsw._emit(EV_CHANGE, file, newStats);
                    }

                    prevStats = newStats;
                  }

                case 21:
                case "end":
                  return _context7.stop();
              }
            }
          }, null, null, [[3, 15]]);
        }; // kick off the watcher


        var closer = this._watchWithNodeFs(file, listener); // emit an add event if we're supposed to


        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV_ADD, file, 0)) return;

          this.fsw._emit(EV_ADD, file, stats);
        }

        return closer;
      }
      /**
       * Handle symlinks encountered while reading a dir.
       * @param {Object} entry returned by readdirp
       * @param {String} directory path of dir being read
       * @param {String} path of this item
       * @param {String} item basename of this item
       * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
       */

    }, {
      key: "_handleSymlink",
      value: function _handleSymlink(entry, directory, path, item) {
        var full, dir, linkPath;
        return regeneratorRuntime.async(function _handleSymlink$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!this.fsw.closed) {
                  _context8.next = 2;
                  break;
                }

                return _context8.abrupt("return");

              case 2:
                full = entry.fullPath;
                dir = this.fsw._getWatchedDir(directory);

                if (this.fsw.options.followSymlinks) {
                  _context8.next = 21;
                  break;
                }

                // watch symlink directly (don't follow) and detect changes
                this.fsw._incrReadyCount();

                _context8.prev = 6;
                _context8.next = 9;
                return regeneratorRuntime.awrap(fsrealpath(path));

              case 9:
                linkPath = _context8.sent;
                _context8.next = 16;
                break;

              case 12:
                _context8.prev = 12;
                _context8.t0 = _context8["catch"](6);

                this.fsw._emitReady();

                return _context8.abrupt("return", true);

              case 16:
                if (!this.fsw.closed) {
                  _context8.next = 18;
                  break;
                }

                return _context8.abrupt("return");

              case 18:
                if (dir.has(item)) {
                  if (this.fsw._symlinkPaths.get(full) !== linkPath) {
                    this.fsw._symlinkPaths.set(full, linkPath);

                    this.fsw._emit(EV_CHANGE, path, entry.stats);
                  }
                } else {
                  dir.add(item);

                  this.fsw._symlinkPaths.set(full, linkPath);

                  this.fsw._emit(EV_ADD, path, entry.stats);
                }

                this.fsw._emitReady();

                return _context8.abrupt("return", true);

              case 21:
                if (!this.fsw._symlinkPaths.has(full)) {
                  _context8.next = 23;
                  break;
                }

                return _context8.abrupt("return", true);

              case 23:
                this.fsw._symlinkPaths.set(full, true);

              case 24:
              case "end":
                return _context8.stop();
            }
          }
        }, null, this, [[6, 12]]);
      }
    }, {
      key: "_handleRead",
      value: function _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
        var _this4 = this;

        // Normalize the directory name on Windows
        directory = sysPath.join(directory, EMPTY_STR);

        if (!wh.hasGlob) {
          throttler = this.fsw._throttle('readdir', directory, 1000);
          if (!throttler) return;
        }

        var previous = this.fsw._getWatchedDir(wh.path);

        var current = new Set();

        var stream = this.fsw._readdirp(directory, {
          fileFilter: function fileFilter(entry) {
            return wh.filterPath(entry);
          },
          directoryFilter: function directoryFilter(entry) {
            return wh.filterDir(entry);
          },
          depth: 0
        }).on(STR_DATA, function _callee2(entry) {
          var item, path;
          return regeneratorRuntime.async(function _callee2$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  if (!_this4.fsw.closed) {
                    _context9.next = 3;
                    break;
                  }

                  stream = undefined;
                  return _context9.abrupt("return");

                case 3:
                  item = entry.path;
                  path = sysPath.join(directory, item);
                  current.add(item);
                  _context9.t0 = entry.stats.isSymbolicLink();

                  if (!_context9.t0) {
                    _context9.next = 11;
                    break;
                  }

                  _context9.next = 10;
                  return regeneratorRuntime.awrap(_this4._handleSymlink(entry, directory, path, item));

                case 10:
                  _context9.t0 = _context9.sent;

                case 11:
                  if (!_context9.t0) {
                    _context9.next = 13;
                    break;
                  }

                  return _context9.abrupt("return");

                case 13:
                  if (!_this4.fsw.closed) {
                    _context9.next = 16;
                    break;
                  }

                  stream = undefined;
                  return _context9.abrupt("return");

                case 16:
                  // Files that present in current directory snapshot
                  // but absent in previous are added to watch list and
                  // emit `add` event.
                  if (item === target || !target && !previous.has(item)) {
                    _this4.fsw._incrReadyCount(); // ensure relativeness of path is preserved in case of watcher reuse


                    path = sysPath.join(dir, sysPath.relative(dir, path));

                    _this4._addToNodeFs(path, initialAdd, wh, depth + 1);
                  }

                case 17:
                case "end":
                  return _context9.stop();
              }
            }
          });
        }).on(EV_ERROR, this._boundHandleError);

        return new Promise(function (resolve) {
          return stream.once(STR_END, function () {
            if (_this4.fsw.closed) {
              stream = undefined;
              return;
            }

            var wasThrottled = throttler ? throttler.clear() : false;
            resolve(); // Files that absent in current directory snapshot
            // but present in previous emit `remove` event
            // and are removed from @watched[directory].

            previous.getChildren().filter(function (item) {
              return item !== directory && !current.has(item) && ( // in case of intersecting globs;
              // a path may have been filtered out of this readdir, but
              // shouldn't be removed because it matches a different glob
              !wh.hasGlob || wh.filterPath({
                fullPath: sysPath.resolve(directory, item)
              }));
            }).forEach(function (item) {
              _this4.fsw._remove(directory, item);
            });
            stream = undefined; // one more time for any missed in case changes came in extremely quickly

            if (wasThrottled) _this4._handleRead(directory, false, wh, target, dir, depth, throttler);
          });
        });
      }
      /**
       * Read directory to add / remove files from `@watched` list and re-read it on change.
       * @param {String} dir fs path
       * @param {fs.Stats} stats
       * @param {Boolean} initialAdd
       * @param {Number} depth relative to user-supplied path
       * @param {String} target child path targeted for watch
       * @param {Object} wh Common watch helpers for this path
       * @param {String} realpath
       * @returns {Promise<Function>} closer for the watcher instance.
       */

    }, {
      key: "_handleDir",
      value: function _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
        var _this5 = this;

        var parentDir, tracked, throttler, closer, oDepth;
        return regeneratorRuntime.async(function _handleDir$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
                tracked = parentDir.has(sysPath.basename(dir));

                if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
                  if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);
                } // ensure dir is tracked (harmless if redundant)


                parentDir.add(sysPath.basename(dir));

                this.fsw._getWatchedDir(dir);

                oDepth = this.fsw.options.depth;

                if (!((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath))) {
                  _context10.next = 13;
                  break;
                }

                if (target) {
                  _context10.next = 12;
                  break;
                }

                _context10.next = 10;
                return regeneratorRuntime.awrap(this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler));

              case 10:
                if (!this.fsw.closed) {
                  _context10.next = 12;
                  break;
                }

                return _context10.abrupt("return");

              case 12:
                closer = this._watchWithNodeFs(dir, function (dirPath, stats) {
                  // if current directory is removed, do nothing
                  if (stats && stats.mtimeMs === 0) return;

                  _this5._handleRead(dirPath, false, wh, target, dir, depth, throttler);
                });

              case 13:
                return _context10.abrupt("return", closer);

              case 14:
              case "end":
                return _context10.stop();
            }
          }
        }, null, this);
      }
      /**
       * Handle added file, directory, or glob pattern.
       * Delegates call to _handleFile / _handleDir after checks.
       * @param {String} path to file or ir
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @param {Object} priorWh depth relative to user-supplied path
       * @param {Number} depth Child path actually targeted for watch
       * @param {String=} target Child path actually targeted for watch
       * @returns {Promise}
       */

    }, {
      key: "_addToNodeFs",
      value: function _addToNodeFs(path, initialAdd, priorWh, depth, target) {
        var ready, wh, stats, follow, closer, absPath, targetPath, _targetPath, parent;

        return regeneratorRuntime.async(function _addToNodeFs$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                ready = this.fsw._emitReady;

                if (!(this.fsw._isIgnored(path) || this.fsw.closed)) {
                  _context11.next = 4;
                  break;
                }

                ready();
                return _context11.abrupt("return", false);

              case 4:
                wh = this.fsw._getWatchHelpers(path, depth);

                if (!wh.hasGlob && priorWh) {
                  wh.hasGlob = priorWh.hasGlob;
                  wh.globFilter = priorWh.globFilter;

                  wh.filterPath = function (entry) {
                    return priorWh.filterPath(entry);
                  };

                  wh.filterDir = function (entry) {
                    return priorWh.filterDir(entry);
                  };
                } // evaluate what is at the path we're being asked to watch


                _context11.prev = 6;
                _context11.next = 9;
                return regeneratorRuntime.awrap(statMethods[wh.statMethod](wh.watchPath));

              case 9:
                stats = _context11.sent;

                if (!this.fsw.closed) {
                  _context11.next = 12;
                  break;
                }

                return _context11.abrupt("return");

              case 12:
                if (!this.fsw._isIgnored(wh.watchPath, stats)) {
                  _context11.next = 15;
                  break;
                }

                ready();
                return _context11.abrupt("return", false);

              case 15:
                follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);

                if (!stats.isDirectory()) {
                  _context11.next = 36;
                  break;
                }

                absPath = sysPath.resolve(path);

                if (!follow) {
                  _context11.next = 24;
                  break;
                }

                _context11.next = 21;
                return regeneratorRuntime.awrap(fsrealpath(path));

              case 21:
                _context11.t0 = _context11.sent;
                _context11.next = 25;
                break;

              case 24:
                _context11.t0 = path;

              case 25:
                targetPath = _context11.t0;

                if (!this.fsw.closed) {
                  _context11.next = 28;
                  break;
                }

                return _context11.abrupt("return");

              case 28:
                _context11.next = 30;
                return regeneratorRuntime.awrap(this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath));

              case 30:
                closer = _context11.sent;

                if (!this.fsw.closed) {
                  _context11.next = 33;
                  break;
                }

                return _context11.abrupt("return");

              case 33:
                // preserve this symlink's target path
                if (absPath !== targetPath && targetPath !== undefined) {
                  this.fsw._symlinkPaths.set(absPath, targetPath);
                }

                _context11.next = 59;
                break;

              case 36:
                if (!stats.isSymbolicLink()) {
                  _context11.next = 58;
                  break;
                }

                if (!follow) {
                  _context11.next = 43;
                  break;
                }

                _context11.next = 40;
                return regeneratorRuntime.awrap(fsrealpath(path));

              case 40:
                _context11.t1 = _context11.sent;
                _context11.next = 44;
                break;

              case 43:
                _context11.t1 = path;

              case 44:
                _targetPath = _context11.t1;

                if (!this.fsw.closed) {
                  _context11.next = 47;
                  break;
                }

                return _context11.abrupt("return");

              case 47:
                parent = sysPath.dirname(wh.watchPath);

                this.fsw._getWatchedDir(parent).add(wh.watchPath);

                this.fsw._emit(EV_ADD, wh.watchPath, stats);

                _context11.next = 52;
                return regeneratorRuntime.awrap(this._handleDir(parent, stats, initialAdd, depth, path, wh, _targetPath));

              case 52:
                closer = _context11.sent;

                if (!this.fsw.closed) {
                  _context11.next = 55;
                  break;
                }

                return _context11.abrupt("return");

              case 55:
                // preserve this symlink's target path
                if (_targetPath !== undefined) {
                  this.fsw._symlinkPaths.set(sysPath.resolve(path), _targetPath);
                }

                _context11.next = 59;
                break;

              case 58:
                closer = this._handleFile(wh.watchPath, stats, initialAdd);

              case 59:
                ready();

                this.fsw._addPathCloser(path, closer);

                return _context11.abrupt("return", false);

              case 64:
                _context11.prev = 64;
                _context11.t2 = _context11["catch"](6);

                if (!this.fsw._handleError(_context11.t2)) {
                  _context11.next = 69;
                  break;
                }

                ready();
                return _context11.abrupt("return", path);

              case 69:
              case "end":
                return _context11.stop();
            }
          }
        }, null, this, [[6, 64]]);
      }
    }]);

    return NodeFsHandler;
  }();

  nodefsHandler = NodeFsHandler;
  return nodefsHandler;
}

var fseventsHandler = {
  exports: {}
};
var require$$3 =
/*@__PURE__*/
rollup.getAugmentedNamespace(fseventsImporter.fseventsImporter);
var hasRequiredFseventsHandler;

function requireFseventsHandler() {
  if (hasRequiredFseventsHandler) return fseventsHandler.exports;
  hasRequiredFseventsHandler = 1;
  var fs = require$$0$2;
  var sysPath = require$$0$1;
  var promisify = require$$2.promisify;
  var fsevents;

  try {
    fsevents = require$$3.getFsEvents();
  } catch (error) {
    if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);
  }

  if (fsevents) {
    // TODO: real check
    var mtch = process.version.match(/v(\d+)\.(\d+)/);

    if (mtch && mtch[1] && mtch[2]) {
      var maj = Number.parseInt(mtch[1], 10);
      var min = Number.parseInt(mtch[2], 10);

      if (maj === 8 && min < 16) {
        fsevents = undefined;
      }
    }
  }

  var _requireConstants2 =
  /*@__PURE__*/
  requireConstants(),
      EV_ADD = _requireConstants2.EV_ADD,
      EV_CHANGE = _requireConstants2.EV_CHANGE,
      EV_ADD_DIR = _requireConstants2.EV_ADD_DIR,
      EV_UNLINK = _requireConstants2.EV_UNLINK,
      EV_ERROR = _requireConstants2.EV_ERROR,
      STR_DATA = _requireConstants2.STR_DATA,
      STR_END = _requireConstants2.STR_END,
      FSEVENT_CREATED = _requireConstants2.FSEVENT_CREATED,
      FSEVENT_MODIFIED = _requireConstants2.FSEVENT_MODIFIED,
      FSEVENT_DELETED = _requireConstants2.FSEVENT_DELETED,
      FSEVENT_MOVED = _requireConstants2.FSEVENT_MOVED,
      FSEVENT_UNKNOWN = _requireConstants2.FSEVENT_UNKNOWN,
      FSEVENT_FLAG_MUST_SCAN_SUBDIRS = _requireConstants2.FSEVENT_FLAG_MUST_SCAN_SUBDIRS,
      FSEVENT_TYPE_FILE = _requireConstants2.FSEVENT_TYPE_FILE,
      FSEVENT_TYPE_DIRECTORY = _requireConstants2.FSEVENT_TYPE_DIRECTORY,
      FSEVENT_TYPE_SYMLINK = _requireConstants2.FSEVENT_TYPE_SYMLINK,
      ROOT_GLOBSTAR = _requireConstants2.ROOT_GLOBSTAR,
      DIR_SUFFIX = _requireConstants2.DIR_SUFFIX,
      DOT_SLASH = _requireConstants2.DOT_SLASH,
      FUNCTION_TYPE = _requireConstants2.FUNCTION_TYPE,
      EMPTY_FN = _requireConstants2.EMPTY_FN,
      IDENTITY_FN = _requireConstants2.IDENTITY_FN;

  var Depth = function Depth(value) {
    return isNaN(value) ? {} : {
      depth: value
    };
  };

  var stat = promisify(fs.stat);
  var lstat = promisify(fs.lstat);
  var realpath = promisify(fs.realpath);
  var statMethods = {
    stat: stat,
    lstat: lstat
  };
  /**
   * @typedef {String} Path
   */

  /**
   * @typedef {Object} FsEventsWatchContainer
   * @property {Set<Function>} listeners
   * @property {Function} rawEmitter
   * @property {{stop: Function}} watcher
   */
  // fsevents instance helper functions

  /**
   * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)
   * @type {Map<Path,FsEventsWatchContainer>}
   */

  var FSEventsWatchers = new Map(); // Threshold of duplicate path prefixes at which to start
  // consolidating going forward

  var consolidateThreshhold = 10;
  var wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);
  /**
   * Instantiates the fsevents interface
   * @param {Path} path path to be watched
   * @param {Function} callback called when fsevents is bound and ready
   * @returns {{stop: Function}} new fsevents instance
   */

  var createFSEventsInstance = function createFSEventsInstance(path, callback) {
    var stop = fsevents.watch(path, callback);
    return {
      stop: stop
    };
  };
  /**
   * Instantiates the fsevents interface or binds listeners to an existing one covering
   * the same file tree.
   * @param {Path} path           - to be watched
   * @param {Path} realPath       - real path for symlinks
   * @param {Function} listener   - called when fsevents emits events
   * @param {Function} rawEmitter - passes data to listeners of the 'raw' event
   * @returns {Function} closer
   */


  function setFSEventsListener(path, realPath, listener, rawEmitter) {
    var watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;
    var parentPath = sysPath.dirname(watchPath);
    var cont = FSEventsWatchers.get(watchPath); // If we've accumulated a substantial number of paths that
    // could have been consolidated by watching one directory
    // above the current one, create a watcher on the parent
    // path instead, so that we do consolidate going forward.

    if (couldConsolidate(parentPath)) {
      watchPath = parentPath;
    }

    var resolvedPath = sysPath.resolve(path);
    var hasSymlink = resolvedPath !== realPath;

    var filteredListener = function filteredListener(fullPath, flags, info) {
      if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
      if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);
    }; // check if there is already a watcher on a parent path
    // modifies `watchPath` to the parent path when it finds a match


    var watchedParent = false;
    var _iteratorNormalCompletion16 = true;
    var _didIteratorError16 = false;
    var _iteratorError16 = undefined;

    try {
      for (var _iterator16 = FSEventsWatchers.keys()[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
        var watchedPath = _step16.value;

        if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
          watchPath = watchedPath;
          cont = FSEventsWatchers.get(watchPath);
          watchedParent = true;
          break;
        }
      }
    } catch (err) {
      _didIteratorError16 = true;
      _iteratorError16 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
          _iterator16["return"]();
        }
      } finally {
        if (_didIteratorError16) {
          throw _iteratorError16;
        }
      }
    }

    if (cont || watchedParent) {
      cont.listeners.add(filteredListener);
    } else {
      cont = {
        listeners: new Set([filteredListener]),
        rawEmitter: rawEmitter,
        watcher: createFSEventsInstance(watchPath, function (fullPath, flags) {
          if (!cont.listeners.size) return;
          if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS) return;
          var info = fsevents.getInfo(fullPath, flags);
          cont.listeners.forEach(function (list) {
            list(fullPath, flags, info);
          });
          cont.rawEmitter(info.event, fullPath, info);
        })
      };
      FSEventsWatchers.set(watchPath, cont);
    } // removes this instance's listeners and closes the underlying fsevents
    // instance if there are no more listeners left


    return function () {
      var lst = cont.listeners;
      lst["delete"](filteredListener);

      if (!lst.size) {
        FSEventsWatchers["delete"](watchPath);
        if (cont.watcher) return cont.watcher.stop().then(function () {
          cont.rawEmitter = cont.watcher = undefined;
          Object.freeze(cont);
        });
      }
    };
  } // Decide whether or not we should start a new higher-level
  // parent watcher


  var couldConsolidate = function couldConsolidate(path) {
    var count = 0;
    var _iteratorNormalCompletion17 = true;
    var _didIteratorError17 = false;
    var _iteratorError17 = undefined;

    try {
      for (var _iterator17 = FSEventsWatchers.keys()[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
        var watchPath = _step17.value;

        if (watchPath.indexOf(path) === 0) {
          count++;

          if (count >= consolidateThreshhold) {
            return true;
          }
        }
      }
    } catch (err) {
      _didIteratorError17 = true;
      _iteratorError17 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
          _iterator17["return"]();
        }
      } finally {
        if (_didIteratorError17) {
          throw _iteratorError17;
        }
      }
    }

    return false;
  }; // returns boolean indicating whether fsevents can be used


  var canUse = function canUse() {
    return fsevents && FSEventsWatchers.size < 128;
  }; // determines subdirectory traversal levels from root to path


  var calcDepth = function calcDepth(path, root) {
    var i = 0;

    while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) {
      i++;
    }

    return i;
  }; // returns boolean indicating whether the fsevents' event info has the same type
  // as the one returned by fs.stat


  var sameTypes = function sameTypes(info, stats) {
    return info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
  };
  /**
   * @mixin
   */


  var FsEventsHandler =
  /*#__PURE__*/
  function () {
    /**
     * @param {import('../index').FSWatcher} fsw
     */
    function FsEventsHandler(fsw) {
      _classCallCheck(this, FsEventsHandler);

      this.fsw = fsw;
    }

    _createClass(FsEventsHandler, [{
      key: "checkIgnored",
      value: function checkIgnored(path, stats) {
        var ipaths = this.fsw._ignoredPaths;

        if (this.fsw._isIgnored(path, stats)) {
          ipaths.add(path);

          if (stats && stats.isDirectory()) {
            ipaths.add(path + ROOT_GLOBSTAR);
          }

          return true;
        }

        ipaths["delete"](path);
        ipaths["delete"](path + ROOT_GLOBSTAR);
      }
    }, {
      key: "addOrChange",
      value: function addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        var event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
        this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
    }, {
      key: "checkExists",
      value: function checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        var stats;
        return regeneratorRuntime.async(function checkExists$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.prev = 0;
                _context12.next = 3;
                return regeneratorRuntime.awrap(stat(path));

              case 3:
                stats = _context12.sent;

                if (!this.fsw.closed) {
                  _context12.next = 6;
                  break;
                }

                return _context12.abrupt("return");

              case 6:
                if (sameTypes(info, stats)) {
                  this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                } else {
                  this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
                }

                _context12.next = 12;
                break;

              case 9:
                _context12.prev = 9;
                _context12.t0 = _context12["catch"](0);

                if (_context12.t0.code === 'EACCES') {
                  this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                } else {
                  this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
                }

              case 12:
              case "end":
                return _context12.stop();
            }
          }
        }, null, this, [[0, 9]]);
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {
        if (this.fsw.closed || this.checkIgnored(path)) return;

        if (event === EV_UNLINK) {
          var isDirectory = info.type === FSEVENT_TYPE_DIRECTORY; // suppress unlink events on never before seen files

          if (isDirectory || watchedDir.has(item)) {
            this.fsw._remove(parent, item, isDirectory);
          }
        } else {
          if (event === EV_ADD) {
            // track new directories
            if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);

            if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
              // push symlinks back to the top of the stack to get handled
              var curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;
              return this._addToFsEvents(path, false, true, curDepth);
            } // track new paths
            // (other than symlinks being followed, which will be tracked soon)


            this.fsw._getWatchedDir(parent).add(item);
          }
          /**
           * @type {'add'|'addDir'|'unlink'|'unlinkDir'}
           */


          var eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;

          this.fsw._emit(eventName, path);

          if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);
        }
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} watchPath  - file/dir path to be watched with fsevents
       * @param {String} realPath   - real path (in case of symlinks)
       * @param {Function} transform  - path transformer
       * @param {Function} globFilter - path filter in case a glob pattern was provided
       * @returns {Function} closer for the watcher instance
      */

    }, {
      key: "_watchWithFsEvents",
      value: function _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
        var _this6 = this;

        if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
        var opts = this.fsw.options;

        var watchCallback = function watchCallback(fullPath, flags, info) {
          var path, parent, item, watchedDir, stats;
          return regeneratorRuntime.async(function watchCallback$(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  if (!_this6.fsw.closed) {
                    _context13.next = 2;
                    break;
                  }

                  return _context13.abrupt("return");

                case 2:
                  if (!(opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth)) {
                    _context13.next = 4;
                    break;
                  }

                  return _context13.abrupt("return");

                case 4:
                  path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));

                  if (!(globFilter && !globFilter(path))) {
                    _context13.next = 7;
                    break;
                  }

                  return _context13.abrupt("return");

                case 7:
                  // ensure directories are tracked
                  parent = sysPath.dirname(path);
                  item = sysPath.basename(path);
                  watchedDir = _this6.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent); // correct for wrong events emitted

                  if (!(wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN)) {
                    _context13.next = 30;
                    break;
                  }

                  if (!(_typeof(opts.ignored) === FUNCTION_TYPE)) {
                    _context13.next = 27;
                    break;
                  }

                  _context13.prev = 12;
                  _context13.next = 15;
                  return regeneratorRuntime.awrap(stat(path));

                case 15:
                  stats = _context13.sent;
                  _context13.next = 20;
                  break;

                case 18:
                  _context13.prev = 18;
                  _context13.t0 = _context13["catch"](12);

                case 20:
                  if (!_this6.fsw.closed) {
                    _context13.next = 22;
                    break;
                  }

                  return _context13.abrupt("return");

                case 22:
                  if (!_this6.checkIgnored(path, stats)) {
                    _context13.next = 24;
                    break;
                  }

                  return _context13.abrupt("return");

                case 24:
                  if (sameTypes(info, stats)) {
                    _this6.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                  } else {
                    _this6.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);
                  }

                  _context13.next = 28;
                  break;

                case 27:
                  _this6.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);

                case 28:
                  _context13.next = 35;
                  break;

                case 30:
                  _context13.t1 = info.event;
                  _context13.next = _context13.t1 === FSEVENT_CREATED ? 33 : _context13.t1 === FSEVENT_MODIFIED ? 33 : _context13.t1 === FSEVENT_DELETED ? 34 : _context13.t1 === FSEVENT_MOVED ? 34 : 35;
                  break;

                case 33:
                  return _context13.abrupt("return", _this6.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts));

                case 34:
                  return _context13.abrupt("return", _this6.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts));

                case 35:
                case "end":
                  return _context13.stop();
              }
            }
          }, null, null, [[12, 18]]);
        };

        var closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);

        this.fsw._emitReady();

        return closer;
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} linkPath path to symlink
       * @param {String} fullPath absolute path to the symlink
       * @param {Function} transform pre-existing path transformer
       * @param {Number} curDepth level of subdirectories traversed to where symlink is
       * @returns {Promise<void>}
       */

    }, {
      key: "_handleFsEventsSymlink",
      value: function _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
        var linkTarget;
        return regeneratorRuntime.async(function _handleFsEventsSymlink$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                if (!(this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))) {
                  _context14.next = 2;
                  break;
                }

                return _context14.abrupt("return");

              case 2:
                this.fsw._symlinkPaths.set(fullPath, true);

                this.fsw._incrReadyCount();

                _context14.prev = 4;
                _context14.next = 7;
                return regeneratorRuntime.awrap(realpath(linkPath));

              case 7:
                linkTarget = _context14.sent;

                if (!this.fsw.closed) {
                  _context14.next = 10;
                  break;
                }

                return _context14.abrupt("return");

              case 10:
                if (!this.fsw._isIgnored(linkTarget)) {
                  _context14.next = 12;
                  break;
                }

                return _context14.abrupt("return", this.fsw._emitReady());

              case 12:
                this.fsw._incrReadyCount(); // add the linkTarget for watching with a wrapper for transform
                // that causes emitted paths to incorporate the link's path


                this._addToFsEvents(linkTarget || linkPath, function (path) {
                  var aliasedPath = linkPath;

                  if (linkTarget && linkTarget !== DOT_SLASH) {
                    aliasedPath = path.replace(linkTarget, linkPath);
                  } else if (path !== DOT_SLASH) {
                    aliasedPath = sysPath.join(linkPath, path);
                  }

                  return transform(aliasedPath);
                }, false, curDepth);

                _context14.next = 20;
                break;

              case 16:
                _context14.prev = 16;
                _context14.t0 = _context14["catch"](4);

                if (!this.fsw._handleError(_context14.t0)) {
                  _context14.next = 20;
                  break;
                }

                return _context14.abrupt("return", this.fsw._emitReady());

              case 20:
              case "end":
                return _context14.stop();
            }
          }
        }, null, this, [[4, 16]]);
      }
      /**
       *
       * @param {Path} newPath
       * @param {fs.Stats} stats
       */

    }, {
      key: "emitAdd",
      value: function emitAdd(newPath, stats, processPath, opts, forceAdd) {
        var pp = processPath(newPath);
        var isDir = stats.isDirectory();

        var dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));

        var base = sysPath.basename(pp); // ensure empty dirs get tracked

        if (isDir) this.fsw._getWatchedDir(pp);
        if (dirObj.has(base)) return;
        dirObj.add(base);

        if (!opts.ignoreInitial || forceAdd === true) {
          this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);
        }
      }
    }, {
      key: "initWatch",
      value: function initWatch(realPath, path, wh, processPath) {
        if (this.fsw.closed) return;

        var closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);

        this.fsw._addPathCloser(path, closer);
      }
      /**
       * Handle added path with fsevents
       * @param {String} path file/dir path or glob pattern
       * @param {Function|Boolean=} transform converts working path to what the user expects
       * @param {Boolean=} forceAdd ensure add is emitted
       * @param {Number=} priorDepth Level of subdirectories already traversed.
       * @returns {Promise<void>}
       */

    }, {
      key: "_addToFsEvents",
      value: function _addToFsEvents(path, transform, forceAdd, priorDepth) {
        var _this7 = this;

        var opts, processPath, wh, stats, realPath;
        return regeneratorRuntime.async(function _addToFsEvents$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                if (!this.fsw.closed) {
                  _context15.next = 2;
                  break;
                }

                return _context15.abrupt("return");

              case 2:
                opts = this.fsw.options;
                processPath = _typeof(transform) === FUNCTION_TYPE ? transform : IDENTITY_FN;
                wh = this.fsw._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch

                _context15.prev = 5;
                _context15.next = 8;
                return regeneratorRuntime.awrap(statMethods[wh.statMethod](wh.watchPath));

              case 8:
                stats = _context15.sent;

                if (!this.fsw.closed) {
                  _context15.next = 11;
                  break;
                }

                return _context15.abrupt("return");

              case 11:
                if (!this.fsw._isIgnored(wh.watchPath, stats)) {
                  _context15.next = 13;
                  break;
                }

                throw null;

              case 13:
                if (!stats.isDirectory()) {
                  _context15.next = 20;
                  break;
                }

                // emit addDir unless this is a glob parent
                if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd); // don't recurse further if it would exceed depth setting

                if (!(priorDepth && priorDepth > opts.depth)) {
                  _context15.next = 17;
                  break;
                }

                return _context15.abrupt("return");

              case 17:
                // scan the contents of the dir
                this.fsw._readdirp(wh.watchPath, _objectSpread({
                  fileFilter: function fileFilter(entry) {
                    return wh.filterPath(entry);
                  },
                  directoryFilter: function directoryFilter(entry) {
                    return wh.filterDir(entry);
                  }
                }, Depth(opts.depth - (priorDepth || 0)))).on(STR_DATA, function (entry) {
                  // need to check filterPath on dirs b/c filterDir is less restrictive
                  if (_this7.fsw.closed) {
                    return;
                  }

                  if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;
                  var joinedPath = sysPath.join(wh.watchPath, entry.path);
                  var fullPath = entry.fullPath;

                  if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                    // preserve the current depth here since it can't be derived from
                    // real paths past the symlink
                    var curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;

                    _this7._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
                  } else {
                    _this7.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
                  }
                }).on(EV_ERROR, EMPTY_FN).on(STR_END, function () {
                  _this7.fsw._emitReady();
                });

                _context15.next = 22;
                break;

              case 20:
                this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);

                this.fsw._emitReady();

              case 22:
                _context15.next = 27;
                break;

              case 24:
                _context15.prev = 24;
                _context15.t0 = _context15["catch"](5);

                if (!_context15.t0 || this.fsw._handleError(_context15.t0)) {
                  // TODO: Strange thing: "should not choke on an ignored watch path" will be failed without 2 ready calls -__-
                  this.fsw._emitReady();

                  this.fsw._emitReady();
                }

              case 27:
                if (!(opts.persistent && forceAdd !== true)) {
                  _context15.next = 41;
                  break;
                }

                if (!(_typeof(transform) === FUNCTION_TYPE)) {
                  _context15.next = 32;
                  break;
                }

                // realpath has already been resolved
                this.initWatch(undefined, path, wh, processPath);
                _context15.next = 41;
                break;

              case 32:
                _context15.prev = 32;
                _context15.next = 35;
                return regeneratorRuntime.awrap(realpath(wh.watchPath));

              case 35:
                realPath = _context15.sent;
                _context15.next = 40;
                break;

              case 38:
                _context15.prev = 38;
                _context15.t1 = _context15["catch"](32);

              case 40:
                this.initWatch(realPath, path, wh, processPath);

              case 41:
              case "end":
                return _context15.stop();
            }
          }
        }, null, this, [[5, 24], [32, 38]]);
      }
    }]);

    return FsEventsHandler;
  }();

  fseventsHandler.exports = FsEventsHandler;
  fseventsHandler.exports.canUse = canUse;
  return fseventsHandler.exports;
}

var hasRequiredChokidar;

function requireChokidar() {
  if (hasRequiredChokidar) return chokidar$1;
  hasRequiredChokidar = 1;
  var EventEmitter = require$$0$3.EventEmitter;
  var fs = require$$0$2;
  var sysPath = require$$0$1;
  var promisify = require$$2.promisify;
  var readdirp =
  /*@__PURE__*/
  requireReaddirp();
  var anymatch =
  /*@__PURE__*/
  requireAnymatch()["default"];
  var globParent =
  /*@__PURE__*/
  requireGlobParent();
  var isGlob =
  /*@__PURE__*/
  requireIsGlob();
  var braces =
  /*@__PURE__*/
  requireBraces();
  var normalizePath =
  /*@__PURE__*/
  requireNormalizePath();
  var NodeFsHandler =
  /*@__PURE__*/
  requireNodefsHandler();
  var FsEventsHandler =
  /*@__PURE__*/
  requireFseventsHandler();

  var _requireConstants3 =
  /*@__PURE__*/
  requireConstants(),
      EV_ALL = _requireConstants3.EV_ALL,
      EV_READY = _requireConstants3.EV_READY,
      EV_ADD = _requireConstants3.EV_ADD,
      EV_CHANGE = _requireConstants3.EV_CHANGE,
      EV_UNLINK = _requireConstants3.EV_UNLINK,
      EV_ADD_DIR = _requireConstants3.EV_ADD_DIR,
      EV_UNLINK_DIR = _requireConstants3.EV_UNLINK_DIR,
      EV_RAW = _requireConstants3.EV_RAW,
      EV_ERROR = _requireConstants3.EV_ERROR,
      STR_CLOSE = _requireConstants3.STR_CLOSE,
      STR_END = _requireConstants3.STR_END,
      BACK_SLASH_RE = _requireConstants3.BACK_SLASH_RE,
      DOUBLE_SLASH_RE = _requireConstants3.DOUBLE_SLASH_RE,
      SLASH_OR_BACK_SLASH_RE = _requireConstants3.SLASH_OR_BACK_SLASH_RE,
      DOT_RE = _requireConstants3.DOT_RE,
      REPLACER_RE = _requireConstants3.REPLACER_RE,
      SLASH = _requireConstants3.SLASH,
      SLASH_SLASH = _requireConstants3.SLASH_SLASH,
      BRACE_START = _requireConstants3.BRACE_START,
      BANG = _requireConstants3.BANG,
      ONE_DOT = _requireConstants3.ONE_DOT,
      TWO_DOTS = _requireConstants3.TWO_DOTS,
      GLOBSTAR = _requireConstants3.GLOBSTAR,
      SLASH_GLOBSTAR = _requireConstants3.SLASH_GLOBSTAR,
      ANYMATCH_OPTS = _requireConstants3.ANYMATCH_OPTS,
      STRING_TYPE = _requireConstants3.STRING_TYPE,
      FUNCTION_TYPE = _requireConstants3.FUNCTION_TYPE,
      EMPTY_STR = _requireConstants3.EMPTY_STR,
      EMPTY_FN = _requireConstants3.EMPTY_FN,
      isWindows = _requireConstants3.isWindows,
      isMacos = _requireConstants3.isMacos,
      isIBMi = _requireConstants3.isIBMi;

  var stat = promisify(fs.stat);
  var readdir = promisify(fs.readdir);
  /**
   * @typedef {String} Path
   * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName
   * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType
   */

  /**
   *
   * @typedef {Object} WatchHelpers
   * @property {Boolean} followSymlinks
   * @property {'stat'|'lstat'} statMethod
   * @property {Path} path
   * @property {Path} watchPath
   * @property {Function} entryPath
   * @property {Boolean} hasGlob
   * @property {Object} globFilter
   * @property {Function} filterPath
   * @property {Function} filterDir
   */

  var arrify = function arrify() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return Array.isArray(value) ? value : [value];
  };

  var flatten = function flatten(list) {
    var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    list.forEach(function (item) {
      if (Array.isArray(item)) {
        flatten(item, result);
      } else {
        result.push(item);
      }
    });
    return result;
  };

  var unifyPaths = function unifyPaths(paths_) {
    /**
     * @type {Array<String>}
     */
    var paths = flatten(arrify(paths_));

    if (!paths.every(function (p) {
      return _typeof(p) === STRING_TYPE;
    })) {
      throw new TypeError("Non-string provided as watch path: ".concat(paths));
    }

    return paths.map(normalizePathToUnix);
  }; // If SLASH_SLASH occurs at the beginning of path, it is not replaced
  //     because "//StoragePC/DrivePool/Movies" is a valid network path


  var toUnix = function toUnix(string) {
    var str = string.replace(BACK_SLASH_RE, SLASH);
    var prepend = false;

    if (str.startsWith(SLASH_SLASH)) {
      prepend = true;
    }

    while (str.match(DOUBLE_SLASH_RE)) {
      str = str.replace(DOUBLE_SLASH_RE, SLASH);
    }

    if (prepend) {
      str = SLASH + str;
    }

    return str;
  }; // Our version of upath.normalize
  // TODO: this is not equal to path-normalize module - investigate why


  var normalizePathToUnix = function normalizePathToUnix(path) {
    return toUnix(sysPath.normalize(toUnix(path)));
  };

  var normalizeIgnored = function normalizeIgnored() {
    var cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_STR;
    return function (path) {
      if (_typeof(path) !== STRING_TYPE) return path;
      return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));
    };
  };

  var getAbsolutePath = function getAbsolutePath(path, cwd) {
    if (sysPath.isAbsolute(path)) {
      return path;
    }

    if (path.startsWith(BANG)) {
      return BANG + sysPath.join(cwd, path.slice(1));
    }

    return sysPath.join(cwd, path);
  };

  var undef = function undef(opts, key) {
    return opts[key] === undefined;
  };
  /**
   * Directory entry.
   * @property {Path} path
   * @property {Set<Path>} items
   */


  var DirEntry =
  /*#__PURE__*/
  function () {
    /**
     * @param {Path} dir
     * @param {Function} removeWatcher
     */
    function DirEntry(dir, removeWatcher) {
      _classCallCheck(this, DirEntry);

      this.path = dir;
      this._removeWatcher = removeWatcher;
      /** @type {Set<Path>} */

      this.items = new Set();
    }

    _createClass(DirEntry, [{
      key: "add",
      value: function add(item) {
        var items = this.items;
        if (!items) return;
        if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
      }
    }, {
      key: "remove",
      value: function remove(item) {
        var items, dir;
        return regeneratorRuntime.async(function remove$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                items = this.items;

                if (items) {
                  _context16.next = 3;
                  break;
                }

                return _context16.abrupt("return");

              case 3:
                items["delete"](item);

                if (!(items.size > 0)) {
                  _context16.next = 6;
                  break;
                }

                return _context16.abrupt("return");

              case 6:
                dir = this.path;
                _context16.prev = 7;
                _context16.next = 10;
                return regeneratorRuntime.awrap(readdir(dir));

              case 10:
                _context16.next = 15;
                break;

              case 12:
                _context16.prev = 12;
                _context16.t0 = _context16["catch"](7);

                if (this._removeWatcher) {
                  this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
                }

              case 15:
              case "end":
                return _context16.stop();
            }
          }
        }, null, this, [[7, 12]]);
      }
    }, {
      key: "has",
      value: function has(item) {
        var items = this.items;
        if (!items) return;
        return items.has(item);
      }
      /**
       * @returns {Array<String>}
       */

    }, {
      key: "getChildren",
      value: function getChildren() {
        var items = this.items;
        if (!items) return;
        return _toConsumableArray(items.values());
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.items.clear();
        delete this.path;
        delete this._removeWatcher;
        delete this.items;
        Object.freeze(this);
      }
    }]);

    return DirEntry;
  }();

  var STAT_METHOD_F = 'stat';
  var STAT_METHOD_L = 'lstat';

  var WatchHelper =
  /*#__PURE__*/
  function () {
    function WatchHelper(path, watchPath, follow, fsw) {
      _classCallCheck(this, WatchHelper);

      this.fsw = fsw;
      this.path = path = path.replace(REPLACER_RE, EMPTY_STR);
      this.watchPath = watchPath;
      this.fullWatchPath = sysPath.resolve(watchPath);
      this.hasGlob = watchPath !== path;
      /** @type {object|boolean} */

      if (path === EMPTY_STR) this.hasGlob = false;
      this.globSymlink = this.hasGlob && follow ? undefined : false;
      this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;
      this.dirParts = this.getDirParts(path);
      this.dirParts.forEach(function (parts) {
        if (parts.length > 1) parts.pop();
      });
      this.followSymlinks = follow;
      this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
    }

    _createClass(WatchHelper, [{
      key: "checkGlobSymlink",
      value: function checkGlobSymlink(entry) {
        // only need to resolve once
        // first entry should always have entry.parentDir === EMPTY_STR
        if (this.globSymlink === undefined) {
          this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {
            realPath: entry.fullParentDir,
            linkPath: this.fullWatchPath
          };
        }

        if (this.globSymlink) {
          return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
        }

        return entry.fullPath;
      }
    }, {
      key: "entryPath",
      value: function entryPath(entry) {
        return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));
      }
    }, {
      key: "filterPath",
      value: function filterPath(entry) {
        var stats = entry.stats;
        if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
        var resolvedPath = this.entryPath(entry);
        var matchesGlob = this.hasGlob && _typeof(this.globFilter) === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
        return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
    }, {
      key: "getDirParts",
      value: function getDirParts(path) {
        var _this8 = this;

        if (!this.hasGlob) return [];
        var parts = [];
        var expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];
        expandedPath.forEach(function (path) {
          parts.push(sysPath.relative(_this8.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));
        });
        return parts;
      }
    }, {
      key: "filterDir",
      value: function filterDir(entry) {
        if (this.hasGlob) {
          var entryParts = this.getDirParts(this.checkGlobSymlink(entry));
          var globstar = false;
          this.unmatchedGlob = !this.dirParts.some(function (parts) {
            return parts.every(function (part, i) {
              if (part === GLOBSTAR) globstar = true;
              return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
            });
          });
        }

        return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
      }
    }]);

    return WatchHelper;
  }();
  /**
   * Watches files & directories for changes. Emitted events:
   * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
   *
   *     new FSWatcher()
   *       .add(directories)
   *       .on('add', path => log('File', path, 'was added'))
   */


  var FSWatcher =
  /*#__PURE__*/
  function (_EventEmitter) {
    _inherits(FSWatcher, _EventEmitter);

    // Not indenting methods for history sake; for now.
    function FSWatcher(_opts) {
      var _this9;

      _classCallCheck(this, FSWatcher);

      _this9 = _possibleConstructorReturn(this, _getPrototypeOf(FSWatcher).call(this));
      var opts = {};
      if (_opts) Object.assign(opts, _opts); // for frozen objects

      /** @type {Map<String, DirEntry>} */

      _this9._watched = new Map();
      /** @type {Map<String, Array>} */

      _this9._closers = new Map();
      /** @type {Set<String>} */

      _this9._ignoredPaths = new Set();
      /** @type {Map<ThrottleType, Map>} */

      _this9._throttled = new Map();
      /** @type {Map<Path, String|Boolean>} */

      _this9._symlinkPaths = new Map();
      _this9._streams = new Set();
      _this9.closed = false; // Set up default options.

      if (undef(opts, 'persistent')) opts.persistent = true;
      if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;
      if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;
      if (undef(opts, 'interval')) opts.interval = 100;
      if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;
      if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;
      opts.enableBinaryInterval = opts.binaryInterval !== opts.interval; // Enable fsevents on OS X when polling isn't explicitly enabled.

      if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling; // If we can't use fsevents, ensure the options reflect it's disabled.

      var canUseFsEvents = FsEventsHandler.canUse();
      if (!canUseFsEvents) opts.useFsEvents = false; // Use polling on Mac if not using fsevents.
      // Other platforms use non-polling fs_watch.

      if (undef(opts, 'usePolling') && !opts.useFsEvents) {
        opts.usePolling = isMacos;
      } // Always default to polling on IBM i because fs.watch() is not available on IBM i.


      if (isIBMi) {
        opts.usePolling = true;
      } // Global override (useful for end-developers that need to force polling for all
      // instances of chokidar, regardless of usage/dependency depth)


      var envPoll = process.env.CHOKIDAR_USEPOLLING;

      if (envPoll !== undefined) {
        var envLower = envPoll.toLowerCase();

        if (envLower === 'false' || envLower === '0') {
          opts.usePolling = false;
        } else if (envLower === 'true' || envLower === '1') {
          opts.usePolling = true;
        } else {
          opts.usePolling = !!envLower;
        }
      }

      var envInterval = process.env.CHOKIDAR_INTERVAL;

      if (envInterval) {
        opts.interval = Number.parseInt(envInterval, 10);
      } // Editor atomic write normalization enabled by default with fs.watch


      if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
      if (opts.atomic) _this9._pendingUnlinks = new Map();
      if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;
      if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;
      if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
      var awf = opts.awaitWriteFinish;

      if (awf) {
        if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
        if (!awf.pollInterval) awf.pollInterval = 100;
        _this9._pendingWrites = new Map();
      }

      if (opts.ignored) opts.ignored = arrify(opts.ignored);
      var readyCalls = 0;

      _this9._emitReady = function () {
        readyCalls++;

        if (readyCalls >= _this9._readyCount) {
          _this9._emitReady = EMPTY_FN;
          _this9._readyEmitted = true; // use process.nextTick to allow time for listener to be bound

          process.nextTick(function () {
            return _this9.emit(EV_READY);
          });
        }
      };

      _this9._emitRaw = function () {
        var _this10;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return (_this10 = _this9).emit.apply(_this10, [EV_RAW].concat(args));
      };

      _this9._readyEmitted = false;
      _this9.options = opts; // Initialize with proper watcher.

      if (opts.useFsEvents) {
        _this9._fsEventsHandler = new FsEventsHandler(_assertThisInitialized(_this9));
      } else {
        _this9._nodeFsHandler = new NodeFsHandler(_assertThisInitialized(_this9));
      } // You’re frozen when your heart’s not open.


      Object.freeze(opts);
      return _this9;
    } // Public methods

    /**
     * Adds paths to be watched on an existing FSWatcher instance
     * @param {Path|Array<Path>} paths_
     * @param {String=} _origAdd private; for handling non-existent paths to be watched
     * @param {Boolean=} _internal private; indicates a non-user add
     * @returns {FSWatcher} for chaining
     */


    _createClass(FSWatcher, [{
      key: "add",
      value: function add(paths_, _origAdd, _internal) {
        var _this11 = this;

        var _this$options = this.options,
            cwd = _this$options.cwd,
            disableGlobbing = _this$options.disableGlobbing;
        this.closed = false;
        var paths = unifyPaths(paths_);

        if (cwd) {
          paths = paths.map(function (path) {
            var absPath = getAbsolutePath(path, cwd); // Check `path` instead of `absPath` because the cwd portion can't be a glob

            if (disableGlobbing || !isGlob(path)) {
              return absPath;
            }

            return normalizePath(absPath);
          });
        } // set aside negated glob strings


        paths = paths.filter(function (path) {
          if (path.startsWith(BANG)) {
            _this11._ignoredPaths.add(path.slice(1));

            return false;
          } // if a path is being added that was previously ignored, stop ignoring it


          _this11._ignoredPaths["delete"](path);

          _this11._ignoredPaths["delete"](path + SLASH_GLOBSTAR); // reset the cached userIgnored anymatch fn
          // to make ignoredPaths changes effective


          _this11._userIgnored = undefined;
          return true;
        });

        if (this.options.useFsEvents && this._fsEventsHandler) {
          if (!this._readyCount) this._readyCount = paths.length;
          if (this.options.persistent) this._readyCount += paths.length;
          paths.forEach(function (path) {
            return _this11._fsEventsHandler._addToFsEvents(path);
          });
        } else {
          if (!this._readyCount) this._readyCount = 0;
          this._readyCount += paths.length;
          Promise.all(paths.map(function _callee3(path) {
            var res;
            return regeneratorRuntime.async(function _callee3$(_context17) {
              while (1) {
                switch (_context17.prev = _context17.next) {
                  case 0:
                    _context17.next = 2;
                    return regeneratorRuntime.awrap(_this11._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd));

                  case 2:
                    res = _context17.sent;
                    if (res) _this11._emitReady();
                    return _context17.abrupt("return", res);

                  case 5:
                  case "end":
                    return _context17.stop();
                }
              }
            });
          })).then(function (results) {
            if (_this11.closed) return;
            results.filter(function (item) {
              return item;
            }).forEach(function (item) {
              _this11.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
            });
          });
        }

        return this;
      }
      /**
       * Close watchers or start ignoring events from specified paths.
       * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
       * @returns {FSWatcher} for chaining
      */

    }, {
      key: "unwatch",
      value: function unwatch(paths_) {
        var _this12 = this;

        if (this.closed) return this;
        var paths = unifyPaths(paths_);
        var cwd = this.options.cwd;
        paths.forEach(function (path) {
          // convert to absolute path unless relative path already matches
          if (!sysPath.isAbsolute(path) && !_this12._closers.has(path)) {
            if (cwd) path = sysPath.join(cwd, path);
            path = sysPath.resolve(path);
          }

          _this12._closePath(path);

          _this12._ignoredPaths.add(path);

          if (_this12._watched.has(path)) {
            _this12._ignoredPaths.add(path + SLASH_GLOBSTAR);
          } // reset the cached userIgnored anymatch fn
          // to make ignoredPaths changes effective


          _this12._userIgnored = undefined;
        });
        return this;
      }
      /**
       * Close watchers and remove all listeners from watched paths.
       * @returns {Promise<void>}.
      */

    }, {
      key: "close",
      value: function close() {
        var _this13 = this;

        if (this.closed) return this._closePromise;
        this.closed = true; // Memory management.

        this.removeAllListeners();
        var closers = [];

        this._closers.forEach(function (closerList) {
          return closerList.forEach(function (closer) {
            var promise = closer();
            if (promise instanceof Promise) closers.push(promise);
          });
        });

        this._streams.forEach(function (stream) {
          return stream.destroy();
        });

        this._userIgnored = undefined;
        this._readyCount = 0;
        this._readyEmitted = false;

        this._watched.forEach(function (dirent) {
          return dirent.dispose();
        });

        ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(function (key) {
          _this13["_".concat(key)].clear();
        });
        this._closePromise = closers.length ? Promise.all(closers).then(function () {
          return undefined;
        }) : Promise.resolve();
        return this._closePromise;
      }
      /**
       * Expose list of watched paths
       * @returns {Object} for chaining
      */

    }, {
      key: "getWatched",
      value: function getWatched() {
        var _this14 = this;

        var watchList = {};

        this._watched.forEach(function (entry, dir) {
          var key = _this14.options.cwd ? sysPath.relative(_this14.options.cwd, dir) : dir;
          watchList[key || ONE_DOT] = entry.getChildren().sort();
        });

        return watchList;
      }
    }, {
      key: "emitWithAll",
      value: function emitWithAll(event, args) {
        this.emit.apply(this, _toConsumableArray(args));
        if (event !== EV_ERROR) this.emit.apply(this, [EV_ALL].concat(_toConsumableArray(args)));
      } // Common helpers
      // --------------

      /**
       * Normalize and emit events.
       * Calling _emit DOES NOT MEAN emit() would be called!
       * @param {EventName} event Type of event
       * @param {Path} path File or directory path
       * @param {*=} val1 arguments to be passed with event
       * @param {*=} val2
       * @param {*=} val3
       * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */

    }, {
      key: "_emit",
      value: function _emit(event, path, val1, val2, val3) {
        var _this15 = this;

        var opts, args, awf, pw, awfEmit, isThrottled, fullPath, stats;
        return regeneratorRuntime.async(function _emit$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                if (!this.closed) {
                  _context18.next = 2;
                  break;
                }

                return _context18.abrupt("return");

              case 2:
                opts = this.options;
                if (isWindows) path = sysPath.normalize(path);
                if (opts.cwd) path = sysPath.relative(opts.cwd, path);
                /** @type Array<any> */

                args = [event, path];
                if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);
                awf = opts.awaitWriteFinish;

                if (!(awf && (pw = this._pendingWrites.get(path)))) {
                  _context18.next = 11;
                  break;
                }

                pw.lastChange = new Date();
                return _context18.abrupt("return", this);

              case 11:
                if (!opts.atomic) {
                  _context18.next = 17;
                  break;
                }

                if (!(event === EV_UNLINK)) {
                  _context18.next = 16;
                  break;
                }

                this._pendingUnlinks.set(path, args);

                setTimeout(function () {
                  _this15._pendingUnlinks.forEach(function (entry, path) {
                    _this15.emit.apply(_this15, _toConsumableArray(entry));

                    _this15.emit.apply(_this15, [EV_ALL].concat(_toConsumableArray(entry)));

                    _this15._pendingUnlinks["delete"](path);
                  });
                }, typeof opts.atomic === 'number' ? opts.atomic : 100);
                return _context18.abrupt("return", this);

              case 16:
                if (event === EV_ADD && this._pendingUnlinks.has(path)) {
                  event = args[0] = EV_CHANGE;

                  this._pendingUnlinks["delete"](path);
                }

              case 17:
                if (!(awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted)) {
                  _context18.next = 21;
                  break;
                }

                awfEmit = function awfEmit(err, stats) {
                  if (err) {
                    event = args[0] = EV_ERROR;
                    args[1] = err;

                    _this15.emitWithAll(event, args);
                  } else if (stats) {
                    // if stats doesn't exist the file must have been deleted
                    if (args.length > 2) {
                      args[2] = stats;
                    } else {
                      args.push(stats);
                    }

                    _this15.emitWithAll(event, args);
                  }
                };

                this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);

                return _context18.abrupt("return", this);

              case 21:
                if (!(event === EV_CHANGE)) {
                  _context18.next = 25;
                  break;
                }

                isThrottled = !this._throttle(EV_CHANGE, path, 50);

                if (!isThrottled) {
                  _context18.next = 25;
                  break;
                }

                return _context18.abrupt("return", this);

              case 25:
                if (!(opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE))) {
                  _context18.next = 38;
                  break;
                }

                fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
                _context18.prev = 27;
                _context18.next = 30;
                return regeneratorRuntime.awrap(stat(fullPath));

              case 30:
                stats = _context18.sent;
                _context18.next = 35;
                break;

              case 33:
                _context18.prev = 33;
                _context18.t0 = _context18["catch"](27);

              case 35:
                if (!(!stats || this.closed)) {
                  _context18.next = 37;
                  break;
                }

                return _context18.abrupt("return");

              case 37:
                args.push(stats);

              case 38:
                this.emitWithAll(event, args);
                return _context18.abrupt("return", this);

              case 40:
              case "end":
                return _context18.stop();
            }
          }
        }, null, this, [[27, 33]]);
      }
      /**
       * Common handler for errors
       * @param {Error} error
       * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */

    }, {
      key: "_handleError",
      value: function _handleError(error) {
        var code = error && error.code;

        if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {
          this.emit(EV_ERROR, error);
        }

        return error || this.closed;
      }
      /**
       * Helper utility for throttling
       * @param {ThrottleType} actionType type being throttled
       * @param {Path} path being acted upon
       * @param {Number} timeout duration of time to suppress duplicate actions
       * @returns {Object|false} tracking object or false if action should be suppressed
       */

    }, {
      key: "_throttle",
      value: function _throttle(actionType, path, timeout) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, new Map());
        }
        /** @type {Map<Path, Object>} */


        var action = this._throttled.get(actionType);
        /** @type {Object} */


        var actionPath = action.get(path);

        if (actionPath) {
          actionPath.count++;
          return false;
        }

        var timeoutObject;

        var clear = function clear() {
          var item = action.get(path);
          var count = item ? item.count : 0;
          action["delete"](path);
          clearTimeout(timeoutObject);
          if (item) clearTimeout(item.timeoutObject);
          return count;
        };

        timeoutObject = setTimeout(clear, timeout);
        var thr = {
          timeoutObject: timeoutObject,
          clear: clear,
          count: 0
        };
        action.set(path, thr);
        return thr;
      }
    }, {
      key: "_incrReadyCount",
      value: function _incrReadyCount() {
        return this._readyCount++;
      }
      /**
       * Awaits write operation to finish.
       * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
       * @param {Path} path being acted upon
       * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
       * @param {EventName} event
       * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
       */

    }, {
      key: "_awaitWriteFinish",
      value: function _awaitWriteFinish(path, threshold, event, awfEmit) {
        var _this16 = this;

        var timeoutHandler;
        var fullPath = path;

        if (this.options.cwd && !sysPath.isAbsolute(path)) {
          fullPath = sysPath.join(this.options.cwd, path);
        }

        var now = new Date();

        var awaitWriteFinish = function awaitWriteFinish(prevStat) {
          fs.stat(fullPath, function (err, curStat) {
            if (err || !_this16._pendingWrites.has(path)) {
              if (err && err.code !== 'ENOENT') awfEmit(err);
              return;
            }

            var now = Number(new Date());

            if (prevStat && curStat.size !== prevStat.size) {
              _this16._pendingWrites.get(path).lastChange = now;
            }

            var pw = _this16._pendingWrites.get(path);

            var df = now - pw.lastChange;

            if (df >= threshold) {
              _this16._pendingWrites["delete"](path);

              awfEmit(undefined, curStat);
            } else {
              timeoutHandler = setTimeout(awaitWriteFinish, _this16.options.awaitWriteFinish.pollInterval, curStat);
            }
          });
        };

        if (!this._pendingWrites.has(path)) {
          this._pendingWrites.set(path, {
            lastChange: now,
            cancelWait: function cancelWait() {
              _this16._pendingWrites["delete"](path);

              clearTimeout(timeoutHandler);
              return event;
            }
          });

          timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);
        }
      }
    }, {
      key: "_getGlobIgnored",
      value: function _getGlobIgnored() {
        return _toConsumableArray(this._ignoredPaths.values());
      }
      /**
       * Determines whether user has asked to ignore this path.
       * @param {Path} path filepath or dir
       * @param {fs.Stats=} stats result of fs.stat
       * @returns {Boolean}
       */

    }, {
      key: "_isIgnored",
      value: function _isIgnored(path, stats) {
        if (this.options.atomic && DOT_RE.test(path)) return true;

        if (!this._userIgnored) {
          var cwd = this.options.cwd;
          var ign = this.options.ignored;
          var ignored = ign && ign.map(normalizeIgnored(cwd));
          var paths = arrify(ignored).filter(function (path) {
            return _typeof(path) === STRING_TYPE && !isGlob(path);
          }).map(function (path) {
            return path + SLASH_GLOBSTAR;
          });

          var list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);

          this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);
        }

        return this._userIgnored([path, stats]);
      }
    }, {
      key: "_isntIgnored",
      value: function _isntIgnored(path, stat) {
        return !this._isIgnored(path, stat);
      }
      /**
       * Provides a set of common helpers and properties relating to symlink and glob handling.
       * @param {Path} path file, directory, or glob pattern being watched
       * @param {Number=} depth at any depth > 0, this isn't a glob
       * @returns {WatchHelper} object containing helpers for this path
       */

    }, {
      key: "_getWatchHelpers",
      value: function _getWatchHelpers(path, depth) {
        var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
        var follow = this.options.followSymlinks;
        return new WatchHelper(path, watchPath, follow, this);
      } // Directory helpers
      // -----------------

      /**
       * Provides directory tracking objects
       * @param {String} directory path of the directory
       * @returns {DirEntry} the directory's tracking object
       */

    }, {
      key: "_getWatchedDir",
      value: function _getWatchedDir(directory) {
        if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
        var dir = sysPath.resolve(directory);
        if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
      } // File helpers
      // ------------

      /**
       * Check for read permissions.
       * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
       * @param {fs.Stats} stats - object, result of fs_stat
       * @returns {Boolean} indicates whether the file can be read
      */

    }, {
      key: "_hasReadPermissions",
      value: function _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors) return true; // stats.mode may be bigint

        var md = stats && Number.parseInt(stats.mode, 10);
        var st = md & 511;
        var it = Number.parseInt(st.toString(8)[0], 10);
        return Boolean(4 & it);
      }
      /**
       * Handles emitting unlink events for
       * files and directories, and via recursion, for
       * files and directories within directories that are unlinked
       * @param {String} directory within which the following item is located
       * @param {String} item      base path of item/directory
       * @returns {void}
      */

    }, {
      key: "_remove",
      value: function _remove(directory, item, isDirectory) {
        var _this17 = this;

        // if what is being deleted is a directory, get that directory's paths
        // for recursive deleting and cleaning of watched object
        // if it is not a directory, nestedDirectoryChildren will be empty array
        var path = sysPath.join(directory, item);
        var fullPath = sysPath.resolve(path);
        isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath); // prevent duplicate handling in case of arriving here nearly simultaneously
        // via multiple paths (such as _handleFile and _handleDir)

        if (!this._throttle('remove', path, 100)) return; // if the only watched file is removed, watch for its return

        if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
          this.add(directory, item, true);
        } // This will create a new entry in the watched object in either case
        // so we got to do the directory check beforehand


        var wp = this._getWatchedDir(path);

        var nestedDirectoryChildren = wp.getChildren(); // Recursively remove children directories / files.

        nestedDirectoryChildren.forEach(function (nested) {
          return _this17._remove(path, nested);
        }); // Check if item was on the watched list and remove it

        var parent = this._getWatchedDir(directory);

        var wasTracked = parent.has(item);
        parent.remove(item); // Fixes issue #1042 -> Relative paths were detected and added as symlinks
        // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),
        // but never removed from the map in case the path was deleted.
        // This leads to an incorrect state if the path was recreated:
        // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553

        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths["delete"](fullPath);
        } // If we wait for this file to be fully written, cancel the wait.


        var relPath = path;
        if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);

        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          var event = this._pendingWrites.get(relPath).cancelWait();

          if (event === EV_ADD) return;
        } // The Entry will either be a directory that just got removed
        // or a bogus entry to a file, in either case we have to remove it


        this._watched["delete"](path);

        this._watched["delete"](fullPath);

        var eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
        if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path); // Avoid conflicts if we later create another file with the same name

        if (!this.options.useFsEvents) {
          this._closePath(path);
        }
      }
      /**
       * Closes all watchers for a path
       * @param {Path} path
       */

    }, {
      key: "_closePath",
      value: function _closePath(path) {
        this._closeFile(path);

        var dir = sysPath.dirname(path);

        this._getWatchedDir(dir).remove(sysPath.basename(path));
      }
      /**
       * Closes only file-specific watchers
       * @param {Path} path
       */

    }, {
      key: "_closeFile",
      value: function _closeFile(path) {
        var closers = this._closers.get(path);

        if (!closers) return;
        closers.forEach(function (closer) {
          return closer();
        });

        this._closers["delete"](path);
      }
      /**
       *
       * @param {Path} path
       * @param {Function} closer
       */

    }, {
      key: "_addPathCloser",
      value: function _addPathCloser(path, closer) {
        if (!closer) return;

        var list = this._closers.get(path);

        if (!list) {
          list = [];

          this._closers.set(path, list);
        }

        list.push(closer);
      }
    }, {
      key: "_readdirp",
      value: function _readdirp(root, opts) {
        var _this18 = this;

        if (this.closed) return;

        var options = _objectSpread({
          type: EV_ALL,
          alwaysStat: true,
          lstat: true
        }, opts);

        var stream = readdirp(root, options);

        this._streams.add(stream);

        stream.once(STR_CLOSE, function () {
          stream = undefined;
        });
        stream.once(STR_END, function () {
          if (stream) {
            _this18._streams["delete"](stream);

            stream = undefined;
          }
        });
        return stream;
      }
    }]);

    return FSWatcher;
  }(EventEmitter); // Export FSWatcher class


  chokidar$1.FSWatcher = FSWatcher;
  /**
   * Instantiates watcher with paths to be tracked.
   * @param {String|Array<String>} paths file/directory paths and/or globs
   * @param {Object=} options chokidar opts
   * @returns an instance of FSWatcher for chaining.
   */

  var watch = function watch(paths, options) {
    var watcher = new FSWatcher(options);
    watcher.add(paths);
    return watcher;
  };

  chokidar$1.watch = watch;
  return chokidar$1;
}

var chokidarExports =
/*@__PURE__*/
requireChokidar();
var chokidar =
/*@__PURE__*/
rollup.getDefaultExportFromCjs(chokidarExports);
exports.chokidar = chokidar;