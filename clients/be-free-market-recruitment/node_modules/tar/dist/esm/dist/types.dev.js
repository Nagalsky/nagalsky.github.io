"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.code = exports.name = exports.isName = exports.isCode = void 0;

var isCode = function isCode(c) {
  return name.has(c);
};

exports.isCode = isCode;

var isName = function isName(c) {
  return code.has(c);
}; // map types from key to human-friendly name


exports.isName = isName;
var name = new Map([['0', 'File'], // same as File
['', 'OldFile'], ['1', 'Link'], ['2', 'SymbolicLink'], // Devices and FIFOs aren't fully supported
// they are parsed, but skipped when unpacking
['3', 'CharacterDevice'], ['4', 'BlockDevice'], ['5', 'Directory'], ['6', 'FIFO'], // same as File
['7', 'ContiguousFile'], // pax headers
['g', 'GlobalExtendedHeader'], ['x', 'ExtendedHeader'], // vendor-specific stuff
// skip
['A', 'SolarisACL'], // like 5, but with data, which should be skipped
['D', 'GNUDumpDir'], // metadata only, skip
['I', 'Inode'], // data = link path of next file
['K', 'NextFileHasLongLinkpath'], // data = path of next file
['L', 'NextFileHasLongPath'], // skip
['M', 'ContinuationFile'], // like L
['N', 'OldGnuLongPath'], // skip
['S', 'SparseFile'], // skip
['V', 'TapeVolumeHeader'], // like x
['X', 'OldExtendedHeader']]); // map the other direction

exports.name = name;
var code = new Map(Array.from(name).map(function (kv) {
  return [kv[1], kv[0]];
}));
exports.code = code;