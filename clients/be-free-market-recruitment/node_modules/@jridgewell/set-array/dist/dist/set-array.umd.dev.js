"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.setArray = {}));
})(void 0, function (exports) {
  'use strict';
  /**
   * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the
   * index of the `key` in the backing array.
   *
   * This is designed to allow synchronizing a second array with the contents of the backing array,
   * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,
   * and there are never duplicates.
   */

  var SetArray = function SetArray() {
    _classCallCheck(this, SetArray);

    this._indexes = {
      __proto__: null
    };
    this.array = [];
  };
  /**
   * Typescript doesn't allow friend access to private fields, so this just casts the set into a type
   * with public access modifiers.
   */


  function cast(set) {
    return set;
  }
  /**
   * Gets the index associated with `key` in the backing array, if it is already present.
   */


  function get(setarr, key) {
    return cast(setarr)._indexes[key];
  }
  /**
   * Puts `key` into the backing array, if it is not already present. Returns
   * the index of the `key` in the backing array.
   */


  function put(setarr, key) {
    // The key may or may not be present. If it is present, it's a number.
    var index = get(setarr, key);
    if (index !== undefined) return index;

    var _cast = cast(setarr),
        array = _cast.array,
        indexes = _cast._indexes;

    var length = array.push(key);
    return indexes[key] = length - 1;
  }
  /**
   * Pops the last added item out of the SetArray.
   */


  function pop(setarr) {
    var _cast2 = cast(setarr),
        array = _cast2.array,
        indexes = _cast2._indexes;

    if (array.length === 0) return;
    var last = array.pop();
    indexes[last] = undefined;
  }
  /**
   * Removes the key, if it exists in the set.
   */


  function remove(setarr, key) {
    var index = get(setarr, key);
    if (index === undefined) return;

    var _cast3 = cast(setarr),
        array = _cast3.array,
        indexes = _cast3._indexes;

    for (var i = index + 1; i < array.length; i++) {
      var k = array[i];
      array[i - 1] = k;
      indexes[k]--;
    }

    indexes[key] = undefined;
    array.pop();
  }

  exports.SetArray = SetArray;
  exports.get = get;
  exports.pop = pop;
  exports.put = put;
  exports.remove = remove;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});