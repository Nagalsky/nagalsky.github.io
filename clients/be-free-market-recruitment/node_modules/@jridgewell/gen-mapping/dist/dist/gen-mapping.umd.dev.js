"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/set-array'), require('@jridgewell/sourcemap-codec'), require('@jridgewell/trace-mapping')) : typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/set-array', '@jridgewell/sourcemap-codec', '@jridgewell/trace-mapping'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.genMapping = {}, global.setArray, global.sourcemapCodec, global.traceMapping));
})(void 0, function (exports, setArray, sourcemapCodec, traceMapping) {
  'use strict';

  var COLUMN = 0;
  var SOURCES_INDEX = 1;
  var SOURCE_LINE = 2;
  var SOURCE_COLUMN = 3;
  var NAMES_INDEX = 4;
  var NO_NAME = -1;
  /**
   * Provides the state to generate a sourcemap.
   */

  var GenMapping = function GenMapping() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        file = _ref.file,
        sourceRoot = _ref.sourceRoot;

    _classCallCheck(this, GenMapping);

    this._names = new setArray.SetArray();
    this._sources = new setArray.SetArray();
    this._sourcesContent = [];
    this._mappings = [];
    this.file = file;
    this.sourceRoot = sourceRoot;
    this._ignoreList = new setArray.SetArray();
  };
  /**
   * Typescript doesn't allow friend access to private fields, so this just casts the map into a type
   * with public access modifiers.
   */


  function cast(map) {
    return map;
  }

  function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
    return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
  }

  function addMapping(map, mapping) {
    return addMappingInternal(false, map, mapping);
  }
  /**
   * Same as `addSegment`, but will only add the segment if it generates useful information in the
   * resulting map. This only works correctly if segments are added **in order**, meaning you should
   * not add a segment with a lower generated line/column than one that came before.
   */


  var maybeAddSegment = function maybeAddSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
    return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
  };
  /**
   * Same as `addMapping`, but will only add the mapping if it generates useful information in the
   * resulting map. This only works correctly if mappings are added **in order**, meaning you should
   * not add a mapping with a lower generated line/column than one that came before.
   */


  var maybeAddMapping = function maybeAddMapping(map, mapping) {
    return addMappingInternal(true, map, mapping);
  };
  /**
   * Adds/removes the content of the source file to the source map.
   */


  function setSourceContent(map, source, content) {
    var _cast = cast(map),
        sources = _cast._sources,
        sourcesContent = _cast._sourcesContent;

    var index = setArray.put(sources, source);
    sourcesContent[index] = content;
  }

  function setIgnore(map, source) {
    var ignore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    var _cast2 = cast(map),
        sources = _cast2._sources,
        sourcesContent = _cast2._sourcesContent,
        ignoreList = _cast2._ignoreList;

    var index = setArray.put(sources, source);
    if (index === sourcesContent.length) sourcesContent[index] = null;
    if (ignore) setArray.put(ignoreList, index);else setArray.remove(ignoreList, index);
  }
  /**
   * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
   * a sourcemap, or to JSON.stringify.
   */


  function toDecodedMap(map) {
    var _cast3 = cast(map),
        mappings = _cast3._mappings,
        sources = _cast3._sources,
        sourcesContent = _cast3._sourcesContent,
        names = _cast3._names,
        ignoreList = _cast3._ignoreList;

    removeEmptyFinalLines(mappings);
    return {
      version: 3,
      file: map.file || undefined,
      names: names.array,
      sourceRoot: map.sourceRoot || undefined,
      sources: sources.array,
      sourcesContent: sourcesContent,
      mappings: mappings,
      ignoreList: ignoreList.array
    };
  }
  /**
   * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
   * a sourcemap, or to JSON.stringify.
   */


  function toEncodedMap(map) {
    var decoded = toDecodedMap(map);
    return Object.assign(Object.assign({}, decoded), {
      mappings: sourcemapCodec.encode(decoded.mappings)
    });
  }
  /**
   * Constructs a new GenMapping, using the already present mappings of the input.
   */


  function fromMap(input) {
    var map = new traceMapping.TraceMap(input);
    var gen = new GenMapping({
      file: map.file,
      sourceRoot: map.sourceRoot
    });
    putAll(cast(gen)._names, map.names);
    putAll(cast(gen)._sources, map.sources);
    cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(function () {
      return null;
    });
    cast(gen)._mappings = traceMapping.decodedMappings(map);
    if (map.ignoreList) putAll(cast(gen)._ignoreList, map.ignoreList);
    return gen;
  }
  /**
   * Returns an array of high-level mapping objects for every recorded segment, which could then be
   * passed to the `source-map` library.
   */


  function allMappings(map) {
    var out = [];

    var _cast4 = cast(map),
        mappings = _cast4._mappings,
        sources = _cast4._sources,
        names = _cast4._names;

    for (var i = 0; i < mappings.length; i++) {
      var line = mappings[i];

      for (var j = 0; j < line.length; j++) {
        var seg = line[j];
        var generated = {
          line: i + 1,
          column: seg[COLUMN]
        };
        var source = undefined;
        var original = undefined;
        var name = undefined;

        if (seg.length !== 1) {
          source = sources.array[seg[SOURCES_INDEX]];
          original = {
            line: seg[SOURCE_LINE] + 1,
            column: seg[SOURCE_COLUMN]
          };
          if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];
        }

        out.push({
          generated: generated,
          source: source,
          original: original,
          name: name
        });
      }
    }

    return out;
  } // This split declaration is only so that terser can elminiate the static initialization block.


  function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
    var _cast5 = cast(map),
        mappings = _cast5._mappings,
        sources = _cast5._sources,
        sourcesContent = _cast5._sourcesContent,
        names = _cast5._names;

    var line = getLine(mappings, genLine);
    var index = getColumnIndex(line, genColumn);

    if (!source) {
      if (skipable && skipSourceless(line, index)) return;
      return insert(line, index, [genColumn]);
    }

    var sourcesIndex = setArray.put(sources, source);
    var namesIndex = name ? setArray.put(names, name) : NO_NAME;
    if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;

    if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
      return;
    }

    return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
  }

  function getLine(mappings, index) {
    for (var i = mappings.length; i <= index; i++) {
      mappings[i] = [];
    }

    return mappings[index];
  }

  function getColumnIndex(line, genColumn) {
    var index = line.length;

    for (var i = index - 1; i >= 0; index = i--) {
      var current = line[i];
      if (genColumn >= current[COLUMN]) break;
    }

    return index;
  }

  function insert(array, index, value) {
    for (var i = array.length; i > index; i--) {
      array[i] = array[i - 1];
    }

    array[index] = value;
  }

  function removeEmptyFinalLines(mappings) {
    var length = mappings.length;
    var len = length;

    for (var i = len - 1; i >= 0; len = i, i--) {
      if (mappings[i].length > 0) break;
    }

    if (len < length) mappings.length = len;
  }

  function putAll(setarr, array) {
    for (var i = 0; i < array.length; i++) {
      setArray.put(setarr, array[i]);
    }
  }

  function skipSourceless(line, index) {
    // The start of a line is already sourceless, so adding a sourceless segment to the beginning
    // doesn't generate any useful information.
    if (index === 0) return true;
    var prev = line[index - 1]; // If the previous segment is also sourceless, then adding another sourceless segment doesn't
    // genrate any new information. Else, this segment will end the source/named segment and point to
    // a sourceless position, which is useful.

    return prev.length === 1;
  }

  function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
    // A source/named segment at the start of a line gives position at that genColumn
    if (index === 0) return false;
    var prev = line[index - 1]; // If the previous segment is sourceless, then we're transitioning to a source.

    if (prev.length === 1) return false; // If the previous segment maps to the exact same source position, then this segment doesn't
    // provide any new position information.

    return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
  }

  function addMappingInternal(skipable, map, mapping) {
    var generated = mapping.generated,
        source = mapping.source,
        original = mapping.original,
        name = mapping.name,
        content = mapping.content;

    if (!source) {
      return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
    }

    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
  }

  exports.GenMapping = GenMapping;
  exports.addMapping = addMapping;
  exports.addSegment = addSegment;
  exports.allMappings = allMappings;
  exports.fromMap = fromMap;
  exports.maybeAddMapping = maybeAddMapping;
  exports.maybeAddSegment = maybeAddSegment;
  exports.setIgnore = setIgnore;
  exports.setSourceContent = setSourceContent;
  exports.toDecodedMap = toDecodedMap;
  exports.toEncodedMap = toEncodedMap;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});