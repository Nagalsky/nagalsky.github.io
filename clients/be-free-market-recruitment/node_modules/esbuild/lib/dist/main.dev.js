"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;

var __export = function __export(target, all) {
  for (var name in all) {
    __defProp(target, name, {
      get: all[name],
      enumerable: true
    });
  }
};

var __copyProps = function __copyProps(to, from, except, desc) {
  if (from && _typeof(from) === "object" || typeof from === "function") {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      var _loop = function _loop() {
        var key = _step.value;
        if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
          get: function get() {
            return from[key];
          },
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
      };

      for (var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return to;
};

var __toESM = function __toESM(mod, isNodeMode, target) {
  return target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps( // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod);
};

var __toCommonJS = function __toCommonJS(mod) {
  return __copyProps(__defProp({}, "__esModule", {
    value: true
  }), mod);
}; // lib/npm/node.ts


var node_exports = {};

__export(node_exports, {
  analyzeMetafile: function analyzeMetafile() {
    return _analyzeMetafile;
  },
  analyzeMetafileSync: function analyzeMetafileSync() {
    return _analyzeMetafileSync;
  },
  build: function build() {
    return _build;
  },
  buildSync: function buildSync() {
    return _buildSync;
  },
  context: function context() {
    return _context;
  },
  "default": function _default() {
    return node_default;
  },
  formatMessages: function formatMessages() {
    return _formatMessages;
  },
  formatMessagesSync: function formatMessagesSync() {
    return _formatMessagesSync;
  },
  initialize: function initialize() {
    return _initialize;
  },
  stop: function stop() {
    return _stop;
  },
  transform: function transform() {
    return _transform;
  },
  transformSync: function transformSync() {
    return _transformSync;
  },
  version: function version() {
    return _version;
  }
});

module.exports = __toCommonJS(node_exports); // lib/shared/stdio_protocol.ts

function encodePacket(packet) {
  var visit = function visit(value) {
    if (value === null) {
      bb.write8(0);
    } else if (typeof value === "boolean") {
      bb.write8(1);
      bb.write8(+value);
    } else if (typeof value === "number") {
      bb.write8(2);
      bb.write32(value | 0);
    } else if (typeof value === "string") {
      bb.write8(3);
      bb.write(encodeUTF8(value));
    } else if (value instanceof Uint8Array) {
      bb.write8(4);
      bb.write(value);
    } else if (value instanceof Array) {
      bb.write8(5);
      bb.write32(value.length);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;
          visit(item);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    } else {
      var keys = Object.keys(value);
      bb.write8(6);
      bb.write32(keys.length);

      for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
        var key = _keys[_i];
        bb.write(encodeUTF8(key));
        visit(value[key]);
      }
    }
  };

  var bb = new ByteBuffer();
  bb.write32(0);
  bb.write32(packet.id << 1 | +!packet.isRequest);
  visit(packet.value);
  writeUInt32LE(bb.buf, bb.len - 4, 0);
  return bb.buf.subarray(0, bb.len);
}

function decodePacket(bytes) {
  var visit = function visit() {
    switch (bb.read8()) {
      case 0:
        return null;

      case 1:
        return !!bb.read8();

      case 2:
        return bb.read32();

      case 3:
        return decodeUTF8(bb.read());

      case 4:
        return bb.read();

      case 5:
        {
          var count = bb.read32();
          var value2 = [];

          for (var i = 0; i < count; i++) {
            value2.push(visit());
          }

          return value2;
        }

      case 6:
        {
          var _count = bb.read32();

          var _value = {};

          for (var _i2 = 0; _i2 < _count; _i2++) {
            _value[decodeUTF8(bb.read())] = visit();
          }

          return _value;
        }

      default:
        throw new Error("Invalid packet");
    }
  };

  var bb = new ByteBuffer(bytes);
  var id = bb.read32();
  var isRequest = (id & 1) === 0;
  id >>>= 1;
  var value = visit();

  if (bb.ptr !== bytes.length) {
    throw new Error("Invalid packet");
  }

  return {
    id: id,
    isRequest: isRequest,
    value: value
  };
}

var ByteBuffer =
/*#__PURE__*/
function () {
  function ByteBuffer() {
    var buf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array(1024);

    _classCallCheck(this, ByteBuffer);

    this.buf = buf;
    this.len = 0;
    this.ptr = 0;
  }

  _createClass(ByteBuffer, [{
    key: "_write",
    value: function _write(delta) {
      if (this.len + delta > this.buf.length) {
        var clone = new Uint8Array((this.len + delta) * 2);
        clone.set(this.buf);
        this.buf = clone;
      }

      this.len += delta;
      return this.len - delta;
    }
  }, {
    key: "write8",
    value: function write8(value) {
      var offset = this._write(1);

      this.buf[offset] = value;
    }
  }, {
    key: "write32",
    value: function write32(value) {
      var offset = this._write(4);

      writeUInt32LE(this.buf, value, offset);
    }
  }, {
    key: "write",
    value: function write(bytes) {
      var offset = this._write(4 + bytes.length);

      writeUInt32LE(this.buf, bytes.length, offset);
      this.buf.set(bytes, offset + 4);
    }
  }, {
    key: "_read",
    value: function _read(delta) {
      if (this.ptr + delta > this.buf.length) {
        throw new Error("Invalid packet");
      }

      this.ptr += delta;
      return this.ptr - delta;
    }
  }, {
    key: "read8",
    value: function read8() {
      return this.buf[this._read(1)];
    }
  }, {
    key: "read32",
    value: function read32() {
      return readUInt32LE(this.buf, this._read(4));
    }
  }, {
    key: "read",
    value: function read() {
      var length = this.read32();
      var bytes = new Uint8Array(length);

      var ptr = this._read(bytes.length);

      bytes.set(this.buf.subarray(ptr, ptr + length));
      return bytes;
    }
  }]);

  return ByteBuffer;
}();

var encodeUTF8;
var decodeUTF8;
var encodeInvariant;

if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
  var encoder = new TextEncoder();
  var decoder = new TextDecoder();

  encodeUTF8 = function encodeUTF8(text) {
    return encoder.encode(text);
  };

  decodeUTF8 = function decodeUTF8(bytes) {
    return decoder.decode(bytes);
  };

  encodeInvariant = 'new TextEncoder().encode("")';
} else if (typeof Buffer !== "undefined") {
  encodeUTF8 = function encodeUTF8(text) {
    return Buffer.from(text);
  };

  decodeUTF8 = function decodeUTF8(bytes) {
    var buffer = bytes.buffer,
        byteOffset = bytes.byteOffset,
        byteLength = bytes.byteLength;
    return Buffer.from(buffer, byteOffset, byteLength).toString();
  };

  encodeInvariant = 'Buffer.from("")';
} else {
  throw new Error("No UTF-8 codec found");
}

if (!(encodeUTF8("") instanceof Uint8Array)) throw new Error("Invariant violation: \"".concat(encodeInvariant, " instanceof Uint8Array\" is incorrectly false\n\nThis indicates that your JavaScript environment is broken. You cannot use\nesbuild in this environment because esbuild relies on this invariant. This\nis not a problem with esbuild. You need to fix your environment instead.\n"));

function readUInt32LE(buffer, offset) {
  return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;
}

function writeUInt32LE(buffer, value, offset) {
  buffer[offset++] = value;
  buffer[offset++] = value >> 8;
  buffer[offset++] = value >> 16;
  buffer[offset++] = value >> 24;
} // lib/shared/common.ts


var quote = JSON.stringify;
var buildLogLevelDefault = "warning";
var transformLogLevelDefault = "silent";

function validateAndJoinStringArray(values, what) {
  var toJoin = [];
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = values[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var value = _step3.value;
      validateStringValue(value, what);
      if (value.indexOf(",") >= 0) throw new Error("Invalid ".concat(what, ": ").concat(value));
      toJoin.push(value);
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return toJoin.join(",");
}

var canBeAnything = function canBeAnything() {
  return null;
};

var mustBeBoolean = function mustBeBoolean(value) {
  return typeof value === "boolean" ? null : "a boolean";
};

var mustBeString = function mustBeString(value) {
  return typeof value === "string" ? null : "a string";
};

var mustBeRegExp = function mustBeRegExp(value) {
  return value instanceof RegExp ? null : "a RegExp object";
};

var mustBeInteger = function mustBeInteger(value) {
  return typeof value === "number" && value === (value | 0) ? null : "an integer";
};

var mustBeValidPortNumber = function mustBeValidPortNumber(value) {
  return typeof value === "number" && value === (value | 0) && value >= 0 && value <= 65535 ? null : "a valid port number";
};

var mustBeFunction = function mustBeFunction(value) {
  return typeof value === "function" ? null : "a function";
};

var mustBeArray = function mustBeArray(value) {
  return Array.isArray(value) ? null : "an array";
};

var mustBeArrayOfStrings = function mustBeArrayOfStrings(value) {
  return Array.isArray(value) && value.every(function (x) {
    return typeof x === "string";
  }) ? null : "an array of strings";
};

var mustBeObject = function mustBeObject(value) {
  return _typeof(value) === "object" && value !== null && !Array.isArray(value) ? null : "an object";
};

var mustBeEntryPoints = function mustBeEntryPoints(value) {
  return _typeof(value) === "object" && value !== null ? null : "an array or an object";
};

var mustBeWebAssemblyModule = function mustBeWebAssemblyModule(value) {
  return value instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
};

var mustBeObjectOrNull = function mustBeObjectOrNull(value) {
  return _typeof(value) === "object" && !Array.isArray(value) ? null : "an object or null";
};

var mustBeStringOrBoolean = function mustBeStringOrBoolean(value) {
  return typeof value === "string" || typeof value === "boolean" ? null : "a string or a boolean";
};

var mustBeStringOrObject = function mustBeStringOrObject(value) {
  return typeof value === "string" || _typeof(value) === "object" && value !== null && !Array.isArray(value) ? null : "a string or an object";
};

var mustBeStringOrArrayOfStrings = function mustBeStringOrArrayOfStrings(value) {
  return typeof value === "string" || Array.isArray(value) && value.every(function (x) {
    return typeof x === "string";
  }) ? null : "a string or an array of strings";
};

var mustBeStringOrUint8Array = function mustBeStringOrUint8Array(value) {
  return typeof value === "string" || value instanceof Uint8Array ? null : "a string or a Uint8Array";
};

var mustBeStringOrURL = function mustBeStringOrURL(value) {
  return typeof value === "string" || value instanceof URL ? null : "a string or a URL";
};

function getFlag(object, keys, key, mustBeFn) {
  var value = object[key];
  keys[key + ""] = true;
  if (value === void 0) return void 0;
  var mustBe = mustBeFn(value);
  if (mustBe !== null) throw new Error("".concat(quote(key), " must be ").concat(mustBe));
  return value;
}

function checkForInvalidFlags(object, keys, where) {
  for (var key in object) {
    if (!(key in keys)) {
      throw new Error("Invalid option ".concat(where, ": ").concat(quote(key)));
    }
  }
}

function validateInitializeOptions(options) {
  var keys =
  /* @__PURE__ */
  Object.create(null);
  var wasmURL = getFlag(options, keys, "wasmURL", mustBeStringOrURL);
  var wasmModule = getFlag(options, keys, "wasmModule", mustBeWebAssemblyModule);
  var worker = getFlag(options, keys, "worker", mustBeBoolean);
  checkForInvalidFlags(options, keys, "in initialize() call");
  return {
    wasmURL: wasmURL,
    wasmModule: wasmModule,
    worker: worker
  };
}

function validateMangleCache(mangleCache) {
  var validated;

  if (mangleCache !== void 0) {
    validated =
    /* @__PURE__ */
    Object.create(null);

    for (var key in mangleCache) {
      var value = mangleCache[key];

      if (typeof value === "string" || value === false) {
        validated[key] = value;
      } else {
        throw new Error("Expected ".concat(quote(key), " in mangle cache to map to either a string or false"));
      }
    }
  }

  return validated;
}

function pushLogFlags(flags, options, keys, isTTY2, logLevelDefault) {
  var color = getFlag(options, keys, "color", mustBeBoolean);
  var logLevel = getFlag(options, keys, "logLevel", mustBeString);
  var logLimit = getFlag(options, keys, "logLimit", mustBeInteger);
  if (color !== void 0) flags.push("--color=".concat(color));else if (isTTY2) flags.push("--color=true");
  flags.push("--log-level=".concat(logLevel || logLevelDefault));
  flags.push("--log-limit=".concat(logLimit || 0));
}

function validateStringValue(value, what, key) {
  if (typeof value !== "string") {
    throw new Error("Expected value for ".concat(what).concat(key !== void 0 ? " " + quote(key) : "", " to be a string, got ").concat(_typeof(value), " instead"));
  }

  return value;
}

function pushCommonFlags(flags, options, keys) {
  var legalComments = getFlag(options, keys, "legalComments", mustBeString);
  var sourceRoot = getFlag(options, keys, "sourceRoot", mustBeString);
  var sourcesContent = getFlag(options, keys, "sourcesContent", mustBeBoolean);
  var target = getFlag(options, keys, "target", mustBeStringOrArrayOfStrings);
  var format = getFlag(options, keys, "format", mustBeString);
  var globalName = getFlag(options, keys, "globalName", mustBeString);
  var mangleProps = getFlag(options, keys, "mangleProps", mustBeRegExp);
  var reserveProps = getFlag(options, keys, "reserveProps", mustBeRegExp);
  var mangleQuoted = getFlag(options, keys, "mangleQuoted", mustBeBoolean);
  var minify = getFlag(options, keys, "minify", mustBeBoolean);
  var minifySyntax = getFlag(options, keys, "minifySyntax", mustBeBoolean);
  var minifyWhitespace = getFlag(options, keys, "minifyWhitespace", mustBeBoolean);
  var minifyIdentifiers = getFlag(options, keys, "minifyIdentifiers", mustBeBoolean);
  var lineLimit = getFlag(options, keys, "lineLimit", mustBeInteger);
  var drop = getFlag(options, keys, "drop", mustBeArrayOfStrings);
  var dropLabels = getFlag(options, keys, "dropLabels", mustBeArrayOfStrings);
  var charset = getFlag(options, keys, "charset", mustBeString);
  var treeShaking = getFlag(options, keys, "treeShaking", mustBeBoolean);
  var ignoreAnnotations = getFlag(options, keys, "ignoreAnnotations", mustBeBoolean);
  var jsx = getFlag(options, keys, "jsx", mustBeString);
  var jsxFactory = getFlag(options, keys, "jsxFactory", mustBeString);
  var jsxFragment = getFlag(options, keys, "jsxFragment", mustBeString);
  var jsxImportSource = getFlag(options, keys, "jsxImportSource", mustBeString);
  var jsxDev = getFlag(options, keys, "jsxDev", mustBeBoolean);
  var jsxSideEffects = getFlag(options, keys, "jsxSideEffects", mustBeBoolean);
  var define = getFlag(options, keys, "define", mustBeObject);
  var logOverride = getFlag(options, keys, "logOverride", mustBeObject);
  var supported = getFlag(options, keys, "supported", mustBeObject);
  var pure = getFlag(options, keys, "pure", mustBeArrayOfStrings);
  var keepNames = getFlag(options, keys, "keepNames", mustBeBoolean);
  var platform = getFlag(options, keys, "platform", mustBeString);
  var tsconfigRaw = getFlag(options, keys, "tsconfigRaw", mustBeStringOrObject);
  if (legalComments) flags.push("--legal-comments=".concat(legalComments));
  if (sourceRoot !== void 0) flags.push("--source-root=".concat(sourceRoot));
  if (sourcesContent !== void 0) flags.push("--sources-content=".concat(sourcesContent));
  if (target) flags.push("--target=".concat(validateAndJoinStringArray(Array.isArray(target) ? target : [target], "target")));
  if (format) flags.push("--format=".concat(format));
  if (globalName) flags.push("--global-name=".concat(globalName));
  if (platform) flags.push("--platform=".concat(platform));
  if (tsconfigRaw) flags.push("--tsconfig-raw=".concat(typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)));
  if (minify) flags.push("--minify");
  if (minifySyntax) flags.push("--minify-syntax");
  if (minifyWhitespace) flags.push("--minify-whitespace");
  if (minifyIdentifiers) flags.push("--minify-identifiers");
  if (lineLimit) flags.push("--line-limit=".concat(lineLimit));
  if (charset) flags.push("--charset=".concat(charset));
  if (treeShaking !== void 0) flags.push("--tree-shaking=".concat(treeShaking));
  if (ignoreAnnotations) flags.push("--ignore-annotations");

  if (drop) {
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = drop[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var what = _step4.value;
        flags.push("--drop:".concat(validateStringValue(what, "drop")));
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
          _iterator4["return"]();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }
  }

  if (dropLabels) flags.push("--drop-labels=".concat(validateAndJoinStringArray(dropLabels, "drop label")));
  if (mangleProps) flags.push("--mangle-props=".concat(jsRegExpToGoRegExp(mangleProps)));
  if (reserveProps) flags.push("--reserve-props=".concat(jsRegExpToGoRegExp(reserveProps)));
  if (mangleQuoted !== void 0) flags.push("--mangle-quoted=".concat(mangleQuoted));
  if (jsx) flags.push("--jsx=".concat(jsx));
  if (jsxFactory) flags.push("--jsx-factory=".concat(jsxFactory));
  if (jsxFragment) flags.push("--jsx-fragment=".concat(jsxFragment));
  if (jsxImportSource) flags.push("--jsx-import-source=".concat(jsxImportSource));
  if (jsxDev) flags.push("--jsx-dev");
  if (jsxSideEffects) flags.push("--jsx-side-effects");

  if (define) {
    for (var key in define) {
      if (key.indexOf("=") >= 0) throw new Error("Invalid define: ".concat(key));
      flags.push("--define:".concat(key, "=").concat(validateStringValue(define[key], "define", key)));
    }
  }

  if (logOverride) {
    for (var _key in logOverride) {
      if (_key.indexOf("=") >= 0) throw new Error("Invalid log override: ".concat(_key));
      flags.push("--log-override:".concat(_key, "=").concat(validateStringValue(logOverride[_key], "log override", _key)));
    }
  }

  if (supported) {
    for (var _key2 in supported) {
      if (_key2.indexOf("=") >= 0) throw new Error("Invalid supported: ".concat(_key2));
      var value = supported[_key2];
      if (typeof value !== "boolean") throw new Error("Expected value for supported ".concat(quote(_key2), " to be a boolean, got ").concat(_typeof(value), " instead"));
      flags.push("--supported:".concat(_key2, "=").concat(value));
    }
  }

  if (pure) {
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;
    var _iteratorError5 = undefined;

    try {
      for (var _iterator5 = pure[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
        var fn = _step5.value;
        flags.push("--pure:".concat(validateStringValue(fn, "pure")));
      }
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
          _iterator5["return"]();
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }
  }

  if (keepNames) flags.push("--keep-names");
}

function flagsForBuildOptions(callName, options, isTTY2, logLevelDefault, writeDefault) {
  var _a2;

  var flags = [];
  var entries = [];
  var keys =
  /* @__PURE__ */
  Object.create(null);
  var stdinContents = null;
  var stdinResolveDir = null;
  pushLogFlags(flags, options, keys, isTTY2, logLevelDefault);
  pushCommonFlags(flags, options, keys);
  var sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
  var bundle = getFlag(options, keys, "bundle", mustBeBoolean);
  var splitting = getFlag(options, keys, "splitting", mustBeBoolean);
  var preserveSymlinks = getFlag(options, keys, "preserveSymlinks", mustBeBoolean);
  var metafile = getFlag(options, keys, "metafile", mustBeBoolean);
  var outfile = getFlag(options, keys, "outfile", mustBeString);
  var outdir = getFlag(options, keys, "outdir", mustBeString);
  var outbase = getFlag(options, keys, "outbase", mustBeString);
  var tsconfig = getFlag(options, keys, "tsconfig", mustBeString);
  var resolveExtensions = getFlag(options, keys, "resolveExtensions", mustBeArrayOfStrings);
  var nodePathsInput = getFlag(options, keys, "nodePaths", mustBeArrayOfStrings);
  var mainFields = getFlag(options, keys, "mainFields", mustBeArrayOfStrings);
  var conditions = getFlag(options, keys, "conditions", mustBeArrayOfStrings);
  var external = getFlag(options, keys, "external", mustBeArrayOfStrings);
  var packages = getFlag(options, keys, "packages", mustBeString);
  var alias = getFlag(options, keys, "alias", mustBeObject);
  var loader = getFlag(options, keys, "loader", mustBeObject);
  var outExtension = getFlag(options, keys, "outExtension", mustBeObject);
  var publicPath = getFlag(options, keys, "publicPath", mustBeString);
  var entryNames = getFlag(options, keys, "entryNames", mustBeString);
  var chunkNames = getFlag(options, keys, "chunkNames", mustBeString);
  var assetNames = getFlag(options, keys, "assetNames", mustBeString);
  var inject = getFlag(options, keys, "inject", mustBeArrayOfStrings);
  var banner = getFlag(options, keys, "banner", mustBeObject);
  var footer = getFlag(options, keys, "footer", mustBeObject);
  var entryPoints = getFlag(options, keys, "entryPoints", mustBeEntryPoints);
  var absWorkingDir = getFlag(options, keys, "absWorkingDir", mustBeString);
  var stdin = getFlag(options, keys, "stdin", mustBeObject);
  var write = (_a2 = getFlag(options, keys, "write", mustBeBoolean)) != null ? _a2 : writeDefault;
  var allowOverwrite = getFlag(options, keys, "allowOverwrite", mustBeBoolean);
  var mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
  keys.plugins = true;
  checkForInvalidFlags(options, keys, "in ".concat(callName, "() call"));
  if (sourcemap) flags.push("--sourcemap".concat(sourcemap === true ? "" : "=".concat(sourcemap)));
  if (bundle) flags.push("--bundle");
  if (allowOverwrite) flags.push("--allow-overwrite");
  if (splitting) flags.push("--splitting");
  if (preserveSymlinks) flags.push("--preserve-symlinks");
  if (metafile) flags.push("--metafile");
  if (outfile) flags.push("--outfile=".concat(outfile));
  if (outdir) flags.push("--outdir=".concat(outdir));
  if (outbase) flags.push("--outbase=".concat(outbase));
  if (tsconfig) flags.push("--tsconfig=".concat(tsconfig));
  if (packages) flags.push("--packages=".concat(packages));
  if (resolveExtensions) flags.push("--resolve-extensions=".concat(validateAndJoinStringArray(resolveExtensions, "resolve extension")));
  if (publicPath) flags.push("--public-path=".concat(publicPath));
  if (entryNames) flags.push("--entry-names=".concat(entryNames));
  if (chunkNames) flags.push("--chunk-names=".concat(chunkNames));
  if (assetNames) flags.push("--asset-names=".concat(assetNames));
  if (mainFields) flags.push("--main-fields=".concat(validateAndJoinStringArray(mainFields, "main field")));
  if (conditions) flags.push("--conditions=".concat(validateAndJoinStringArray(conditions, "condition")));

  if (external) {
    var _iteratorNormalCompletion6 = true;
    var _didIteratorError6 = false;
    var _iteratorError6 = undefined;

    try {
      for (var _iterator6 = external[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
        var name = _step6.value;
        flags.push("--external:".concat(validateStringValue(name, "external")));
      }
    } catch (err) {
      _didIteratorError6 = true;
      _iteratorError6 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
          _iterator6["return"]();
        }
      } finally {
        if (_didIteratorError6) {
          throw _iteratorError6;
        }
      }
    }
  }

  if (alias) {
    for (var old in alias) {
      if (old.indexOf("=") >= 0) throw new Error("Invalid package name in alias: ".concat(old));
      flags.push("--alias:".concat(old, "=").concat(validateStringValue(alias[old], "alias", old)));
    }
  }

  if (banner) {
    for (var type in banner) {
      if (type.indexOf("=") >= 0) throw new Error("Invalid banner file type: ".concat(type));
      flags.push("--banner:".concat(type, "=").concat(validateStringValue(banner[type], "banner", type)));
    }
  }

  if (footer) {
    for (var _type in footer) {
      if (_type.indexOf("=") >= 0) throw new Error("Invalid footer file type: ".concat(_type));
      flags.push("--footer:".concat(_type, "=").concat(validateStringValue(footer[_type], "footer", _type)));
    }
  }

  if (inject) {
    var _iteratorNormalCompletion7 = true;
    var _didIteratorError7 = false;
    var _iteratorError7 = undefined;

    try {
      for (var _iterator7 = inject[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
        var path3 = _step7.value;
        flags.push("--inject:".concat(validateStringValue(path3, "inject")));
      }
    } catch (err) {
      _didIteratorError7 = true;
      _iteratorError7 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
          _iterator7["return"]();
        }
      } finally {
        if (_didIteratorError7) {
          throw _iteratorError7;
        }
      }
    }
  }

  if (loader) {
    for (var ext in loader) {
      if (ext.indexOf("=") >= 0) throw new Error("Invalid loader extension: ".concat(ext));
      flags.push("--loader:".concat(ext, "=").concat(validateStringValue(loader[ext], "loader", ext)));
    }
  }

  if (outExtension) {
    for (var _ext in outExtension) {
      if (_ext.indexOf("=") >= 0) throw new Error("Invalid out extension: ".concat(_ext));
      flags.push("--out-extension:".concat(_ext, "=").concat(validateStringValue(outExtension[_ext], "out extension", _ext)));
    }
  }

  if (entryPoints) {
    if (Array.isArray(entryPoints)) {
      for (var i = 0, n = entryPoints.length; i < n; i++) {
        var entryPoint = entryPoints[i];

        if (_typeof(entryPoint) === "object" && entryPoint !== null) {
          var entryPointKeys =
          /* @__PURE__ */
          Object.create(null);
          var input = getFlag(entryPoint, entryPointKeys, "in", mustBeString);
          var output = getFlag(entryPoint, entryPointKeys, "out", mustBeString);
          checkForInvalidFlags(entryPoint, entryPointKeys, "in entry point at index " + i);
          if (input === void 0) throw new Error('Missing property "in" for entry point at index ' + i);
          if (output === void 0) throw new Error('Missing property "out" for entry point at index ' + i);
          entries.push([output, input]);
        } else {
          entries.push(["", validateStringValue(entryPoint, "entry point at index " + i)]);
        }
      }
    } else {
      for (var key in entryPoints) {
        entries.push([key, validateStringValue(entryPoints[key], "entry point", key)]);
      }
    }
  }

  if (stdin) {
    var stdinKeys =
    /* @__PURE__ */
    Object.create(null);
    var contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
    var resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
    var sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
    var loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
    checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
    if (sourcefile) flags.push("--sourcefile=".concat(sourcefile));
    if (loader2) flags.push("--loader=".concat(loader2));
    if (resolveDir) stdinResolveDir = resolveDir;
    if (typeof contents === "string") stdinContents = encodeUTF8(contents);else if (contents instanceof Uint8Array) stdinContents = contents;
  }

  var nodePaths = [];

  if (nodePathsInput) {
    var _iteratorNormalCompletion8 = true;
    var _didIteratorError8 = false;
    var _iteratorError8 = undefined;

    try {
      for (var _iterator8 = nodePathsInput[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
        var value = _step8.value;
        value += "";
        nodePaths.push(value);
      }
    } catch (err) {
      _didIteratorError8 = true;
      _iteratorError8 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
          _iterator8["return"]();
        }
      } finally {
        if (_didIteratorError8) {
          throw _iteratorError8;
        }
      }
    }
  }

  return {
    entries: entries,
    flags: flags,
    write: write,
    stdinContents: stdinContents,
    stdinResolveDir: stdinResolveDir,
    absWorkingDir: absWorkingDir,
    nodePaths: nodePaths,
    mangleCache: validateMangleCache(mangleCache)
  };
}

function flagsForTransformOptions(callName, options, isTTY2, logLevelDefault) {
  var flags = [];
  var keys =
  /* @__PURE__ */
  Object.create(null);
  pushLogFlags(flags, options, keys, isTTY2, logLevelDefault);
  pushCommonFlags(flags, options, keys);
  var sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
  var sourcefile = getFlag(options, keys, "sourcefile", mustBeString);
  var loader = getFlag(options, keys, "loader", mustBeString);
  var banner = getFlag(options, keys, "banner", mustBeString);
  var footer = getFlag(options, keys, "footer", mustBeString);
  var mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
  checkForInvalidFlags(options, keys, "in ".concat(callName, "() call"));
  if (sourcemap) flags.push("--sourcemap=".concat(sourcemap === true ? "external" : sourcemap));
  if (sourcefile) flags.push("--sourcefile=".concat(sourcefile));
  if (loader) flags.push("--loader=".concat(loader));
  if (banner) flags.push("--banner=".concat(banner));
  if (footer) flags.push("--footer=".concat(footer));
  return {
    flags: flags,
    mangleCache: validateMangleCache(mangleCache)
  };
}

function createChannel(streamIn) {
  var requestCallbacksByKey = {};
  var closeData = {
    didClose: false,
    reason: ""
  };
  var responseCallbacks = {};
  var nextRequestID = 0;
  var nextBuildKey = 0;
  var stdout = new Uint8Array(16 * 1024);
  var stdoutUsed = 0;

  var readFromStdout = function readFromStdout(chunk) {
    var limit = stdoutUsed + chunk.length;

    if (limit > stdout.length) {
      var swap = new Uint8Array(limit * 2);
      swap.set(stdout);
      stdout = swap;
    }

    stdout.set(chunk, stdoutUsed);
    stdoutUsed += chunk.length;
    var offset = 0;

    while (offset + 4 <= stdoutUsed) {
      var length = readUInt32LE(stdout, offset);

      if (offset + 4 + length > stdoutUsed) {
        break;
      }

      offset += 4;
      handleIncomingPacket(stdout.subarray(offset, offset + length));
      offset += length;
    }

    if (offset > 0) {
      stdout.copyWithin(0, offset, stdoutUsed);
      stdoutUsed -= offset;
    }
  };

  var afterClose = function afterClose(error) {
    closeData.didClose = true;
    if (error) closeData.reason = ": " + (error.message || error);
    var text = "The service was stopped" + closeData.reason;

    for (var id in responseCallbacks) {
      responseCallbacks[id](text, null);
    }

    responseCallbacks = {};
  };

  var sendRequest = function sendRequest(refs, value, callback) {
    if (closeData.didClose) return callback("The service is no longer running" + closeData.reason, null);
    var id = nextRequestID++;

    responseCallbacks[id] = function (error, response) {
      try {
        callback(error, response);
      } finally {
        if (refs) refs.unref();
      }
    };

    if (refs) refs.ref();
    streamIn.writeToStdin(encodePacket({
      id: id,
      isRequest: true,
      value: value
    }));
  };

  var sendResponse = function sendResponse(id, value) {
    if (closeData.didClose) throw new Error("The service is no longer running" + closeData.reason);
    streamIn.writeToStdin(encodePacket({
      id: id,
      isRequest: false,
      value: value
    }));
  };

  var handleRequest = function handleRequest(id, request) {
    var requestCallbacks, callback, errors;
    return regeneratorRuntime.async(function handleRequest$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;

            if (!(request.command === "ping")) {
              _context2.next = 4;
              break;
            }

            sendResponse(id, {});
            return _context2.abrupt("return");

          case 4:
            if (!(typeof request.key === "number")) {
              _context2.next = 13;
              break;
            }

            requestCallbacks = requestCallbacksByKey[request.key];

            if (requestCallbacks) {
              _context2.next = 8;
              break;
            }

            return _context2.abrupt("return");

          case 8:
            callback = requestCallbacks[request.command];

            if (!callback) {
              _context2.next = 13;
              break;
            }

            _context2.next = 12;
            return regeneratorRuntime.awrap(callback(id, request));

          case 12:
            return _context2.abrupt("return");

          case 13:
            throw new Error("Invalid command: " + request.command);

          case 16:
            _context2.prev = 16;
            _context2.t0 = _context2["catch"](0);
            errors = [extractErrorMessageV8(_context2.t0, streamIn, null, void 0, "")];

            try {
              sendResponse(id, {
                errors: errors
              });
            } catch (_unused) {}

          case 20:
          case "end":
            return _context2.stop();
        }
      }
    }, null, null, [[0, 16]]);
  };

  var isFirstPacket = true;

  var handleIncomingPacket = function handleIncomingPacket(bytes) {
    if (isFirstPacket) {
      isFirstPacket = false;
      var binaryVersion = String.fromCharCode.apply(String, _toConsumableArray(bytes));

      if (binaryVersion !== "0.25.5") {
        throw new Error("Cannot start service: Host version \"".concat("0.25.5", "\" does not match binary version ", quote(binaryVersion)));
      }

      return;
    }

    var packet = decodePacket(bytes);

    if (packet.isRequest) {
      handleRequest(packet.id, packet.value);
    } else {
      var callback = responseCallbacks[packet.id];
      delete responseCallbacks[packet.id];
      if (packet.value.error) callback(packet.value.error, {});else callback(null, packet.value);
    }
  };

  var buildOrContext = function buildOrContext(_ref) {
    var callName = _ref.callName,
        refs = _ref.refs,
        options = _ref.options,
        isTTY2 = _ref.isTTY,
        defaultWD2 = _ref.defaultWD,
        callback = _ref.callback;
    var refCount = 0;
    var buildKey = nextBuildKey++;
    var requestCallbacks = {};
    var buildRefs = {
      ref: function ref() {
        if (++refCount === 1) {
          if (refs) refs.ref();
        }
      },
      unref: function unref() {
        if (--refCount === 0) {
          delete requestCallbacksByKey[buildKey];
          if (refs) refs.unref();
        }
      }
    };
    requestCallbacksByKey[buildKey] = requestCallbacks;
    buildRefs.ref();
    buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, buildRefs, streamIn, requestCallbacks, options, isTTY2, defaultWD2, function (err, res) {
      try {
        callback(err, res);
      } finally {
        buildRefs.unref();
      }
    });
  };

  var transform2 = function transform2(_ref2) {
    var callName = _ref2.callName,
        refs = _ref2.refs,
        input = _ref2.input,
        options = _ref2.options,
        isTTY2 = _ref2.isTTY,
        fs3 = _ref2.fs,
        callback = _ref2.callback;
    var details = createObjectStash();

    var start = function start(inputPath) {
      try {
        if (typeof input !== "string" && !(input instanceof Uint8Array)) throw new Error('The input to "transform" must be a string or a Uint8Array');

        var _flagsForTransformOpt = flagsForTransformOptions(callName, options, isTTY2, transformLogLevelDefault),
            flags = _flagsForTransformOpt.flags,
            mangleCache = _flagsForTransformOpt.mangleCache;

        var request = {
          command: "transform",
          flags: flags,
          inputFS: inputPath !== null,
          input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
        };
        if (mangleCache) request.mangleCache = mangleCache;
        sendRequest(refs, request, function (error, response) {
          if (error) return callback(new Error(error), null);
          var errors = replaceDetailsInMessages(response.errors, details);
          var warnings = replaceDetailsInMessages(response.warnings, details);
          var outstanding = 1;

          var next = function next() {
            if (--outstanding === 0) {
              var result = {
                warnings: warnings,
                code: response.code,
                map: response.map,
                mangleCache: void 0,
                legalComments: void 0
              };
              if ("legalComments" in response) result.legalComments = response == null ? void 0 : response.legalComments;
              if (response.mangleCache) result.mangleCache = response == null ? void 0 : response.mangleCache;
              callback(null, result);
            }
          };

          if (errors.length > 0) return callback(failureErrorWithLog("Transform failed", errors, warnings), null);

          if (response.codeFS) {
            outstanding++;
            fs3.readFile(response.code, function (err, contents) {
              if (err !== null) {
                callback(err, null);
              } else {
                response.code = contents;
                next();
              }
            });
          }

          if (response.mapFS) {
            outstanding++;
            fs3.readFile(response.map, function (err, contents) {
              if (err !== null) {
                callback(err, null);
              } else {
                response.map = contents;
                next();
              }
            });
          }

          next();
        });
      } catch (e) {
        var _flags = [];

        try {
          pushLogFlags(_flags, options, {}, isTTY2, transformLogLevelDefault);
        } catch (_unused2) {}

        var error = extractErrorMessageV8(e, streamIn, details, void 0, "");
        sendRequest(refs, {
          command: "error",
          flags: _flags,
          error: error
        }, function () {
          error.detail = details.load(error.detail);
          callback(failureErrorWithLog("Transform failed", [error], []), null);
        });
      }
    };

    if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
      var next = start;

      start = function start() {
        return fs3.writeFile(input, next);
      };
    }

    start(null);
  };

  var formatMessages2 = function formatMessages2(_ref3) {
    var callName = _ref3.callName,
        refs = _ref3.refs,
        messages = _ref3.messages,
        options = _ref3.options,
        callback = _ref3.callback;
    if (!options) throw new Error("Missing second argument in ".concat(callName, "() call"));
    var keys = {};
    var kind = getFlag(options, keys, "kind", mustBeString);
    var color = getFlag(options, keys, "color", mustBeBoolean);
    var terminalWidth = getFlag(options, keys, "terminalWidth", mustBeInteger);
    checkForInvalidFlags(options, keys, "in ".concat(callName, "() call"));
    if (kind === void 0) throw new Error("Missing \"kind\" in ".concat(callName, "() call"));
    if (kind !== "error" && kind !== "warning") throw new Error("Expected \"kind\" to be \"error\" or \"warning\" in ".concat(callName, "() call"));
    var request = {
      command: "format-msgs",
      messages: sanitizeMessages(messages, "messages", null, "", terminalWidth),
      isWarning: kind === "warning"
    };
    if (color !== void 0) request.color = color;
    if (terminalWidth !== void 0) request.terminalWidth = terminalWidth;
    sendRequest(refs, request, function (error, response) {
      if (error) return callback(new Error(error), null);
      callback(null, response.messages);
    });
  };

  var analyzeMetafile2 = function analyzeMetafile2(_ref4) {
    var callName = _ref4.callName,
        refs = _ref4.refs,
        metafile = _ref4.metafile,
        options = _ref4.options,
        callback = _ref4.callback;
    if (options === void 0) options = {};
    var keys = {};
    var color = getFlag(options, keys, "color", mustBeBoolean);
    var verbose = getFlag(options, keys, "verbose", mustBeBoolean);
    checkForInvalidFlags(options, keys, "in ".concat(callName, "() call"));
    var request = {
      command: "analyze-metafile",
      metafile: metafile
    };
    if (color !== void 0) request.color = color;
    if (verbose !== void 0) request.verbose = verbose;
    sendRequest(refs, request, function (error, response) {
      if (error) return callback(new Error(error), null);
      callback(null, response.result);
    });
  };

  return {
    readFromStdout: readFromStdout,
    afterClose: afterClose,
    service: {
      buildOrContext: buildOrContext,
      transform: transform2,
      formatMessages: formatMessages2,
      analyzeMetafile: analyzeMetafile2
    }
  };
}

function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, isTTY2, defaultWD2, callback) {
  var details = createObjectStash();
  var isContext = callName === "context";

  var handleError = function handleError(e, pluginName) {
    var flags = [];

    try {
      pushLogFlags(flags, options, {}, isTTY2, buildLogLevelDefault);
    } catch (_unused3) {}

    var message = extractErrorMessageV8(e, streamIn, details, void 0, pluginName);
    sendRequest(refs, {
      command: "error",
      flags: flags,
      error: message
    }, function () {
      message.detail = details.load(message.detail);
      callback(failureErrorWithLog(isContext ? "Context failed" : "Build failed", [message], []), null);
    });
  };

  var plugins;

  if (_typeof(options) === "object") {
    var value = options.plugins;

    if (value !== void 0) {
      if (!Array.isArray(value)) return handleError(new Error("\"plugins\" must be an array"), "");
      plugins = value;
    }
  }

  if (plugins && plugins.length > 0) {
    if (streamIn.isSync) return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
    handlePlugins(buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, plugins, details).then(function (result) {
      if (!result.ok) return handleError(result.error, result.pluginName);

      try {
        buildOrContextContinue(result.requestPlugins, result.runOnEndCallbacks, result.scheduleOnDisposeCallbacks);
      } catch (e) {
        handleError(e, "");
      }
    }, function (e) {
      return handleError(e, "");
    });
    return;
  }

  try {
    buildOrContextContinue(null, function (result, done) {
      return done([], []);
    }, function () {});
  } catch (e) {
    handleError(e, "");
  }

  function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {
    var writeDefault = streamIn.hasFS;

    var _flagsForBuildOptions = flagsForBuildOptions(callName, options, isTTY2, buildLogLevelDefault, writeDefault),
        entries = _flagsForBuildOptions.entries,
        flags = _flagsForBuildOptions.flags,
        write = _flagsForBuildOptions.write,
        stdinContents = _flagsForBuildOptions.stdinContents,
        stdinResolveDir = _flagsForBuildOptions.stdinResolveDir,
        absWorkingDir = _flagsForBuildOptions.absWorkingDir,
        nodePaths = _flagsForBuildOptions.nodePaths,
        mangleCache = _flagsForBuildOptions.mangleCache;

    if (write && !streamIn.hasFS) throw new Error("The \"write\" option is unavailable in this environment");
    var request = {
      command: "build",
      key: buildKey,
      entries: entries,
      flags: flags,
      write: write,
      stdinContents: stdinContents,
      stdinResolveDir: stdinResolveDir,
      absWorkingDir: absWorkingDir || defaultWD2,
      nodePaths: nodePaths,
      context: isContext
    };
    if (requestPlugins) request.plugins = requestPlugins;
    if (mangleCache) request.mangleCache = mangleCache;

    var buildResponseToResult = function buildResponseToResult(response, callback2) {
      var result = {
        errors: replaceDetailsInMessages(response.errors, details),
        warnings: replaceDetailsInMessages(response.warnings, details),
        outputFiles: void 0,
        metafile: void 0,
        mangleCache: void 0
      };
      var originalErrors = result.errors.slice();
      var originalWarnings = result.warnings.slice();
      if (response.outputFiles) result.outputFiles = response.outputFiles.map(convertOutputFiles);
      if (response.metafile) result.metafile = JSON.parse(response.metafile);
      if (response.mangleCache) result.mangleCache = response.mangleCache;
      if (response.writeToStdout !== void 0) console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
      runOnEndCallbacks(result, function (onEndErrors, onEndWarnings) {
        if (originalErrors.length > 0 || onEndErrors.length > 0) {
          var error = failureErrorWithLog("Build failed", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));
          return callback2(error, null, onEndErrors, onEndWarnings);
        }

        callback2(null, result, onEndErrors, onEndWarnings);
      });
    };

    var latestResultPromise;
    var provideLatestResult;
    if (isContext) requestCallbacks["on-end"] = function (id, request2) {
      return new Promise(function (resolve) {
        buildResponseToResult(request2, function (err, result, onEndErrors, onEndWarnings) {
          var response = {
            errors: onEndErrors,
            warnings: onEndWarnings
          };
          if (provideLatestResult) provideLatestResult(err, result);
          latestResultPromise = void 0;
          provideLatestResult = void 0;
          sendResponse(id, response);
          resolve();
        });
      });
    };
    sendRequest(refs, request, function (error, response) {
      if (error) return callback(new Error(error), null);

      if (!isContext) {
        return buildResponseToResult(response, function (err, res) {
          scheduleOnDisposeCallbacks();
          return callback(err, res);
        });
      }

      if (response.errors.length > 0) {
        return callback(failureErrorWithLog("Context failed", response.errors, response.warnings), null);
      }

      var didDispose = false;
      var result = {
        rebuild: function rebuild() {
          if (!latestResultPromise) latestResultPromise = new Promise(function (resolve, reject) {
            var settlePromise;

            provideLatestResult = function provideLatestResult(err, result2) {
              if (!settlePromise) settlePromise = function settlePromise() {
                return err ? reject(err) : resolve(result2);
              };
            };

            var triggerAnotherBuild = function triggerAnotherBuild() {
              var request2 = {
                command: "rebuild",
                key: buildKey
              };
              sendRequest(refs, request2, function (error2, response2) {
                if (error2) {
                  reject(new Error(error2));
                } else if (settlePromise) {
                  settlePromise();
                } else {
                  triggerAnotherBuild();
                }
              });
            };

            triggerAnotherBuild();
          });
          return latestResultPromise;
        },
        watch: function watch() {
          var options2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          return new Promise(function (resolve, reject) {
            if (!streamIn.hasFS) throw new Error("Cannot use the \"watch\" API in this environment");
            var keys = {};
            checkForInvalidFlags(options2, keys, "in watch() call");
            var request2 = {
              command: "watch",
              key: buildKey
            };
            sendRequest(refs, request2, function (error2) {
              if (error2) reject(new Error(error2));else resolve(void 0);
            });
          });
        },
        serve: function serve() {
          var options2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          return new Promise(function (resolve, reject) {
            if (!streamIn.hasFS) throw new Error("Cannot use the \"serve\" API in this environment");
            var keys = {};
            var port = getFlag(options2, keys, "port", mustBeValidPortNumber);
            var host = getFlag(options2, keys, "host", mustBeString);
            var servedir = getFlag(options2, keys, "servedir", mustBeString);
            var keyfile = getFlag(options2, keys, "keyfile", mustBeString);
            var certfile = getFlag(options2, keys, "certfile", mustBeString);
            var fallback = getFlag(options2, keys, "fallback", mustBeString);
            var cors = getFlag(options2, keys, "cors", mustBeObject);
            var onRequest = getFlag(options2, keys, "onRequest", mustBeFunction);
            checkForInvalidFlags(options2, keys, "in serve() call");
            var request2 = {
              command: "serve",
              key: buildKey,
              onRequest: !!onRequest
            };
            if (port !== void 0) request2.port = port;
            if (host !== void 0) request2.host = host;
            if (servedir !== void 0) request2.servedir = servedir;
            if (keyfile !== void 0) request2.keyfile = keyfile;
            if (certfile !== void 0) request2.certfile = certfile;
            if (fallback !== void 0) request2.fallback = fallback;

            if (cors) {
              var corsKeys = {};
              var origin = getFlag(cors, corsKeys, "origin", mustBeStringOrArrayOfStrings);
              checkForInvalidFlags(cors, corsKeys, "on \"cors\" object");
              if (Array.isArray(origin)) request2.corsOrigin = origin;else if (origin !== void 0) request2.corsOrigin = [origin];
            }

            sendRequest(refs, request2, function (error2, response2) {
              if (error2) return reject(new Error(error2));

              if (onRequest) {
                requestCallbacks["serve-request"] = function (id, request3) {
                  onRequest(request3.args);
                  sendResponse(id, {});
                };
              }

              resolve(response2);
            });
          });
        },
        cancel: function cancel() {
          return new Promise(function (resolve) {
            if (didDispose) return resolve();
            var request2 = {
              command: "cancel",
              key: buildKey
            };
            sendRequest(refs, request2, function () {
              resolve();
            });
          });
        },
        dispose: function dispose() {
          return new Promise(function (resolve) {
            if (didDispose) return resolve();
            didDispose = true;
            var request2 = {
              command: "dispose",
              key: buildKey
            };
            sendRequest(refs, request2, function () {
              resolve();
              scheduleOnDisposeCallbacks();
              refs.unref();
            });
          });
        }
      };
      refs.ref();
      callback(null, result);
    });
  }
}

var handlePlugins = function handlePlugins(buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) {
  var onStartCallbacks, onEndCallbacks, onResolveCallbacks, onLoadCallbacks, onDisposeCallbacks, nextCallbackID, i, requestPlugins, isSetupDone, _iteratorNormalCompletion9, _didIteratorError9, _iteratorError9, _loop3, _iterator9, _step9, _ret, runOnEndCallbacks, scheduleOnDisposeCallbacks;

  return regeneratorRuntime.async(function handlePlugins$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          onStartCallbacks = [];
          onEndCallbacks = [];
          onResolveCallbacks = {};
          onLoadCallbacks = {};
          onDisposeCallbacks = [];
          nextCallbackID = 0;
          i = 0;
          requestPlugins = [];
          isSetupDone = false;
          plugins = _toConsumableArray(plugins);
          _iteratorNormalCompletion9 = true;
          _didIteratorError9 = false;
          _iteratorError9 = undefined;
          _context9.prev = 13;

          _loop3 = function _loop3() {
            var item, keys, name, setup, plugin, resolve, promise;
            return regeneratorRuntime.async(function _loop3$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    item = _step9.value;
                    keys = {};

                    if (!(_typeof(item) !== "object")) {
                      _context8.next = 4;
                      break;
                    }

                    throw new Error("Plugin at index ".concat(i, " must be an object"));

                  case 4:
                    name = getFlag(item, keys, "name", mustBeString);

                    if (!(typeof name !== "string" || name === "")) {
                      _context8.next = 7;
                      break;
                    }

                    throw new Error("Plugin at index ".concat(i, " is missing a name"));

                  case 7:
                    _context8.prev = 7;
                    setup = getFlag(item, keys, "setup", mustBeFunction);

                    if (!(typeof setup !== "function")) {
                      _context8.next = 11;
                      break;
                    }

                    throw new Error("Plugin is missing a setup function");

                  case 11:
                    checkForInvalidFlags(item, keys, "on plugin ".concat(quote(name)));
                    plugin = {
                      name: name,
                      onStart: false,
                      onEnd: false,
                      onResolve: [],
                      onLoad: []
                    };
                    i++;

                    resolve = function resolve(path3) {
                      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                      if (!isSetupDone) throw new Error('Cannot call "resolve" before plugin setup has completed');
                      if (typeof path3 !== "string") throw new Error("The path to resolve must be a string");
                      var keys2 =
                      /* @__PURE__ */
                      Object.create(null);
                      var pluginName = getFlag(options, keys2, "pluginName", mustBeString);
                      var importer = getFlag(options, keys2, "importer", mustBeString);
                      var namespace = getFlag(options, keys2, "namespace", mustBeString);
                      var resolveDir = getFlag(options, keys2, "resolveDir", mustBeString);
                      var kind = getFlag(options, keys2, "kind", mustBeString);
                      var pluginData = getFlag(options, keys2, "pluginData", canBeAnything);
                      var importAttributes = getFlag(options, keys2, "with", mustBeObject);
                      checkForInvalidFlags(options, keys2, "in resolve() call");
                      return new Promise(function (resolve2, reject) {
                        var request = {
                          command: "resolve",
                          path: path3,
                          key: buildKey,
                          pluginName: name
                        };
                        if (pluginName != null) request.pluginName = pluginName;
                        if (importer != null) request.importer = importer;
                        if (namespace != null) request.namespace = namespace;
                        if (resolveDir != null) request.resolveDir = resolveDir;
                        if (kind != null) request.kind = kind;else throw new Error("Must specify \"kind\" when calling \"resolve\"");
                        if (pluginData != null) request.pluginData = details.store(pluginData);
                        if (importAttributes != null) request["with"] = sanitizeStringMap(importAttributes, "with");
                        sendRequest(refs, request, function (error, response) {
                          if (error !== null) reject(new Error(error));else resolve2({
                            errors: replaceDetailsInMessages(response.errors, details),
                            warnings: replaceDetailsInMessages(response.warnings, details),
                            path: response.path,
                            external: response.external,
                            sideEffects: response.sideEffects,
                            namespace: response.namespace,
                            suffix: response.suffix,
                            pluginData: details.load(response.pluginData)
                          });
                        });
                      });
                    };

                    promise = setup({
                      initialOptions: initialOptions,
                      resolve: resolve,
                      onStart: function onStart(callback) {
                        var registeredText = "This error came from the \"onStart\" callback registered here:";
                        var registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
                        onStartCallbacks.push({
                          name: name,
                          callback: callback,
                          note: registeredNote
                        });
                        plugin.onStart = true;
                      },
                      onEnd: function onEnd(callback) {
                        var registeredText = "This error came from the \"onEnd\" callback registered here:";
                        var registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
                        onEndCallbacks.push({
                          name: name,
                          callback: callback,
                          note: registeredNote
                        });
                        plugin.onEnd = true;
                      },
                      onResolve: function onResolve(options, callback) {
                        var registeredText = "This error came from the \"onResolve\" callback registered here:";
                        var registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
                        var keys2 = {};
                        var filter = getFlag(options, keys2, "filter", mustBeRegExp);
                        var namespace = getFlag(options, keys2, "namespace", mustBeString);
                        checkForInvalidFlags(options, keys2, "in onResolve() call for plugin ".concat(quote(name)));
                        if (filter == null) throw new Error("onResolve() call is missing a filter");
                        var id = nextCallbackID++;
                        onResolveCallbacks[id] = {
                          name: name,
                          callback: callback,
                          note: registeredNote
                        };
                        plugin.onResolve.push({
                          id: id,
                          filter: jsRegExpToGoRegExp(filter),
                          namespace: namespace || ""
                        });
                      },
                      onLoad: function onLoad(options, callback) {
                        var registeredText = "This error came from the \"onLoad\" callback registered here:";
                        var registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
                        var keys2 = {};
                        var filter = getFlag(options, keys2, "filter", mustBeRegExp);
                        var namespace = getFlag(options, keys2, "namespace", mustBeString);
                        checkForInvalidFlags(options, keys2, "in onLoad() call for plugin ".concat(quote(name)));
                        if (filter == null) throw new Error("onLoad() call is missing a filter");
                        var id = nextCallbackID++;
                        onLoadCallbacks[id] = {
                          name: name,
                          callback: callback,
                          note: registeredNote
                        };
                        plugin.onLoad.push({
                          id: id,
                          filter: jsRegExpToGoRegExp(filter),
                          namespace: namespace || ""
                        });
                      },
                      onDispose: function onDispose(callback) {
                        onDisposeCallbacks.push(callback);
                      },
                      esbuild: streamIn.esbuild
                    });

                    if (!promise) {
                      _context8.next = 19;
                      break;
                    }

                    _context8.next = 19;
                    return regeneratorRuntime.awrap(promise);

                  case 19:
                    requestPlugins.push(plugin);
                    _context8.next = 25;
                    break;

                  case 22:
                    _context8.prev = 22;
                    _context8.t0 = _context8["catch"](7);
                    return _context8.abrupt("return", {
                      v: {
                        ok: false,
                        error: _context8.t0,
                        pluginName: name
                      }
                    });

                  case 25:
                  case "end":
                    return _context8.stop();
                }
              }
            }, null, null, [[7, 22]]);
          };

          _iterator9 = plugins[Symbol.iterator]();

        case 16:
          if (_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done) {
            _context9.next = 25;
            break;
          }

          _context9.next = 19;
          return regeneratorRuntime.awrap(_loop3());

        case 19:
          _ret = _context9.sent;

          if (!(_typeof(_ret) === "object")) {
            _context9.next = 22;
            break;
          }

          return _context9.abrupt("return", _ret.v);

        case 22:
          _iteratorNormalCompletion9 = true;
          _context9.next = 16;
          break;

        case 25:
          _context9.next = 31;
          break;

        case 27:
          _context9.prev = 27;
          _context9.t0 = _context9["catch"](13);
          _didIteratorError9 = true;
          _iteratorError9 = _context9.t0;

        case 31:
          _context9.prev = 31;
          _context9.prev = 32;

          if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
            _iterator9["return"]();
          }

        case 34:
          _context9.prev = 34;

          if (!_didIteratorError9) {
            _context9.next = 37;
            break;
          }

          throw _iteratorError9;

        case 37:
          return _context9.finish(34);

        case 38:
          return _context9.finish(31);

        case 39:
          requestCallbacks["on-start"] = function _callee2(id, request) {
            var response;
            return regeneratorRuntime.async(function _callee2$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    details.clear();
                    response = {
                      errors: [],
                      warnings: []
                    };
                    _context4.next = 4;
                    return regeneratorRuntime.awrap(Promise.all(onStartCallbacks.map(function _callee(_ref5) {
                      var name, callback, note, result, _response$errors, _response$warnings, keys, errors, warnings;

                      return regeneratorRuntime.async(function _callee$(_context3) {
                        while (1) {
                          switch (_context3.prev = _context3.next) {
                            case 0:
                              name = _ref5.name, callback = _ref5.callback, note = _ref5.note;
                              _context3.prev = 1;
                              _context3.next = 4;
                              return regeneratorRuntime.awrap(callback());

                            case 4:
                              result = _context3.sent;

                              if (!(result != null)) {
                                _context3.next = 14;
                                break;
                              }

                              if (!(_typeof(result) !== "object")) {
                                _context3.next = 8;
                                break;
                              }

                              throw new Error("Expected onStart() callback in plugin ".concat(quote(name), " to return an object"));

                            case 8:
                              keys = {};
                              errors = getFlag(result, keys, "errors", mustBeArray);
                              warnings = getFlag(result, keys, "warnings", mustBeArray);
                              checkForInvalidFlags(result, keys, "from onStart() callback in plugin ".concat(quote(name)));
                              if (errors != null) (_response$errors = response.errors).push.apply(_response$errors, _toConsumableArray(sanitizeMessages(errors, "errors", details, name, void 0)));
                              if (warnings != null) (_response$warnings = response.warnings).push.apply(_response$warnings, _toConsumableArray(sanitizeMessages(warnings, "warnings", details, name, void 0)));

                            case 14:
                              _context3.next = 19;
                              break;

                            case 16:
                              _context3.prev = 16;
                              _context3.t0 = _context3["catch"](1);
                              response.errors.push(extractErrorMessageV8(_context3.t0, streamIn, details, note && note(), name));

                            case 19:
                            case "end":
                              return _context3.stop();
                          }
                        }
                      }, null, null, [[1, 16]]);
                    })));

                  case 4:
                    sendResponse(id, response);

                  case 5:
                  case "end":
                    return _context4.stop();
                }
              }
            });
          };

          requestCallbacks["on-resolve"] = function _callee3(id, request) {
            var response, name, callback, note, _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, id2, _onResolveCallbacks$i, result, keys, pluginName, path3, namespace, suffix, external, sideEffects, pluginData, errors, warnings, watchFiles, watchDirs;

            return regeneratorRuntime.async(function _callee3$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    response = {}, name = "";
                    _iteratorNormalCompletion10 = true;
                    _didIteratorError10 = false;
                    _iteratorError10 = undefined;
                    _context5.prev = 4;
                    _iterator10 = request.ids[Symbol.iterator]();

                  case 6:
                    if (_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done) {
                      _context5.next = 54;
                      break;
                    }

                    id2 = _step10.value;
                    _context5.prev = 8;
                    _onResolveCallbacks$i = onResolveCallbacks[id2];
                    name = _onResolveCallbacks$i.name;
                    callback = _onResolveCallbacks$i.callback;
                    note = _onResolveCallbacks$i.note;
                    _context5.next = 15;
                    return regeneratorRuntime.awrap(callback({
                      path: request.path,
                      importer: request.importer,
                      namespace: request.namespace,
                      resolveDir: request.resolveDir,
                      kind: request.kind,
                      pluginData: details.load(request.pluginData),
                      "with": request["with"]
                    }));

                  case 15:
                    result = _context5.sent;

                    if (!(result != null)) {
                      _context5.next = 45;
                      break;
                    }

                    if (!(_typeof(result) !== "object")) {
                      _context5.next = 19;
                      break;
                    }

                    throw new Error("Expected onResolve() callback in plugin ".concat(quote(name), " to return an object"));

                  case 19:
                    keys = {};
                    pluginName = getFlag(result, keys, "pluginName", mustBeString);
                    path3 = getFlag(result, keys, "path", mustBeString);
                    namespace = getFlag(result, keys, "namespace", mustBeString);
                    suffix = getFlag(result, keys, "suffix", mustBeString);
                    external = getFlag(result, keys, "external", mustBeBoolean);
                    sideEffects = getFlag(result, keys, "sideEffects", mustBeBoolean);
                    pluginData = getFlag(result, keys, "pluginData", canBeAnything);
                    errors = getFlag(result, keys, "errors", mustBeArray);
                    warnings = getFlag(result, keys, "warnings", mustBeArray);
                    watchFiles = getFlag(result, keys, "watchFiles", mustBeArrayOfStrings);
                    watchDirs = getFlag(result, keys, "watchDirs", mustBeArrayOfStrings);
                    checkForInvalidFlags(result, keys, "from onResolve() callback in plugin ".concat(quote(name)));
                    response.id = id2;
                    if (pluginName != null) response.pluginName = pluginName;
                    if (path3 != null) response.path = path3;
                    if (namespace != null) response.namespace = namespace;
                    if (suffix != null) response.suffix = suffix;
                    if (external != null) response.external = external;
                    if (sideEffects != null) response.sideEffects = sideEffects;
                    if (pluginData != null) response.pluginData = details.store(pluginData);
                    if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
                    if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
                    if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                    if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                    return _context5.abrupt("break", 54);

                  case 45:
                    _context5.next = 51;
                    break;

                  case 47:
                    _context5.prev = 47;
                    _context5.t0 = _context5["catch"](8);
                    response = {
                      id: id2,
                      errors: [extractErrorMessageV8(_context5.t0, streamIn, details, note && note(), name)]
                    };
                    return _context5.abrupt("break", 54);

                  case 51:
                    _iteratorNormalCompletion10 = true;
                    _context5.next = 6;
                    break;

                  case 54:
                    _context5.next = 60;
                    break;

                  case 56:
                    _context5.prev = 56;
                    _context5.t1 = _context5["catch"](4);
                    _didIteratorError10 = true;
                    _iteratorError10 = _context5.t1;

                  case 60:
                    _context5.prev = 60;
                    _context5.prev = 61;

                    if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
                      _iterator10["return"]();
                    }

                  case 63:
                    _context5.prev = 63;

                    if (!_didIteratorError10) {
                      _context5.next = 66;
                      break;
                    }

                    throw _iteratorError10;

                  case 66:
                    return _context5.finish(63);

                  case 67:
                    return _context5.finish(60);

                  case 68:
                    sendResponse(id, response);

                  case 69:
                  case "end":
                    return _context5.stop();
                }
              }
            }, null, null, [[4, 56, 60, 68], [8, 47], [61,, 63, 67]]);
          };

          requestCallbacks["on-load"] = function _callee4(id, request) {
            var response, name, callback, note, _iteratorNormalCompletion11, _didIteratorError11, _iteratorError11, _iterator11, _step11, id2, _onLoadCallbacks$id, result, keys, pluginName, contents, resolveDir, pluginData, loader, errors, warnings, watchFiles, watchDirs;

            return regeneratorRuntime.async(function _callee4$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    response = {}, name = "";
                    _iteratorNormalCompletion11 = true;
                    _didIteratorError11 = false;
                    _iteratorError11 = undefined;
                    _context6.prev = 4;
                    _iterator11 = request.ids[Symbol.iterator]();

                  case 6:
                    if (_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done) {
                      _context6.next = 50;
                      break;
                    }

                    id2 = _step11.value;
                    _context6.prev = 8;
                    _onLoadCallbacks$id = onLoadCallbacks[id2];
                    name = _onLoadCallbacks$id.name;
                    callback = _onLoadCallbacks$id.callback;
                    note = _onLoadCallbacks$id.note;
                    _context6.next = 15;
                    return regeneratorRuntime.awrap(callback({
                      path: request.path,
                      namespace: request.namespace,
                      suffix: request.suffix,
                      pluginData: details.load(request.pluginData),
                      "with": request["with"]
                    }));

                  case 15:
                    result = _context6.sent;

                    if (!(result != null)) {
                      _context6.next = 41;
                      break;
                    }

                    if (!(_typeof(result) !== "object")) {
                      _context6.next = 19;
                      break;
                    }

                    throw new Error("Expected onLoad() callback in plugin ".concat(quote(name), " to return an object"));

                  case 19:
                    keys = {};
                    pluginName = getFlag(result, keys, "pluginName", mustBeString);
                    contents = getFlag(result, keys, "contents", mustBeStringOrUint8Array);
                    resolveDir = getFlag(result, keys, "resolveDir", mustBeString);
                    pluginData = getFlag(result, keys, "pluginData", canBeAnything);
                    loader = getFlag(result, keys, "loader", mustBeString);
                    errors = getFlag(result, keys, "errors", mustBeArray);
                    warnings = getFlag(result, keys, "warnings", mustBeArray);
                    watchFiles = getFlag(result, keys, "watchFiles", mustBeArrayOfStrings);
                    watchDirs = getFlag(result, keys, "watchDirs", mustBeArrayOfStrings);
                    checkForInvalidFlags(result, keys, "from onLoad() callback in plugin ".concat(quote(name)));
                    response.id = id2;
                    if (pluginName != null) response.pluginName = pluginName;
                    if (contents instanceof Uint8Array) response.contents = contents;else if (contents != null) response.contents = encodeUTF8(contents);
                    if (resolveDir != null) response.resolveDir = resolveDir;
                    if (pluginData != null) response.pluginData = details.store(pluginData);
                    if (loader != null) response.loader = loader;
                    if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
                    if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
                    if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                    if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                    return _context6.abrupt("break", 50);

                  case 41:
                    _context6.next = 47;
                    break;

                  case 43:
                    _context6.prev = 43;
                    _context6.t0 = _context6["catch"](8);
                    response = {
                      id: id2,
                      errors: [extractErrorMessageV8(_context6.t0, streamIn, details, note && note(), name)]
                    };
                    return _context6.abrupt("break", 50);

                  case 47:
                    _iteratorNormalCompletion11 = true;
                    _context6.next = 6;
                    break;

                  case 50:
                    _context6.next = 56;
                    break;

                  case 52:
                    _context6.prev = 52;
                    _context6.t1 = _context6["catch"](4);
                    _didIteratorError11 = true;
                    _iteratorError11 = _context6.t1;

                  case 56:
                    _context6.prev = 56;
                    _context6.prev = 57;

                    if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
                      _iterator11["return"]();
                    }

                  case 59:
                    _context6.prev = 59;

                    if (!_didIteratorError11) {
                      _context6.next = 62;
                      break;
                    }

                    throw _iteratorError11;

                  case 62:
                    return _context6.finish(59);

                  case 63:
                    return _context6.finish(56);

                  case 64:
                    sendResponse(id, response);

                  case 65:
                  case "end":
                    return _context6.stop();
                }
              }
            }, null, null, [[4, 52, 56, 64], [8, 43], [57,, 59, 63]]);
          };

          runOnEndCallbacks = function runOnEndCallbacks(result, done) {
            return done([], []);
          };

          if (onEndCallbacks.length > 0) {
            runOnEndCallbacks = function runOnEndCallbacks(result, done) {
              (function _callee5() {
                var onEndErrors, onEndWarnings, _iteratorNormalCompletion12, _didIteratorError12, _iteratorError12, _iterator12, _step12, _step12$value, name, callback, note, newErrors, newWarnings, value, keys, errors, warnings, _result$errors, _result$warnings;

                return regeneratorRuntime.async(function _callee5$(_context7) {
                  while (1) {
                    switch (_context7.prev = _context7.next) {
                      case 0:
                        onEndErrors = [];
                        onEndWarnings = [];
                        _iteratorNormalCompletion12 = true;
                        _didIteratorError12 = false;
                        _iteratorError12 = undefined;
                        _context7.prev = 5;
                        _iterator12 = onEndCallbacks[Symbol.iterator]();

                      case 7:
                        if (_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done) {
                          _context7.next = 34;
                          break;
                        }

                        _step12$value = _step12.value, name = _step12$value.name, callback = _step12$value.callback, note = _step12$value.note;
                        newErrors = void 0;
                        newWarnings = void 0;
                        _context7.prev = 11;
                        _context7.next = 14;
                        return regeneratorRuntime.awrap(callback(result));

                      case 14:
                        value = _context7.sent;

                        if (!(value != null)) {
                          _context7.next = 24;
                          break;
                        }

                        if (!(_typeof(value) !== "object")) {
                          _context7.next = 18;
                          break;
                        }

                        throw new Error("Expected onEnd() callback in plugin ".concat(quote(name), " to return an object"));

                      case 18:
                        keys = {};
                        errors = getFlag(value, keys, "errors", mustBeArray);
                        warnings = getFlag(value, keys, "warnings", mustBeArray);
                        checkForInvalidFlags(value, keys, "from onEnd() callback in plugin ".concat(quote(name)));
                        if (errors != null) newErrors = sanitizeMessages(errors, "errors", details, name, void 0);
                        if (warnings != null) newWarnings = sanitizeMessages(warnings, "warnings", details, name, void 0);

                      case 24:
                        _context7.next = 29;
                        break;

                      case 26:
                        _context7.prev = 26;
                        _context7.t0 = _context7["catch"](11);
                        newErrors = [extractErrorMessageV8(_context7.t0, streamIn, details, note && note(), name)];

                      case 29:
                        if (newErrors) {
                          onEndErrors.push.apply(onEndErrors, _toConsumableArray(newErrors));

                          try {
                            (_result$errors = result.errors).push.apply(_result$errors, _toConsumableArray(newErrors));
                          } catch (_unused4) {}
                        }

                        if (newWarnings) {
                          onEndWarnings.push.apply(onEndWarnings, _toConsumableArray(newWarnings));

                          try {
                            (_result$warnings = result.warnings).push.apply(_result$warnings, _toConsumableArray(newWarnings));
                          } catch (_unused5) {}
                        }

                      case 31:
                        _iteratorNormalCompletion12 = true;
                        _context7.next = 7;
                        break;

                      case 34:
                        _context7.next = 40;
                        break;

                      case 36:
                        _context7.prev = 36;
                        _context7.t1 = _context7["catch"](5);
                        _didIteratorError12 = true;
                        _iteratorError12 = _context7.t1;

                      case 40:
                        _context7.prev = 40;
                        _context7.prev = 41;

                        if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
                          _iterator12["return"]();
                        }

                      case 43:
                        _context7.prev = 43;

                        if (!_didIteratorError12) {
                          _context7.next = 46;
                          break;
                        }

                        throw _iteratorError12;

                      case 46:
                        return _context7.finish(43);

                      case 47:
                        return _context7.finish(40);

                      case 48:
                        done(onEndErrors, onEndWarnings);

                      case 49:
                      case "end":
                        return _context7.stop();
                    }
                  }
                }, null, null, [[5, 36, 40, 48], [11, 26], [41,, 43, 47]]);
              })();
            };
          }

          scheduleOnDisposeCallbacks = function scheduleOnDisposeCallbacks() {
            var _iteratorNormalCompletion13 = true;
            var _didIteratorError13 = false;
            var _iteratorError13 = undefined;

            try {
              var _loop2 = function _loop2() {
                var cb = _step13.value;
                setTimeout(function () {
                  return cb();
                }, 0);
              };

              for (var _iterator13 = onDisposeCallbacks[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                _loop2();
              }
            } catch (err) {
              _didIteratorError13 = true;
              _iteratorError13 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
                  _iterator13["return"]();
                }
              } finally {
                if (_didIteratorError13) {
                  throw _iteratorError13;
                }
              }
            }
          };

          isSetupDone = true;
          return _context9.abrupt("return", {
            ok: true,
            requestPlugins: requestPlugins,
            runOnEndCallbacks: runOnEndCallbacks,
            scheduleOnDisposeCallbacks: scheduleOnDisposeCallbacks
          });

        case 47:
        case "end":
          return _context9.stop();
      }
    }
  }, null, null, [[13, 27, 31, 39], [32,, 34, 38]]);
};

function createObjectStash() {
  var map =
  /* @__PURE__ */
  new Map();
  var nextID = 0;
  return {
    clear: function clear() {
      map.clear();
    },
    load: function load(id) {
      return map.get(id);
    },
    store: function store(value) {
      if (value === void 0) return -1;
      var id = nextID++;
      map.set(id, value);
      return id;
    }
  };
}

function extractCallerV8(e, streamIn, ident) {
  var note;
  var tried = false;
  return function () {
    if (tried) return note;
    tried = true;

    try {
      var lines = (e.stack + "").split("\n");
      lines.splice(1, 1);
      var location = parseStackLinesV8(streamIn, lines, ident);

      if (location) {
        note = {
          text: e.message,
          location: location
        };
        return note;
      }
    } catch (_unused6) {}
  };
}

function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {
  var text = "Internal error";
  var location = null;

  try {
    text = (e && e.message || e) + "";
  } catch (_unused7) {}

  try {
    location = parseStackLinesV8(streamIn, (e.stack + "").split("\n"), "");
  } catch (_unused8) {}

  return {
    id: "",
    pluginName: pluginName,
    text: text,
    location: location,
    notes: note ? [note] : [],
    detail: stash ? stash.store(e) : -1
  };
}

function parseStackLinesV8(streamIn, lines, ident) {
  var at = "    at ";

  if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {
    for (var _i3 = 1; _i3 < lines.length; _i3++) {
      var line = lines[_i3];
      if (!line.startsWith(at)) continue;
      line = line.slice(at.length);

      while (true) {
        var match = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);

        if (match) {
          line = match[1];
          continue;
        }

        match = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);

        if (match) {
          line = match[1];
          continue;
        }

        match = /^(\S+):(\d+):(\d+)$/.exec(line);

        if (match) {
          var contents = void 0;

          try {
            contents = streamIn.readFileSync(match[1], "utf8");
          } catch (_unused9) {
            break;
          }

          var lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match[2] - 1] || "";
          var column = +match[3] - 1;
          var length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
          return {
            file: match[1],
            namespace: "file",
            line: +match[2],
            column: encodeUTF8(lineText.slice(0, column)).length,
            length: encodeUTF8(lineText.slice(column, column + length)).length,
            lineText: lineText + "\n" + lines.slice(1).join("\n"),
            suggestion: ""
          };
        }

        break;
      }
    }
  }

  return null;
}

function failureErrorWithLog(text, errors, warnings) {
  var limit = 5;
  text += errors.length < 1 ? "" : " with ".concat(errors.length, " error").concat(errors.length < 2 ? "" : "s", ":") + errors.slice(0, limit + 1).map(function (e, i) {
    if (i === limit) return "\n...";
    if (!e.location) return "\nerror: ".concat(e.text);
    var _e$location = e.location,
        file = _e$location.file,
        line = _e$location.line,
        column = _e$location.column;
    var pluginText = e.pluginName ? "[plugin: ".concat(e.pluginName, "] ") : "";
    return "\n".concat(file, ":").concat(line, ":").concat(column, ": ERROR: ").concat(pluginText).concat(e.text);
  }).join("");
  var error = new Error(text);

  var _loop4 = function _loop4() {
    var _arr$_i = _slicedToArray(_arr[_i4], 2),
        key = _arr$_i[0],
        value = _arr$_i[1];

    Object.defineProperty(error, key, {
      configurable: true,
      enumerable: true,
      get: function get() {
        return value;
      },
      set: function set(value2) {
        return Object.defineProperty(error, key, {
          configurable: true,
          enumerable: true,
          value: value2
        });
      }
    });
  };

  for (var _i4 = 0, _arr = [["errors", errors], ["warnings", warnings]]; _i4 < _arr.length; _i4++) {
    _loop4();
  }

  return error;
}

function replaceDetailsInMessages(messages, stash) {
  var _iteratorNormalCompletion14 = true;
  var _didIteratorError14 = false;
  var _iteratorError14 = undefined;

  try {
    for (var _iterator14 = messages[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
      var message = _step14.value;
      message.detail = stash.load(message.detail);
    }
  } catch (err) {
    _didIteratorError14 = true;
    _iteratorError14 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
        _iterator14["return"]();
      }
    } finally {
      if (_didIteratorError14) {
        throw _iteratorError14;
      }
    }
  }

  return messages;
}

function sanitizeLocation(location, where, terminalWidth) {
  if (location == null) return null;
  var keys = {};
  var file = getFlag(location, keys, "file", mustBeString);
  var namespace = getFlag(location, keys, "namespace", mustBeString);
  var line = getFlag(location, keys, "line", mustBeInteger);
  var column = getFlag(location, keys, "column", mustBeInteger);
  var length = getFlag(location, keys, "length", mustBeInteger);
  var lineText = getFlag(location, keys, "lineText", mustBeString);
  var suggestion = getFlag(location, keys, "suggestion", mustBeString);
  checkForInvalidFlags(location, keys, where);

  if (lineText) {
    var relevantASCII = lineText.slice(0, (column && column > 0 ? column : 0) + (length && length > 0 ? length : 0) + (terminalWidth && terminalWidth > 0 ? terminalWidth : 80));

    if (!/[\x7F-\uFFFF]/.test(relevantASCII) && !/\n/.test(lineText)) {
      lineText = relevantASCII;
    }
  }

  return {
    file: file || "",
    namespace: namespace || "",
    line: line || 0,
    column: column || 0,
    length: length || 0,
    lineText: lineText || "",
    suggestion: suggestion || ""
  };
}

function sanitizeMessages(messages, property, stash, fallbackPluginName, terminalWidth) {
  var messagesClone = [];
  var index = 0;
  var _iteratorNormalCompletion15 = true;
  var _didIteratorError15 = false;
  var _iteratorError15 = undefined;

  try {
    for (var _iterator15 = messages[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
      var message = _step15.value;
      var keys = {};
      var id = getFlag(message, keys, "id", mustBeString);
      var pluginName = getFlag(message, keys, "pluginName", mustBeString);
      var text = getFlag(message, keys, "text", mustBeString);
      var location = getFlag(message, keys, "location", mustBeObjectOrNull);
      var notes = getFlag(message, keys, "notes", mustBeArray);
      var detail = getFlag(message, keys, "detail", canBeAnything);
      var where = "in element ".concat(index, " of \"").concat(property, "\"");
      checkForInvalidFlags(message, keys, where);
      var notesClone = [];

      if (notes) {
        var _iteratorNormalCompletion16 = true;
        var _didIteratorError16 = false;
        var _iteratorError16 = undefined;

        try {
          for (var _iterator16 = notes[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
            var note = _step16.value;
            var noteKeys = {};
            var noteText = getFlag(note, noteKeys, "text", mustBeString);
            var noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
            checkForInvalidFlags(note, noteKeys, where);
            notesClone.push({
              text: noteText || "",
              location: sanitizeLocation(noteLocation, where, terminalWidth)
            });
          }
        } catch (err) {
          _didIteratorError16 = true;
          _iteratorError16 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
              _iterator16["return"]();
            }
          } finally {
            if (_didIteratorError16) {
              throw _iteratorError16;
            }
          }
        }
      }

      messagesClone.push({
        id: id || "",
        pluginName: pluginName || fallbackPluginName,
        text: text || "",
        location: sanitizeLocation(location, where, terminalWidth),
        notes: notesClone,
        detail: stash ? stash.store(detail) : -1
      });
      index++;
    }
  } catch (err) {
    _didIteratorError15 = true;
    _iteratorError15 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
        _iterator15["return"]();
      }
    } finally {
      if (_didIteratorError15) {
        throw _iteratorError15;
      }
    }
  }

  return messagesClone;
}

function sanitizeStringArray(values, property) {
  var result = [];
  var _iteratorNormalCompletion17 = true;
  var _didIteratorError17 = false;
  var _iteratorError17 = undefined;

  try {
    for (var _iterator17 = values[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
      var value = _step17.value;
      if (typeof value !== "string") throw new Error("".concat(quote(property), " must be an array of strings"));
      result.push(value);
    }
  } catch (err) {
    _didIteratorError17 = true;
    _iteratorError17 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
        _iterator17["return"]();
      }
    } finally {
      if (_didIteratorError17) {
        throw _iteratorError17;
      }
    }
  }

  return result;
}

function sanitizeStringMap(map, property) {
  var result =
  /* @__PURE__ */
  Object.create(null);

  for (var key in map) {
    var value = map[key];
    if (typeof value !== "string") throw new Error("key ".concat(quote(key), " in object ").concat(quote(property), " must be a string"));
    result[key] = value;
  }

  return result;
}

function convertOutputFiles(_ref6) {
  var path3 = _ref6.path,
      contents = _ref6.contents,
      hash = _ref6.hash;
  var text = null;
  return {
    path: path3,
    contents: contents,
    hash: hash,

    get text() {
      var binary = this.contents;

      if (text === null || binary !== contents) {
        contents = binary;
        text = decodeUTF8(binary);
      }

      return text;
    }

  };
}

function jsRegExpToGoRegExp(regexp) {
  var result = regexp.source;
  if (regexp.flags) result = "(?".concat(regexp.flags, ")").concat(result);
  return result;
} // lib/npm/node-platform.ts


var fs = require("fs");

var os = require("os");

var path = require("path");

var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;

var isValidBinaryPath = function isValidBinaryPath(x) {
  return !!x && x !== "/usr/bin/esbuild";
};

var packageDarwin_arm64 = "@esbuild/darwin-arm64";
var packageDarwin_x64 = "@esbuild/darwin-x64";
var knownWindowsPackages = {
  "win32 arm64 LE": "@esbuild/win32-arm64",
  "win32 ia32 LE": "@esbuild/win32-ia32",
  "win32 x64 LE": "@esbuild/win32-x64"
};
var knownUnixlikePackages = {
  "aix ppc64 BE": "@esbuild/aix-ppc64",
  "android arm64 LE": "@esbuild/android-arm64",
  "darwin arm64 LE": "@esbuild/darwin-arm64",
  "darwin x64 LE": "@esbuild/darwin-x64",
  "freebsd arm64 LE": "@esbuild/freebsd-arm64",
  "freebsd x64 LE": "@esbuild/freebsd-x64",
  "linux arm LE": "@esbuild/linux-arm",
  "linux arm64 LE": "@esbuild/linux-arm64",
  "linux ia32 LE": "@esbuild/linux-ia32",
  "linux mips64el LE": "@esbuild/linux-mips64el",
  "linux ppc64 LE": "@esbuild/linux-ppc64",
  "linux riscv64 LE": "@esbuild/linux-riscv64",
  "linux s390x BE": "@esbuild/linux-s390x",
  "linux x64 LE": "@esbuild/linux-x64",
  "linux loong64 LE": "@esbuild/linux-loong64",
  "netbsd arm64 LE": "@esbuild/netbsd-arm64",
  "netbsd x64 LE": "@esbuild/netbsd-x64",
  "openbsd arm64 LE": "@esbuild/openbsd-arm64",
  "openbsd x64 LE": "@esbuild/openbsd-x64",
  "sunos x64 LE": "@esbuild/sunos-x64"
};
var knownWebAssemblyFallbackPackages = {
  "android arm LE": "@esbuild/android-arm",
  "android x64 LE": "@esbuild/android-x64"
};

function pkgAndSubpathForCurrentPlatform() {
  var pkg;
  var subpath;
  var isWASM = false;
  var platformKey = "".concat(process.platform, " ").concat(os.arch(), " ").concat(os.endianness());

  if (platformKey in knownWindowsPackages) {
    pkg = knownWindowsPackages[platformKey];
    subpath = "esbuild.exe";
  } else if (platformKey in knownUnixlikePackages) {
    pkg = knownUnixlikePackages[platformKey];
    subpath = "bin/esbuild";
  } else if (platformKey in knownWebAssemblyFallbackPackages) {
    pkg = knownWebAssemblyFallbackPackages[platformKey];
    subpath = "bin/esbuild";
    isWASM = true;
  } else {
    throw new Error("Unsupported platform: ".concat(platformKey));
  }

  return {
    pkg: pkg,
    subpath: subpath,
    isWASM: isWASM
  };
}

function pkgForSomeOtherPlatform() {
  var libMainJS = require.resolve("esbuild");

  var nodeModulesDirectory = path.dirname(path.dirname(path.dirname(libMainJS)));

  if (path.basename(nodeModulesDirectory) === "node_modules") {
    for (var unixKey in knownUnixlikePackages) {
      try {
        var pkg = knownUnixlikePackages[unixKey];
        if (fs.existsSync(path.join(nodeModulesDirectory, pkg))) return pkg;
      } catch (_unused10) {}
    }

    for (var windowsKey in knownWindowsPackages) {
      try {
        var _pkg = knownWindowsPackages[windowsKey];
        if (fs.existsSync(path.join(nodeModulesDirectory, _pkg))) return _pkg;
      } catch (_unused11) {}
    }
  }

  return null;
}

function downloadedBinPath(pkg, subpath) {
  var esbuildLibDir = path.dirname(require.resolve("esbuild"));
  return path.join(esbuildLibDir, "downloaded-".concat(pkg.replace("/", "-"), "-").concat(path.basename(subpath)));
}

function generateBinPath() {
  if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
    if (!fs.existsSync(ESBUILD_BINARY_PATH)) {
      console.warn("[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=".concat(ESBUILD_BINARY_PATH));
    } else {
      return {
        binPath: ESBUILD_BINARY_PATH,
        isWASM: false
      };
    }
  }

  var _pkgAndSubpathForCurr = pkgAndSubpathForCurrentPlatform(),
      pkg = _pkgAndSubpathForCurr.pkg,
      subpath = _pkgAndSubpathForCurr.subpath,
      isWASM = _pkgAndSubpathForCurr.isWASM;

  var binPath;

  try {
    binPath = require.resolve("".concat(pkg, "/").concat(subpath));
  } catch (e) {
    binPath = downloadedBinPath(pkg, subpath);

    if (!fs.existsSync(binPath)) {
      try {
        require.resolve(pkg);
      } catch (_unused12) {
        var otherPkg = pkgForSomeOtherPlatform();

        if (otherPkg) {
          var suggestions = "\nSpecifically the \"".concat(otherPkg, "\" package is present but this platform\nneeds the \"").concat(pkg, "\" package instead. People often get into this\nsituation by installing esbuild on Windows or macOS and copying \"node_modules\"\ninto a Docker image that runs Linux, or by copying \"node_modules\" between\nWindows and WSL environments.\n\nIf you are installing with npm, you can try not copying the \"node_modules\"\ndirectory when you copy the files over, and running \"npm ci\" or \"npm install\"\non the destination platform after the copy. Or you could consider using yarn\ninstead of npm which has built-in support for installing a package on multiple\nplatforms simultaneously.\n\nIf you are installing with yarn, you can try listing both this platform and the\nother platform in your \".yarnrc.yml\" file using the \"supportedArchitectures\"\nfeature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures\nKeep in mind that this means multiple copies of esbuild will be present.\n");

          if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
            suggestions = "\nSpecifically the \"".concat(otherPkg, "\" package is present but this platform\nneeds the \"").concat(pkg, "\" package instead. People often get into this\nsituation by installing esbuild with npm running inside of Rosetta 2 and then\ntrying to use it with node running outside of Rosetta 2, or vice versa (Rosetta\n2 is Apple's on-the-fly x86_64-to-arm64 translation service).\n\nIf you are installing with npm, you can try ensuring that both npm and node are\nnot running under Rosetta 2 and then reinstalling esbuild. This likely involves\nchanging how you installed npm and/or node. For example, installing node with\nthe universal installer here should work: https://nodejs.org/en/download/. Or\nyou could consider using yarn instead of npm which has built-in support for\ninstalling a package on multiple platforms simultaneously.\n\nIf you are installing with yarn, you can try listing both \"arm64\" and \"x64\"\nin your \".yarnrc.yml\" file using the \"supportedArchitectures\" feature:\nhttps://yarnpkg.com/configuration/yarnrc/#supportedArchitectures\nKeep in mind that this means multiple copies of esbuild will be present.\n");
          }

          throw new Error("\nYou installed esbuild for another platform than the one you're currently using.\nThis won't work because esbuild is written with native code and needs to\ninstall a platform-specific binary executable.\n".concat(suggestions, "\nAnother alternative is to use the \"esbuild-wasm\" package instead, which works\nthe same way on all platforms. But it comes with a heavy performance cost and\ncan sometimes be 10x slower than the \"esbuild\" package, so you may also not\nwant to do that.\n"));
        }

        throw new Error("The package \"".concat(pkg, "\" could not be found, and is needed by esbuild.\n\nIf you are installing esbuild with npm, make sure that you don't specify the\n\"--no-optional\" or \"--omit=optional\" flags. The \"optionalDependencies\" feature\nof \"package.json\" is used by esbuild to install the correct binary executable\nfor your current platform."));
      }

      throw e;
    }
  }

  if (/\.zip\//.test(binPath)) {
    var pnpapi;

    try {
      pnpapi = require("pnpapi");
    } catch (e) {}

    if (pnpapi) {
      var root = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
      var binTargetPath = path.join(root, "node_modules", ".cache", "esbuild", "pnpapi-".concat(pkg.replace("/", "-"), "-", "0.25.5", "-").concat(path.basename(subpath)));

      if (!fs.existsSync(binTargetPath)) {
        fs.mkdirSync(path.dirname(binTargetPath), {
          recursive: true
        });
        fs.copyFileSync(binPath, binTargetPath);
        fs.chmodSync(binTargetPath, 493);
      }

      return {
        binPath: binTargetPath,
        isWASM: isWASM
      };
    }
  }

  return {
    binPath: binPath,
    isWASM: isWASM
  };
} // lib/npm/node.ts


var child_process = require("child_process");

var crypto = require("crypto");

var path2 = require("path");

var fs2 = require("fs");

var os2 = require("os");

var tty = require("tty");

var worker_threads;

if (process.env.ESBUILD_WORKER_THREADS !== "0") {
  try {
    worker_threads = require("worker_threads");
  } catch (_unused13) {}

  var _process$versions$nod = process.versions.node.split("."),
      _process$versions$nod2 = _slicedToArray(_process$versions$nod, 2),
      major = _process$versions$nod2[0],
      minor = _process$versions$nod2[1];

  if ( // <v12.17.0 does not work
  +major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13) {
    worker_threads = void 0;
  }
}

var _a;

var isInternalWorkerThread = ((_a = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a.esbuildVersion) === "0.25.5";

var esbuildCommandAndArgs = function esbuildCommandAndArgs() {
  if ((!ESBUILD_BINARY_PATH || false) && (path2.basename(__filename) !== "main.js" || path2.basename(__dirname) !== "lib")) {
    throw new Error("The esbuild JavaScript API cannot be bundled. Please mark the \"esbuild\" package as external so it's not included in the bundle.\n\nMore information: The file containing the code for esbuild's JavaScript API (".concat(__filename, ") does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found."));
  }

  if (false) {
    return ["node", [path2.join(__dirname, "..", "bin", "esbuild")]];
  } else {
    var _generateBinPath = generateBinPath(),
        binPath = _generateBinPath.binPath,
        isWASM = _generateBinPath.isWASM;

    if (isWASM) {
      return ["node", [binPath]];
    } else {
      return [binPath, []];
    }
  }
};

var isTTY = function isTTY() {
  return tty.isatty(2);
};

var fsSync = {
  readFile: function readFile(tempFile, callback) {
    try {
      var contents = fs2.readFileSync(tempFile, "utf8");

      try {
        fs2.unlinkSync(tempFile);
      } catch (_unused14) {}

      callback(null, contents);
    } catch (err) {
      callback(err, null);
    }
  },
  writeFile: function writeFile(contents, callback) {
    try {
      var tempFile = randomFileName();
      fs2.writeFileSync(tempFile, contents);
      callback(tempFile);
    } catch (_unused15) {
      callback(null);
    }
  }
};
var fsAsync = {
  readFile: function readFile(tempFile, callback) {
    try {
      fs2.readFile(tempFile, "utf8", function (err, contents) {
        try {
          fs2.unlink(tempFile, function () {
            return callback(err, contents);
          });
        } catch (_unused16) {
          callback(err, contents);
        }
      });
    } catch (err) {
      callback(err, null);
    }
  },
  writeFile: function writeFile(contents, callback) {
    try {
      var tempFile = randomFileName();
      fs2.writeFile(tempFile, contents, function (err) {
        return err !== null ? callback(null) : callback(tempFile);
      });
    } catch (_unused17) {
      callback(null);
    }
  }
};
var _version = "0.25.5";

var _build = function _build(options) {
  return ensureServiceIsRunning().build(options);
};

var _context = function _context(buildOptions) {
  return ensureServiceIsRunning().context(buildOptions);
};

var _transform = function _transform(input, options) {
  return ensureServiceIsRunning().transform(input, options);
};

var _formatMessages = function _formatMessages(messages, options) {
  return ensureServiceIsRunning().formatMessages(messages, options);
};

var _analyzeMetafile = function _analyzeMetafile(messages, options) {
  return ensureServiceIsRunning().analyzeMetafile(messages, options);
};

var _buildSync = function _buildSync(options) {
  if (worker_threads && !isInternalWorkerThread) {
    if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
    return workerThreadService.buildSync(options);
  }

  var result;
  runServiceSync(function (service) {
    return service.buildOrContext({
      callName: "buildSync",
      refs: null,
      options: options,
      isTTY: isTTY(),
      defaultWD: defaultWD,
      callback: function callback(err, res) {
        if (err) throw err;
        result = res;
      }
    });
  });
  return result;
};

var _transformSync = function _transformSync(input, options) {
  if (worker_threads && !isInternalWorkerThread) {
    if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
    return workerThreadService.transformSync(input, options);
  }

  var result;
  runServiceSync(function (service) {
    return service.transform({
      callName: "transformSync",
      refs: null,
      input: input,
      options: options || {},
      isTTY: isTTY(),
      fs: fsSync,
      callback: function callback(err, res) {
        if (err) throw err;
        result = res;
      }
    });
  });
  return result;
};

var _formatMessagesSync = function _formatMessagesSync(messages, options) {
  if (worker_threads && !isInternalWorkerThread) {
    if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
    return workerThreadService.formatMessagesSync(messages, options);
  }

  var result;
  runServiceSync(function (service) {
    return service.formatMessages({
      callName: "formatMessagesSync",
      refs: null,
      messages: messages,
      options: options,
      callback: function callback(err, res) {
        if (err) throw err;
        result = res;
      }
    });
  });
  return result;
};

var _analyzeMetafileSync = function _analyzeMetafileSync(metafile, options) {
  if (worker_threads && !isInternalWorkerThread) {
    if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
    return workerThreadService.analyzeMetafileSync(metafile, options);
  }

  var result;
  runServiceSync(function (service) {
    return service.analyzeMetafile({
      callName: "analyzeMetafileSync",
      refs: null,
      metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
      options: options,
      callback: function callback(err, res) {
        if (err) throw err;
        result = res;
      }
    });
  });
  return result;
};

var _stop = function _stop() {
  if (_stopService) _stopService();
  if (workerThreadService) workerThreadService.stop();
  return Promise.resolve();
};

var initializeWasCalled = false;

var _initialize = function _initialize(options) {
  options = validateInitializeOptions(options || {});
  if (options.wasmURL) throw new Error("The \"wasmURL\" option only works in the browser");
  if (options.wasmModule) throw new Error("The \"wasmModule\" option only works in the browser");
  if (options.worker) throw new Error("The \"worker\" option only works in the browser");
  if (initializeWasCalled) throw new Error('Cannot call "initialize" more than once');
  ensureServiceIsRunning();
  initializeWasCalled = true;
  return Promise.resolve();
};

var defaultWD = process.cwd();
var longLivedService;

var _stopService;

var ensureServiceIsRunning = function ensureServiceIsRunning() {
  if (longLivedService) return longLivedService;

  var _esbuildCommandAndArg = esbuildCommandAndArgs(),
      _esbuildCommandAndArg2 = _slicedToArray(_esbuildCommandAndArg, 2),
      command = _esbuildCommandAndArg2[0],
      args = _esbuildCommandAndArg2[1];

  var child = child_process.spawn(command, args.concat("--service=".concat("0.25.5"), "--ping"), {
    windowsHide: true,
    stdio: ["pipe", "pipe", "inherit"],
    cwd: defaultWD
  });

  var _createChannel = createChannel({
    writeToStdin: function writeToStdin(bytes) {
      child.stdin.write(bytes, function (err) {
        if (err) afterClose(err);
      });
    },
    readFileSync: fs2.readFileSync,
    isSync: false,
    hasFS: true,
    esbuild: node_exports
  }),
      readFromStdout = _createChannel.readFromStdout,
      afterClose = _createChannel.afterClose,
      service = _createChannel.service;

  child.stdin.on("error", afterClose);
  child.on("error", afterClose);
  var stdin = child.stdin;
  var stdout = child.stdout;
  stdout.on("data", readFromStdout);
  stdout.on("end", afterClose);

  _stopService = function stopService() {
    stdin.destroy();
    stdout.destroy();
    child.kill();
    initializeWasCalled = false;
    longLivedService = void 0;
    _stopService = void 0;
  };

  var refCount = 0;
  child.unref();

  if (stdin.unref) {
    stdin.unref();
  }

  if (stdout.unref) {
    stdout.unref();
  }

  var refs = {
    ref: function ref() {
      if (++refCount === 1) child.ref();
    },
    unref: function unref() {
      if (--refCount === 0) child.unref();
    }
  };
  longLivedService = {
    build: function build(options) {
      return new Promise(function (resolve, reject) {
        service.buildOrContext({
          callName: "build",
          refs: refs,
          options: options,
          isTTY: isTTY(),
          defaultWD: defaultWD,
          callback: function callback(err, res) {
            return err ? reject(err) : resolve(res);
          }
        });
      });
    },
    context: function context(options) {
      return new Promise(function (resolve, reject) {
        return service.buildOrContext({
          callName: "context",
          refs: refs,
          options: options,
          isTTY: isTTY(),
          defaultWD: defaultWD,
          callback: function callback(err, res) {
            return err ? reject(err) : resolve(res);
          }
        });
      });
    },
    transform: function transform(input, options) {
      return new Promise(function (resolve, reject) {
        return service.transform({
          callName: "transform",
          refs: refs,
          input: input,
          options: options || {},
          isTTY: isTTY(),
          fs: fsAsync,
          callback: function callback(err, res) {
            return err ? reject(err) : resolve(res);
          }
        });
      });
    },
    formatMessages: function formatMessages(messages, options) {
      return new Promise(function (resolve, reject) {
        return service.formatMessages({
          callName: "formatMessages",
          refs: refs,
          messages: messages,
          options: options,
          callback: function callback(err, res) {
            return err ? reject(err) : resolve(res);
          }
        });
      });
    },
    analyzeMetafile: function analyzeMetafile(metafile, options) {
      return new Promise(function (resolve, reject) {
        return service.analyzeMetafile({
          callName: "analyzeMetafile",
          refs: refs,
          metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
          options: options,
          callback: function callback(err, res) {
            return err ? reject(err) : resolve(res);
          }
        });
      });
    }
  };
  return longLivedService;
};

var runServiceSync = function runServiceSync(callback) {
  var _esbuildCommandAndArg3 = esbuildCommandAndArgs(),
      _esbuildCommandAndArg4 = _slicedToArray(_esbuildCommandAndArg3, 2),
      command = _esbuildCommandAndArg4[0],
      args = _esbuildCommandAndArg4[1];

  var stdin = new Uint8Array();

  var _createChannel2 = createChannel({
    writeToStdin: function writeToStdin(bytes) {
      if (stdin.length !== 0) throw new Error("Must run at most one command");
      stdin = bytes;
    },
    isSync: true,
    hasFS: true,
    esbuild: node_exports
  }),
      readFromStdout = _createChannel2.readFromStdout,
      afterClose = _createChannel2.afterClose,
      service = _createChannel2.service;

  callback(service);
  var stdout = child_process.execFileSync(command, args.concat("--service=".concat("0.25.5")), {
    cwd: defaultWD,
    windowsHide: true,
    input: stdin,
    // We don't know how large the output could be. If it's too large, the
    // command will fail with ENOBUFS. Reserve 16mb for now since that feels
    // like it should be enough. Also allow overriding this with an environment
    // variable.
    maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
  });
  readFromStdout(stdout);
  afterClose(null);
};

var randomFileName = function randomFileName() {
  return path2.join(os2.tmpdir(), "esbuild-".concat(crypto.randomBytes(32).toString("hex")));
};

var workerThreadService = null;

var startWorkerThreadService = function startWorkerThreadService(worker_threads2) {
  var _ref7 = new worker_threads2.MessageChannel(),
      mainPort = _ref7.port1,
      workerPort = _ref7.port2;

  var worker = new worker_threads2.Worker(__filename, {
    workerData: {
      workerPort: workerPort,
      defaultWD: defaultWD,
      esbuildVersion: "0.25.5"
    },
    transferList: [workerPort],
    // From node's documentation: https://nodejs.org/api/worker_threads.html
    //
    //   Take care when launching worker threads from preload scripts (scripts loaded
    //   and run using the `-r` command line flag). Unless the `execArgv` option is
    //   explicitly set, new Worker threads automatically inherit the command line flags
    //   from the running process and will preload the same preload scripts as the main
    //   thread. If the preload script unconditionally launches a worker thread, every
    //   thread spawned will spawn another until the application crashes.
    //
    execArgv: []
  });
  var nextID = 0;

  var fakeBuildError = function fakeBuildError(text) {
    var error = new Error("Build failed with 1 error:\nerror: ".concat(text));
    var errors = [{
      id: "",
      pluginName: "",
      text: text,
      location: null,
      notes: [],
      detail: void 0
    }];
    error.errors = errors;
    error.warnings = [];
    return error;
  };

  var validateBuildSyncOptions = function validateBuildSyncOptions(options) {
    if (!options) return;
    var plugins = options.plugins;
    if (plugins && plugins.length > 0) throw fakeBuildError("Cannot use plugins in synchronous API calls");
  };

  var applyProperties = function applyProperties(object, properties) {
    for (var key in properties) {
      object[key] = properties[key];
    }
  };

  var runCallSync = function runCallSync(command, args) {
    var id = nextID++;
    var sharedBuffer = new SharedArrayBuffer(8);
    var sharedBufferView = new Int32Array(sharedBuffer);
    var msg = {
      sharedBuffer: sharedBuffer,
      id: id,
      command: command,
      args: args
    };
    worker.postMessage(msg);
    var status = Atomics.wait(sharedBufferView, 0, 0);
    if (status !== "ok" && status !== "not-equal") throw new Error("Internal error: Atomics.wait() failed: " + status);

    var _worker_threads2$rece = worker_threads2.receiveMessageOnPort(mainPort),
        _worker_threads2$rece2 = _worker_threads2$rece.message,
        id2 = _worker_threads2$rece2.id,
        resolve = _worker_threads2$rece2.resolve,
        reject = _worker_threads2$rece2.reject,
        properties = _worker_threads2$rece2.properties;

    if (id !== id2) throw new Error("Internal error: Expected id ".concat(id, " but got id ").concat(id2));

    if (reject) {
      applyProperties(reject, properties);
      throw reject;
    }

    return resolve;
  };

  worker.unref();
  return {
    buildSync: function buildSync(options) {
      validateBuildSyncOptions(options);
      return runCallSync("build", [options]);
    },
    transformSync: function transformSync(input, options) {
      return runCallSync("transform", [input, options]);
    },
    formatMessagesSync: function formatMessagesSync(messages, options) {
      return runCallSync("formatMessages", [messages, options]);
    },
    analyzeMetafileSync: function analyzeMetafileSync(metafile, options) {
      return runCallSync("analyzeMetafile", [metafile, options]);
    },
    stop: function stop() {
      worker.terminate();
      workerThreadService = null;
    }
  };
};

var startSyncServiceWorker = function startSyncServiceWorker() {
  var workerPort = worker_threads.workerData.workerPort;
  var parentPort = worker_threads.parentPort;

  var extractProperties = function extractProperties(object) {
    var properties = {};

    if (object && _typeof(object) === "object") {
      for (var key in object) {
        properties[key] = object[key];
      }
    }

    return properties;
  };

  try {
    var service = ensureServiceIsRunning();
    defaultWD = worker_threads.workerData.defaultWD;
    parentPort.on("message", function (msg) {
      (function _callee6() {
        var sharedBuffer, id, command, args, sharedBufferView;
        return regeneratorRuntime.async(function _callee6$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                sharedBuffer = msg.sharedBuffer, id = msg.id, command = msg.command, args = msg.args;
                sharedBufferView = new Int32Array(sharedBuffer);
                _context10.prev = 2;
                _context10.t0 = command;
                _context10.next = _context10.t0 === "build" ? 6 : _context10.t0 === "transform" ? 14 : _context10.t0 === "formatMessages" ? 22 : _context10.t0 === "analyzeMetafile" ? 30 : 38;
                break;

              case 6:
                _context10.t1 = workerPort;
                _context10.t2 = id;
                _context10.next = 10;
                return regeneratorRuntime.awrap(service.build(args[0]));

              case 10:
                _context10.t3 = _context10.sent;
                _context10.t4 = {
                  id: _context10.t2,
                  resolve: _context10.t3
                };

                _context10.t1.postMessage.call(_context10.t1, _context10.t4);

                return _context10.abrupt("break", 39);

              case 14:
                _context10.t5 = workerPort;
                _context10.t6 = id;
                _context10.next = 18;
                return regeneratorRuntime.awrap(service.transform(args[0], args[1]));

              case 18:
                _context10.t7 = _context10.sent;
                _context10.t8 = {
                  id: _context10.t6,
                  resolve: _context10.t7
                };

                _context10.t5.postMessage.call(_context10.t5, _context10.t8);

                return _context10.abrupt("break", 39);

              case 22:
                _context10.t9 = workerPort;
                _context10.t10 = id;
                _context10.next = 26;
                return regeneratorRuntime.awrap(service.formatMessages(args[0], args[1]));

              case 26:
                _context10.t11 = _context10.sent;
                _context10.t12 = {
                  id: _context10.t10,
                  resolve: _context10.t11
                };

                _context10.t9.postMessage.call(_context10.t9, _context10.t12);

                return _context10.abrupt("break", 39);

              case 30:
                _context10.t13 = workerPort;
                _context10.t14 = id;
                _context10.next = 34;
                return regeneratorRuntime.awrap(service.analyzeMetafile(args[0], args[1]));

              case 34:
                _context10.t15 = _context10.sent;
                _context10.t16 = {
                  id: _context10.t14,
                  resolve: _context10.t15
                };

                _context10.t13.postMessage.call(_context10.t13, _context10.t16);

                return _context10.abrupt("break", 39);

              case 38:
                throw new Error("Invalid command: ".concat(command));

              case 39:
                _context10.next = 44;
                break;

              case 41:
                _context10.prev = 41;
                _context10.t17 = _context10["catch"](2);
                workerPort.postMessage({
                  id: id,
                  reject: _context10.t17,
                  properties: extractProperties(_context10.t17)
                });

              case 44:
                Atomics.add(sharedBufferView, 0, 1);
                Atomics.notify(sharedBufferView, 0, Infinity);

              case 46:
              case "end":
                return _context10.stop();
            }
          }
        }, null, null, [[2, 41]]);
      })();
    });
  } catch (reject) {
    parentPort.on("message", function (msg) {
      var sharedBuffer = msg.sharedBuffer,
          id = msg.id;
      var sharedBufferView = new Int32Array(sharedBuffer);
      workerPort.postMessage({
        id: id,
        reject: reject,
        properties: extractProperties(reject)
      });
      Atomics.add(sharedBufferView, 0, 1);
      Atomics.notify(sharedBufferView, 0, Infinity);
    });
  }
};

if (isInternalWorkerThread) {
  startSyncServiceWorker();
}

var node_default = node_exports; // Annotate the CommonJS export names for ESM import in node:

0 && (module.exports = {
  analyzeMetafile: _analyzeMetafile,
  analyzeMetafileSync: _analyzeMetafileSync,
  build: _build,
  buildSync: _buildSync,
  context: _context,
  formatMessages: _formatMessages,
  formatMessagesSync: _formatMessagesSync,
  initialize: _initialize,
  stop: _stop,
  transform: _transform,
  transformSync: _transformSync,
  version: _version
});