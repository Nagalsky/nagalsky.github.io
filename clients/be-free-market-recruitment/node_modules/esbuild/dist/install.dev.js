"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;

var __copyProps = function __copyProps(to, from, except, desc) {
  if (from && _typeof(from) === "object" || typeof from === "function") {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      var _loop = function _loop() {
        var key = _step.value;
        if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
          get: function get() {
            return from[key];
          },
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
      };

      for (var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return to;
};

var __toESM = function __toESM(mod, isNodeMode, target) {
  return target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps( // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod);
}; // lib/npm/node-platform.ts


var fs = require("fs");

var os = require("os");

var path = require("path");

var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;

var isValidBinaryPath = function isValidBinaryPath(x) {
  return !!x && x !== "/usr/bin/esbuild";
};

var knownWindowsPackages = {
  "win32 arm64 LE": "@esbuild/win32-arm64",
  "win32 ia32 LE": "@esbuild/win32-ia32",
  "win32 x64 LE": "@esbuild/win32-x64"
};
var knownUnixlikePackages = {
  "aix ppc64 BE": "@esbuild/aix-ppc64",
  "android arm64 LE": "@esbuild/android-arm64",
  "darwin arm64 LE": "@esbuild/darwin-arm64",
  "darwin x64 LE": "@esbuild/darwin-x64",
  "freebsd arm64 LE": "@esbuild/freebsd-arm64",
  "freebsd x64 LE": "@esbuild/freebsd-x64",
  "linux arm LE": "@esbuild/linux-arm",
  "linux arm64 LE": "@esbuild/linux-arm64",
  "linux ia32 LE": "@esbuild/linux-ia32",
  "linux mips64el LE": "@esbuild/linux-mips64el",
  "linux ppc64 LE": "@esbuild/linux-ppc64",
  "linux riscv64 LE": "@esbuild/linux-riscv64",
  "linux s390x BE": "@esbuild/linux-s390x",
  "linux x64 LE": "@esbuild/linux-x64",
  "linux loong64 LE": "@esbuild/linux-loong64",
  "netbsd arm64 LE": "@esbuild/netbsd-arm64",
  "netbsd x64 LE": "@esbuild/netbsd-x64",
  "openbsd arm64 LE": "@esbuild/openbsd-arm64",
  "openbsd x64 LE": "@esbuild/openbsd-x64",
  "sunos x64 LE": "@esbuild/sunos-x64"
};
var knownWebAssemblyFallbackPackages = {
  "android arm LE": "@esbuild/android-arm",
  "android x64 LE": "@esbuild/android-x64"
};

function pkgAndSubpathForCurrentPlatform() {
  var pkg;
  var subpath;
  var isWASM = false;
  var platformKey = "".concat(process.platform, " ").concat(os.arch(), " ").concat(os.endianness());

  if (platformKey in knownWindowsPackages) {
    pkg = knownWindowsPackages[platformKey];
    subpath = "esbuild.exe";
  } else if (platformKey in knownUnixlikePackages) {
    pkg = knownUnixlikePackages[platformKey];
    subpath = "bin/esbuild";
  } else if (platformKey in knownWebAssemblyFallbackPackages) {
    pkg = knownWebAssemblyFallbackPackages[platformKey];
    subpath = "bin/esbuild";
    isWASM = true;
  } else {
    throw new Error("Unsupported platform: ".concat(platformKey));
  }

  return {
    pkg: pkg,
    subpath: subpath,
    isWASM: isWASM
  };
}

function downloadedBinPath(pkg, subpath) {
  var esbuildLibDir = path.dirname(require.resolve("esbuild"));
  return path.join(esbuildLibDir, "downloaded-".concat(pkg.replace("/", "-"), "-").concat(path.basename(subpath)));
} // lib/npm/node-install.ts


var fs2 = require("fs");

var os2 = require("os");

var path2 = require("path");

var zlib = require("zlib");

var https = require("https");

var child_process = require("child_process");

var versionFromPackageJSON = require(path2.join(__dirname, "package.json")).version;

var toPath = path2.join(__dirname, "bin", "esbuild");
var isToPathJS = true;

function validateBinaryVersion() {
  for (var _len = arguments.length, command = new Array(_len), _key = 0; _key < _len; _key++) {
    command[_key] = arguments[_key];
  }

  command.push("--version");
  var stdout;

  try {
    stdout = child_process.execFileSync(command.shift(), command, {
      // Without this, this install script strangely crashes with the error
      // "EACCES: permission denied, write" but only on Ubuntu Linux when node is
      // installed from the Snap Store. This is not a problem when you download
      // the official version of node. The problem appears to be that stderr
      // (i.e. file descriptor 2) isn't writable?
      //
      // More info:
      // - https://snapcraft.io/ (what the Snap Store is)
      // - https://nodejs.org/dist/ (download the official version of node)
      // - https://github.com/evanw/esbuild/issues/1711#issuecomment-1027554035
      //
      stdio: "pipe"
    }).toString().trim();
  } catch (err) {
    if (os2.platform() === "darwin" && /_SecTrustEvaluateWithError/.test(err + "")) {
      var os3 = "this version of macOS";

      try {
        os3 = "macOS " + child_process.execFileSync("sw_vers", ["-productVersion"]).toString().trim();
      } catch (_unused) {}

      throw new Error("The \"esbuild\" package cannot be installed because ".concat(os3, " is too outdated.\n\nThe Go compiler (which esbuild relies on) no longer supports ").concat(os3, ",\nwhich means the \"esbuild\" binary executable can't be run. You can either:\n\n  * Update your version of macOS to one that the Go compiler supports\n  * Use the \"esbuild-wasm\" package instead of the \"esbuild\" package\n  * Build esbuild yourself using an older version of the Go compiler\n"));
    }

    throw err;
  }

  if (stdout !== versionFromPackageJSON) {
    throw new Error("Expected ".concat(JSON.stringify(versionFromPackageJSON), " but got ").concat(JSON.stringify(stdout)));
  }
}

function isYarn() {
  var npm_config_user_agent = process.env.npm_config_user_agent;

  if (npm_config_user_agent) {
    return /\byarn\//.test(npm_config_user_agent);
  }

  return false;
}

function fetch(url) {
  return new Promise(function (resolve, reject) {
    https.get(url, function (res) {
      if ((res.statusCode === 301 || res.statusCode === 302) && res.headers.location) return fetch(res.headers.location).then(resolve, reject);
      if (res.statusCode !== 200) return reject(new Error("Server responded with ".concat(res.statusCode)));
      var chunks = [];
      res.on("data", function (chunk) {
        return chunks.push(chunk);
      });
      res.on("end", function () {
        return resolve(Buffer.concat(chunks));
      });
    }).on("error", reject);
  });
}

function extractFileFromTarGzip(buffer, subpath) {
  try {
    buffer = zlib.unzipSync(buffer);
  } catch (err) {
    throw new Error("Invalid gzip data in archive: ".concat(err && err.message || err));
  }

  var str = function str(i, n) {
    return String.fromCharCode.apply(String, _toConsumableArray(buffer.subarray(i, i + n))).replace(/\0.*$/, "");
  };

  var offset = 0;
  subpath = "package/".concat(subpath);

  while (offset < buffer.length) {
    var name = str(offset, 100);
    var size = parseInt(str(offset + 124, 12), 8);
    offset += 512;

    if (!isNaN(size)) {
      if (name === subpath) return buffer.subarray(offset, offset + size);
      offset += size + 511 & ~511;
    }
  }

  throw new Error("Could not find ".concat(JSON.stringify(subpath), " in archive"));
}

function installUsingNPM(pkg, subpath, binPath) {
  var env = _objectSpread({}, process.env, {
    npm_config_global: void 0
  });

  var esbuildLibDir = path2.dirname(require.resolve("esbuild"));
  var installDir = path2.join(esbuildLibDir, "npm-install");
  fs2.mkdirSync(installDir);

  try {
    fs2.writeFileSync(path2.join(installDir, "package.json"), "{}");
    child_process.execSync("npm install --loglevel=error --prefer-offline --no-audit --progress=false ".concat(pkg, "@").concat(versionFromPackageJSON), {
      cwd: installDir,
      stdio: "pipe",
      env: env
    });
    var installedBinPath = path2.join(installDir, "node_modules", pkg, subpath);
    fs2.renameSync(installedBinPath, binPath);
  } finally {
    try {
      removeRecursive(installDir);
    } catch (_unused2) {}
  }
}

function removeRecursive(dir) {
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = fs2.readdirSync(dir)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var entry = _step2.value;
      var entryPath = path2.join(dir, entry);
      var stats = void 0;

      try {
        stats = fs2.lstatSync(entryPath);
      } catch (_unused3) {
        continue;
      }

      if (stats.isDirectory()) removeRecursive(entryPath);else fs2.unlinkSync(entryPath);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  fs2.rmdirSync(dir);
}

function applyManualBinaryPathOverride(overridePath) {
  var pathString = JSON.stringify(overridePath);
  fs2.writeFileSync(toPath, "#!/usr/bin/env node\nrequire('child_process').execFileSync(".concat(pathString, ", process.argv.slice(2), { stdio: 'inherit' });\n"));
  var libMain = path2.join(__dirname, "lib", "main.js");
  var code = fs2.readFileSync(libMain, "utf8");
  fs2.writeFileSync(libMain, "var ESBUILD_BINARY_PATH = ".concat(pathString, ";\n").concat(code));
}

function maybeOptimizePackage(binPath) {
  if (os2.platform() !== "win32" && !isYarn()) {
    var tempPath = path2.join(__dirname, "bin-esbuild");

    try {
      fs2.linkSync(binPath, tempPath);
      fs2.renameSync(tempPath, toPath);
      isToPathJS = false;
      fs2.unlinkSync(tempPath);
    } catch (_unused4) {}
  }
}

function downloadDirectlyFromNPM(pkg, subpath, binPath) {
  var url;
  return regeneratorRuntime.async(function downloadDirectlyFromNPM$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          url = "https://registry.npmjs.org/".concat(pkg, "/-/").concat(pkg.replace("@esbuild/", ""), "-").concat(versionFromPackageJSON, ".tgz");
          console.error("[esbuild] Trying to download ".concat(JSON.stringify(url)));
          _context.prev = 2;
          _context.t0 = fs2;
          _context.t1 = binPath;
          _context.t2 = extractFileFromTarGzip;
          _context.next = 8;
          return regeneratorRuntime.awrap(fetch(url));

        case 8:
          _context.t3 = _context.sent;
          _context.t4 = subpath;
          _context.t5 = (0, _context.t2)(_context.t3, _context.t4);

          _context.t0.writeFileSync.call(_context.t0, _context.t1, _context.t5);

          fs2.chmodSync(binPath, 493);
          _context.next = 19;
          break;

        case 15:
          _context.prev = 15;
          _context.t6 = _context["catch"](2);
          console.error("[esbuild] Failed to download ".concat(JSON.stringify(url), ": ").concat(_context.t6 && _context.t6.message || _context.t6));
          throw _context.t6;

        case 19:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[2, 15]]);
}

function checkAndPreparePackage() {
  var _pkgAndSubpathForCurr, pkg, subpath, binPath;

  return regeneratorRuntime.async(function checkAndPreparePackage$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!isValidBinaryPath(ESBUILD_BINARY_PATH)) {
            _context2.next = 7;
            break;
          }

          if (fs2.existsSync(ESBUILD_BINARY_PATH)) {
            _context2.next = 5;
            break;
          }

          console.warn("[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=".concat(ESBUILD_BINARY_PATH));
          _context2.next = 7;
          break;

        case 5:
          applyManualBinaryPathOverride(ESBUILD_BINARY_PATH);
          return _context2.abrupt("return");

        case 7:
          _pkgAndSubpathForCurr = pkgAndSubpathForCurrentPlatform(), pkg = _pkgAndSubpathForCurr.pkg, subpath = _pkgAndSubpathForCurr.subpath;
          _context2.prev = 8;
          binPath = require.resolve("".concat(pkg, "/").concat(subpath));
          _context2.next = 32;
          break;

        case 12:
          _context2.prev = 12;
          _context2.t0 = _context2["catch"](8);
          console.error("[esbuild] Failed to find package \"".concat(pkg, "\" on the file system\n\nThis can happen if you use the \"--no-optional\" flag. The \"optionalDependencies\"\npackage.json feature is used by esbuild to install the correct binary executable\nfor your current platform. This install script will now attempt to work around\nthis. If that fails, you need to remove the \"--no-optional\" flag to use esbuild.\n"));
          binPath = downloadedBinPath(pkg, subpath);
          _context2.prev = 16;
          console.error("[esbuild] Trying to install package \"".concat(pkg, "\" using npm"));
          installUsingNPM(pkg, subpath, binPath);
          _context2.next = 32;
          break;

        case 21:
          _context2.prev = 21;
          _context2.t1 = _context2["catch"](16);
          console.error("[esbuild] Failed to install package \"".concat(pkg, "\" using npm: ").concat(_context2.t1 && _context2.t1.message || _context2.t1));
          _context2.prev = 24;
          _context2.next = 27;
          return regeneratorRuntime.awrap(downloadDirectlyFromNPM(pkg, subpath, binPath));

        case 27:
          _context2.next = 32;
          break;

        case 29:
          _context2.prev = 29;
          _context2.t2 = _context2["catch"](24);
          throw new Error("Failed to install package \"".concat(pkg, "\""));

        case 32:
          maybeOptimizePackage(binPath);

        case 33:
        case "end":
          return _context2.stop();
      }
    }
  }, null, null, [[8, 12], [16, 21], [24, 29]]);
}

checkAndPreparePackage().then(function () {
  if (isToPathJS) {
    validateBinaryVersion(process.execPath, toPath);
  } else {
    validateBinaryVersion(toPath);
  }
});