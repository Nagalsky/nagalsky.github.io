"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;

var __copyProps = function __copyProps(to, from, except, desc) {
  if (from && _typeof(from) === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
    key = keys[i];
    if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
      get: function (k) {
        return from[k];
      }.bind(null, key),
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    });
  }
  return to;
};

var __toESM = function __toESM(mod, isNodeMode, target) {
  return target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: true
  }) : target, mod);
}; //#endregion


var path = __toESM(require("path"));

var fdir = __toESM(require("fdir"));

var picomatch = __toESM(require("picomatch")); //#region src/utils.ts


var ONLY_PARENT_DIRECTORIES = /^(\/?\.\.)+$/;

function getPartialMatcher(patterns, options) {
  var patternsCount = patterns.length;
  var patternsParts = Array(patternsCount);
  var regexes = Array(patternsCount);

  for (var i = 0; i < patternsCount; i++) {
    var parts = splitPattern(patterns[i]);
    patternsParts[i] = parts;
    var partsCount = parts.length;
    var partRegexes = Array(partsCount);

    for (var j = 0; j < partsCount; j++) {
      partRegexes[j] = picomatch["default"].makeRe(parts[j], options);
    }

    regexes[i] = partRegexes;
  }

  return function (input) {
    var inputParts = input.split("/");
    if (inputParts[0] === ".." && ONLY_PARENT_DIRECTORIES.test(input)) return true;

    for (var _i = 0; _i < patterns.length; _i++) {
      var patternParts = patternsParts[_i];
      var regex = regexes[_i];
      var inputPatternCount = inputParts.length;
      var minParts = Math.min(inputPatternCount, patternParts.length);
      var _j = 0;

      while (_j < minParts) {
        var part = patternParts[_j];
        if (part.includes("/")) return true;

        var match = regex[_j].test(inputParts[_j]);

        if (!match) break;
        if (part === "**") return true;
        _j++;
      }

      if (_j === inputPatternCount) return true;
    }

    return false;
  };
}

var splitPatternOptions = {
  parts: true
};

function splitPattern(path$2) {
  var _result$parts;

  var result = picomatch["default"].scan(path$2, splitPatternOptions);
  return ((_result$parts = result.parts) === null || _result$parts === void 0 ? void 0 : _result$parts.length) ? result.parts : [path$2];
}

var isWin = process.platform === "win32";
var ESCAPED_WIN32_BACKSLASHES = /\\(?![()[\]{}!+@])/g;

function convertPosixPathToPattern(path$2) {
  return escapePosixPath(path$2);
}

function convertWin32PathToPattern(path$2) {
  return escapeWin32Path(path$2).replace(ESCAPED_WIN32_BACKSLASHES, "/");
}

var convertPathToPattern = isWin ? convertWin32PathToPattern : convertPosixPathToPattern;
var POSIX_UNESCAPED_GLOB_SYMBOLS = /(?<!\\)([()[\]{}*?|]|^!|[!+@](?=\()|\\(?![()[\]{}!*+?@|]))/g;
var WIN32_UNESCAPED_GLOB_SYMBOLS = /(?<!\\)([()[\]{}]|^!|[!+@](?=\())/g;

var escapePosixPath = function escapePosixPath(path$2) {
  return path$2.replace(POSIX_UNESCAPED_GLOB_SYMBOLS, "\\$&");
};

var escapeWin32Path = function escapeWin32Path(path$2) {
  return path$2.replace(WIN32_UNESCAPED_GLOB_SYMBOLS, "\\$&");
};

var escapePath = isWin ? escapeWin32Path : escapePosixPath;

function isDynamicPattern(pattern, options) {
  if ((options === null || options === void 0 ? void 0 : options.caseSensitiveMatch) === false) return true;
  var scan = picomatch["default"].scan(pattern);
  return scan.isGlob || scan.negated;
}

function log() {
  var _console;

  for (var _len = arguments.length, tasks = new Array(_len), _key = 0; _key < _len; _key++) {
    tasks[_key] = arguments[_key];
  }

  (_console = console).log.apply(_console, ["[tinyglobby ".concat(new Date().toLocaleTimeString("es"), "]")].concat(tasks));
} //#endregion
//#region src/index.ts


var PARENT_DIRECTORY = /^(\/?\.\.)+/;
var ESCAPING_BACKSLASHES = /\\(?=[()[\]{}!*+?@|])/g;
var BACKSLASHES = /\\/g;

function normalizePattern(pattern, expandDirectories, cwd, props, isIgnore) {
  var result = pattern;
  if (pattern.endsWith("/")) result = pattern.slice(0, -1);
  if (!result.endsWith("*") && expandDirectories) result += "/**";
  var escapedCwd = escapePath(cwd);
  if (path["default"].isAbsolute(result.replace(ESCAPING_BACKSLASHES, ""))) result = path.posix.relative(escapedCwd, result);else result = path.posix.normalize(result);
  var parentDirectoryMatch = PARENT_DIRECTORY.exec(result);
  var parts = splitPattern(result);

  if (parentDirectoryMatch === null || parentDirectoryMatch === void 0 ? void 0 : parentDirectoryMatch[0]) {
    var n = (parentDirectoryMatch[0].length + 1) / 3;
    var i = 0;
    var cwdParts = escapedCwd.split("/");

    while (i < n && parts[i + n] === cwdParts[cwdParts.length + i - n]) {
      result = result.slice(0, (n - i - 1) * 3) + result.slice((n - i) * 3 + parts[i + n].length + 1) || ".";
      i++;
    }

    var potentialRoot = path.posix.join(cwd, parentDirectoryMatch[0].slice(i * 3));

    if (!potentialRoot.startsWith(".") && props.root.length > potentialRoot.length) {
      props.root = potentialRoot;
      props.depthOffset = -n + i;
    }
  }

  if (!isIgnore && props.depthOffset >= 0) {
    var _path$default$posix;

    var _props$commonPath;

    (_props$commonPath = props.commonPath) !== null && _props$commonPath !== void 0 || (props.commonPath = parts);
    var newCommonPath = [];
    var length = Math.min(props.commonPath.length, parts.length);

    for (var _i2 = 0; _i2 < length; _i2++) {
      var part = parts[_i2];

      if (part === "**" && !parts[_i2 + 1]) {
        newCommonPath.pop();
        break;
      }

      if (part !== props.commonPath[_i2] || isDynamicPattern(part) || _i2 === parts.length - 1) break;
      newCommonPath.push(part);
    }

    props.depthOffset = newCommonPath.length;
    props.commonPath = newCommonPath;
    props.root = newCommonPath.length > 0 ? (_path$default$posix = path["default"].posix).join.apply(_path$default$posix, [cwd].concat(newCommonPath)) : cwd;
  }

  return result;
}

function processPatterns(_ref, cwd, props) {
  var patterns = _ref.patterns,
      _ref$ignore = _ref.ignore,
      ignore = _ref$ignore === void 0 ? [] : _ref$ignore,
      _ref$expandDirectorie = _ref.expandDirectories,
      expandDirectories = _ref$expandDirectorie === void 0 ? true : _ref$expandDirectorie;
  if (typeof patterns === "string") patterns = [patterns];else if (!patterns) patterns = ["**/*"];
  if (typeof ignore === "string") ignore = [ignore];
  var matchPatterns = [];
  var ignorePatterns = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = ignore[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var pattern = _step.value;
      if (!pattern) continue;
      if (pattern[0] !== "!" || pattern[1] === "(") ignorePatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, true));
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = patterns[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _pattern = _step2.value;
      if (!_pattern) continue;
      if (_pattern[0] !== "!" || _pattern[1] === "(") matchPatterns.push(normalizePattern(_pattern, expandDirectories, cwd, props, false));else if (_pattern[1] !== "!" || _pattern[2] === "(") ignorePatterns.push(normalizePattern(_pattern.slice(1), expandDirectories, cwd, props, true));
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return {
    match: matchPatterns,
    ignore: ignorePatterns
  };
}

function getRelativePath(path$2, cwd, root) {
  return path.posix.relative(cwd, "".concat(root, "/").concat(path$2)) || ".";
}

function processPath(path$2, cwd, root, isDirectory, absolute) {
  var relativePath = absolute ? path$2.slice(root === "/" ? 1 : root.length + 1) || "." : path$2;
  if (root === cwd) return isDirectory && relativePath !== "." ? relativePath.slice(0, -1) : relativePath;
  return getRelativePath(relativePath, cwd, root);
}

function formatPaths(paths, cwd, root) {
  for (var i = paths.length - 1; i >= 0; i--) {
    var path$2 = paths[i];
    paths[i] = getRelativePath(path$2, cwd, root) + (!path$2 || path$2.endsWith("/") ? "/" : "");
  }

  return paths;
}

function crawl(options, cwd, sync) {
  if (process.env.TINYGLOBBY_DEBUG) options.debug = true;
  if (options.debug) log("globbing with options:", options, "cwd:", cwd);
  if (Array.isArray(options.patterns) && options.patterns.length === 0) return sync ? [] : Promise.resolve([]);
  var props = {
    root: cwd,
    commonPath: null,
    depthOffset: 0
  };
  var processed = processPatterns(options, cwd, props);
  var nocase = options.caseSensitiveMatch === false;
  if (options.debug) log("internal processing patterns:", processed);
  var matcher = (0, picomatch["default"])(processed.match, {
    dot: options.dot,
    nocase: nocase,
    ignore: processed.ignore
  });
  var ignore = (0, picomatch["default"])(processed.ignore, {
    dot: options.dot,
    nocase: nocase
  });
  var partialMatcher = getPartialMatcher(processed.match, {
    dot: options.dot,
    nocase: nocase
  });
  var fdirOptions = {
    filters: [options.debug ? function (p, isDirectory) {
      var path$2 = processPath(p, cwd, props.root, isDirectory, options.absolute);
      var matches = matcher(path$2);
      if (matches) log("matched ".concat(path$2));
      return matches;
    } : function (p, isDirectory) {
      return matcher(processPath(p, cwd, props.root, isDirectory, options.absolute));
    }],
    exclude: options.debug ? function (_, p) {
      var relativePath = processPath(p, cwd, props.root, true, true);
      var skipped = relativePath !== "." && !partialMatcher(relativePath) || ignore(relativePath);
      if (skipped) log("skipped ".concat(p));else log("crawling ".concat(p));
      return skipped;
    } : function (_, p) {
      var relativePath = processPath(p, cwd, props.root, true, true);
      return relativePath !== "." && !partialMatcher(relativePath) || ignore(relativePath);
    },
    pathSeparator: "/",
    relativePaths: true,
    resolveSymlinks: true
  };
  if (options.deep !== void 0) fdirOptions.maxDepth = Math.round(options.deep - props.depthOffset);

  if (options.absolute) {
    fdirOptions.relativePaths = false;
    fdirOptions.resolvePaths = true;
    fdirOptions.includeBasePath = true;
  }

  if (options.followSymbolicLinks === false) {
    fdirOptions.resolveSymlinks = false;
    fdirOptions.excludeSymlinks = true;
  }

  if (options.onlyDirectories) {
    fdirOptions.excludeFiles = true;
    fdirOptions.includeDirs = true;
  } else if (options.onlyFiles === false) fdirOptions.includeDirs = true;

  props.root = props.root.replace(BACKSLASHES, "");
  var root = props.root;
  if (options.debug) log("internal properties:", props);
  var api = new fdir.fdir(fdirOptions).crawl(root);
  if (cwd === root || options.absolute) return sync ? api.sync() : api.withPromise();
  return sync ? formatPaths(api.sync(), cwd, root) : api.withPromise().then(function (paths) {
    return formatPaths(paths, cwd, root);
  });
}

function glob(patternsOrOptions, options) {
  var opts, cwd;
  return regeneratorRuntime.async(function glob$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!(patternsOrOptions && (options === null || options === void 0 ? void 0 : options.patterns))) {
            _context.next = 2;
            break;
          }

          throw new Error("Cannot pass patterns as both an argument and an option");

        case 2:
          opts = Array.isArray(patternsOrOptions) || typeof patternsOrOptions === "string" ? _objectSpread({}, options, {
            patterns: patternsOrOptions
          }) : patternsOrOptions;
          cwd = opts.cwd ? path["default"].resolve(opts.cwd).replace(BACKSLASHES, "/") : process.cwd().replace(BACKSLASHES, "/");
          return _context.abrupt("return", crawl(opts, cwd, false));

        case 5:
        case "end":
          return _context.stop();
      }
    }
  });
}

function globSync(patternsOrOptions, options) {
  if (patternsOrOptions && (options === null || options === void 0 ? void 0 : options.patterns)) throw new Error("Cannot pass patterns as both an argument and an option");
  var opts = Array.isArray(patternsOrOptions) || typeof patternsOrOptions === "string" ? _objectSpread({}, options, {
    patterns: patternsOrOptions
  }) : patternsOrOptions;
  var cwd = opts.cwd ? path["default"].resolve(opts.cwd).replace(BACKSLASHES, "/") : process.cwd().replace(BACKSLASHES, "/");
  return crawl(opts, cwd, true);
} //#endregion


exports.convertPathToPattern = convertPathToPattern;
exports.escapePath = escapePath;
exports.glob = glob;
exports.globSync = globSync;
exports.isDynamicPattern = isDynamicPattern;