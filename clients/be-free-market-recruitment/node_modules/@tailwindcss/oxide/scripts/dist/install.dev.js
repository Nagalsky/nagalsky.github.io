#!/usr/bin/env node

/**
 * @tailwindcss/oxide postinstall script
 *
 * This script ensures that the correct binary for the current platform and
 * architecture is downloaded and available.
 */
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var fs = require('fs');

var path = require('path');

var https = require('https');

var _require = require('tar'),
    extract = _require.extract;

var packageJson = require('../package.json');

var detectLibc = require('detect-libc');

var version = packageJson.version;

function getPlatformPackageName() {
  var platform = process.platform;
  var arch = process.arch;
  var libc = '';

  if (platform === 'linux') {
    libc = detectLibc.isNonGlibcLinuxSync() ? 'musl' : 'gnu';
  } // Map to our package naming conventions


  switch (platform) {
    case 'darwin':
      return arch === 'arm64' ? '@tailwindcss/oxide-darwin-arm64' : '@tailwindcss/oxide-darwin-x64';

    case 'win32':
      if (arch === 'arm64') return '@tailwindcss/oxide-win32-arm64-msvc';
      if (arch === 'ia32') return '@tailwindcss/oxide-win32-ia32-msvc';
      return '@tailwindcss/oxide-win32-x64-msvc';

    case 'linux':
      if (arch === 'x64') {
        return libc === 'musl' ? '@tailwindcss/oxide-linux-x64-musl' : '@tailwindcss/oxide-linux-x64-gnu';
      } else if (arch === 'arm64') {
        return libc === 'musl' ? '@tailwindcss/oxide-linux-arm64-musl' : '@tailwindcss/oxide-linux-arm64-gnu';
      } else if (arch === 'arm') {
        return '@tailwindcss/oxide-linux-arm-gnueabihf';
      }

      break;

    case 'freebsd':
      return '@tailwindcss/oxide-freebsd-x64';

    case 'android':
      return '@tailwindcss/oxide-android-arm64';

    default:
      return '@tailwindcss/oxide-wasm32-wasi';
  }
}

function isPackageAvailable(packageName) {
  try {
    require.resolve(packageName);

    return true;
  } catch (e) {
    return false;
  }
} // Extract all files from a tarball to a destination directory


function extractTarball(tarballStream, destDir) {
  return regeneratorRuntime.async(function extractTarball$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!fs.existsSync(destDir)) {
            fs.mkdirSync(destDir, {
              recursive: true
            });
          }

          return _context.abrupt("return", new Promise(function (resolve, reject) {
            tarballStream.pipe(extract({
              cwd: destDir,
              strip: 1
            })).on('error', function (err) {
              return reject(err);
            }).on('end', function () {
              return resolve();
            });
          }));

        case 2:
        case "end":
          return _context.stop();
      }
    }
  });
}

function downloadAndExtractBinary(packageName) {
  var tarballUrl;
  return regeneratorRuntime.async(function downloadAndExtractBinary$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          tarballUrl = "https://registry.npmjs.org/".concat(packageName, "/-/").concat(packageName.replace('@tailwindcss/', ''), "-").concat(version, ".tgz");
          console.log("Downloading ".concat(tarballUrl, "..."));
          return _context3.abrupt("return", new Promise(function (resolve) {
            https.get(tarballUrl, function (response) {
              if (response.statusCode === 302 || response.statusCode === 301) {
                // Handle redirects
                https.get(response.headers.location, handleResponse).on('error', function (err) {
                  console.error('Download error:', err);
                  resolve();
                });
                return;
              }

              handleResponse(response);

              function handleResponse(response) {
                return regeneratorRuntime.async(function handleResponse$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.prev = 0;

                        if (!(response.statusCode !== 200)) {
                          _context2.next = 3;
                          break;
                        }

                        throw new Error("Download failed with status code: ".concat(response.statusCode));

                      case 3:
                        _context2.next = 5;
                        return regeneratorRuntime.awrap(extractTarball(response, path.join.apply(path, [__dirname, '..', 'node_modules'].concat(_toConsumableArray(packageName.split('/'))))));

                      case 5:
                        console.log("Successfully downloaded and installed ".concat(packageName));
                        _context2.next = 12;
                        break;

                      case 8:
                        _context2.prev = 8;
                        _context2.t0 = _context2["catch"](0);
                        console.error('Error during extraction:', _context2.t0);
                        resolve();

                      case 12:
                        _context2.prev = 12;
                        resolve();
                        return _context2.finish(12);

                      case 15:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, null, null, [[0, 8, 12, 15]]);
              }
            }).on('error', function (err) {
              console.error('Download error:', err);
              resolve();
            });
          }));

        case 3:
        case "end":
          return _context3.stop();
      }
    }
  });
}

function main() {
  var packageName;
  return regeneratorRuntime.async(function main$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.prev = 0;

          if (!fs.existsSync(path.join(__dirname, '..', 'build.rs'))) {
            _context4.next = 3;
            break;
          }

          return _context4.abrupt("return");

        case 3:
          packageName = getPlatformPackageName();

          if (packageName) {
            _context4.next = 6;
            break;
          }

          return _context4.abrupt("return");

        case 6:
          if (!isPackageAvailable(packageName)) {
            _context4.next = 8;
            break;
          }

          return _context4.abrupt("return");

        case 8:
          _context4.next = 10;
          return regeneratorRuntime.awrap(downloadAndExtractBinary(packageName));

        case 10:
          _context4.next = 16;
          break;

        case 12:
          _context4.prev = 12;
          _context4.t0 = _context4["catch"](0);
          console.error(_context4.t0);
          return _context4.abrupt("return");

        case 16:
        case "end":
          return _context4.stop();
      }
    }
  }, null, null, [[0, 12]]);
}

main();